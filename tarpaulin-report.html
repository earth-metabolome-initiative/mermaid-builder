<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>:root {
  --color: black;
  --bg: white;
  --head-bg: white;
  --link: #338;

  --blue: #ccf;
  --red: #fcc;
  --yellow: #ffc;
  --green: #cfc;
}

[data-theme='dark'] {
  --color: white;
  --bg: black;
  --head-bg: #333;
  --link: #aaf;

  --blue: #225;
  --red: #522;
  --yellow: #552;
  --green: #252;
}

html,
body {
  margin: 0;
  padding: 0;
  color: var(--color);
  background: var(--bg);
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: var(--head-bg);
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: var(--blue);
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: var(--red);
}
.files-list__file_medium {
  background: var(--yellow);
}
.files-list__file_high {
  background: var(--green);
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: var(--bg);
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: var(--link);
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
  content: counter(line);
  margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: var(--green);
}
.code-line_uncovered {
  background: var(--red);
}

#theme-toggle-label {
  margin-left: 1ch;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","home","lucac","github","mermaid-builder","src","diagrams","class_diagram","class_edge","builder.rs"],"content":"//! Submodule defining a builder for class edges in class diagrams\n//! in Mermaid syntax.\n\nuse crate::{\n    diagrams::class_diagram::{\n        class_edge::{ClassEdge, multiplicity::Multiplicity},\n        class_node::ClassNode,\n    },\n    errors::EdgeError,\n    shared::generic_edge::GenericEdgeBuilder,\n    traits::EdgeBuilder,\n};\n\n#[derive(Default, Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// Builder for creating a `ClassEdge`.\n///\n/// # Example\n///\n/// ```\n/// use std::rc::Rc;\n///\n/// use mermaid_builder::prelude::*;\n///\n/// let node1 = Rc::new(ClassNodeBuilder::default().label(\"A\").unwrap().id(0).build().unwrap());\n/// let node2 = Rc::new(ClassNodeBuilder::default().label(\"B\").unwrap().id(1).build().unwrap());\n///\n/// let edge = ClassEdgeBuilder::default()\n///     .source(node1)\n///     .unwrap()\n///     .destination(node2)\n///     .unwrap()\n///     .right_arrow_shape(ArrowShape::Triangle)\n///     .unwrap()\n///     .build()\n///     .unwrap();\n/// ```\npub struct ClassEdgeBuilder {\n    /// Underlying generic edge builder.\n    edge_builder: GenericEdgeBuilder\u003cClassNode\u003e,\n    /// Left Multiplicity of the edge.\n    left_multiplicity: Option\u003cMultiplicity\u003e,\n    /// Right Multiplicity of the edge.\n    right_multiplicity: Option\u003cMultiplicity\u003e,\n}\n\nimpl ClassEdgeBuilder {\n    /// Sets the left multiplicity of the edge.\n    #[must_use]\n    pub fn left_multiplicity(mut self, multiplicity: Multiplicity) -\u003e Self {\n        self.left_multiplicity = Some(multiplicity);\n        self\n    }\n\n    /// Sets the right multiplicity of the edge.\n    #[must_use]\n    pub fn right_multiplicity(mut self, multiplicity: Multiplicity) -\u003e Self {\n        self.right_multiplicity = Some(multiplicity);\n        self\n    }\n}\n\nimpl TryFrom\u003cClassEdgeBuilder\u003e for ClassEdge {\n    type Error = EdgeError;\n\n    fn try_from(builder: ClassEdgeBuilder) -\u003e Result\u003cSelf, Self::Error\u003e {\n        Ok(ClassEdge {\n            edge: builder.edge_builder.try_into()?,\n            left_multiplicity: builder.left_multiplicity,\n            right_multiplicity: builder.right_multiplicity,\n        })\n    }\n}\n\nimpl EdgeBuilder for ClassEdgeBuilder {\n    type Edge = ClassEdge;\n    type Node = ClassNode;\n    type Error = EdgeError;\n\n    fn build(self) -\u003e Result\u003cSelf::Edge, Self::Error\u003e {\n        self.try_into()\n    }\n\n    fn source(mut self, node: std::rc::Rc\u003cSelf::Node\u003e) -\u003e Result\u003cSelf, Self::Error\u003e {\n        self.edge_builder = self.edge_builder.source(node)?;\n        Ok(self)\n    }\n\n    fn destination(mut self, node: std::rc::Rc\u003cSelf::Node\u003e) -\u003e Result\u003cSelf, Self::Error\u003e {\n        self.edge_builder = self.edge_builder.destination(node)?;\n        Ok(self)\n    }\n\n    fn label\u003cS: ToString\u003e(mut self, label: S) -\u003e Result\u003cSelf, Self::Error\u003e {\n        self.edge_builder = self.edge_builder.label(label)?;\n        Ok(self)\n    }\n\n    fn line_style(mut self, style: crate::shared::LineStyle) -\u003e Self {\n        self.edge_builder = self.edge_builder.line_style(style);\n        self\n    }\n\n    fn left_arrow_shape(mut self, shape: crate::shared::ArrowShape) -\u003e Result\u003cSelf, Self::Error\u003e {\n        self.edge_builder = self.edge_builder.left_arrow_shape(shape)?;\n        Ok(self)\n    }\n\n    fn right_arrow_shape(mut self, shape: crate::shared::ArrowShape) -\u003e Result\u003cSelf, Self::Error\u003e {\n        self.edge_builder = self.edge_builder.right_arrow_shape(shape)?;\n        Ok(self)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use std::rc::Rc;\n\n    use super::*;\n    use crate::{\n        diagrams::class_diagram::class_node::ClassNodeBuilder,\n        shared::{ArrowShape, LineStyle},\n        traits::{NodeBuilder, edge::Edge, node::Node},\n    };\n\n    #[test]\n    fn test_class_edge_builder() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n        let node1 = Rc::new(ClassNodeBuilder::default().label(\"A\")?.id(0).build()?);\n        let node2 = Rc::new(ClassNodeBuilder::default().label(\"B\")?.id(1).build()?);\n\n        let edge = ClassEdgeBuilder::default()\n            .source(node1.clone())?\n            .destination(node2.clone())?\n            .label(\"Edge Label\")?\n            .line_style(LineStyle::Dashed)\n            .left_multiplicity(Multiplicity::One)\n            .right_multiplicity(Multiplicity::Many)\n            .left_arrow_shape(ArrowShape::Circle)?\n            .right_arrow_shape(ArrowShape::Triangle)?\n            .build()?;\n\n        assert_eq!(edge.source().id(), 0);\n        assert_eq!(edge.destination().id(), 1);\n        assert_eq!(edge.label(), Some(\"Edge Label\"));\n        assert_eq!(edge.line_style(), LineStyle::Dashed);\n        assert_eq!(edge.left_multiplicity, Some(Multiplicity::One));\n        assert_eq!(edge.right_multiplicity, Some(Multiplicity::Many));\n        assert_eq!(edge.left_arrow_shape(), Some(ArrowShape::Circle));\n        assert_eq!(edge.right_arrow_shape(), Some(ArrowShape::Triangle));\n        Ok(())\n    }\n}\n","traces":[{"line":50,"address":[571424],"length":1,"stats":{"Line":1}},{"line":51,"address":[571442],"length":1,"stats":{"Line":1}},{"line":52,"address":[571445],"length":1,"stats":{"Line":1}},{"line":57,"address":[571472],"length":1,"stats":{"Line":1}},{"line":58,"address":[571490],"length":1,"stats":{"Line":1}},{"line":59,"address":[571493],"length":1,"stats":{"Line":1}},{"line":66,"address":[640224],"length":1,"stats":{"Line":1}},{"line":67,"address":[640526],"length":1,"stats":{"Line":1}},{"line":68,"address":[640246],"length":1,"stats":{"Line":1}},{"line":69,"address":[640512],"length":1,"stats":{"Line":1}},{"line":70,"address":[640519],"length":1,"stats":{"Line":1}},{"line":80,"address":[573056],"length":1,"stats":{"Line":1}},{"line":81,"address":[573069],"length":1,"stats":{"Line":1}},{"line":84,"address":[573529,573554,573120],"length":1,"stats":{"Line":1}},{"line":85,"address":[573527,573150,573280],"length":1,"stats":{"Line":2}},{"line":86,"address":[573465],"length":1,"stats":{"Line":1}},{"line":89,"address":[572121,571712,572146],"length":1,"stats":{"Line":1}},{"line":90,"address":[571742,571872,572119],"length":1,"stats":{"Line":2}},{"line":91,"address":[572057],"length":1,"stats":{"Line":1}},{"line":94,"address":[577242,576800,577217],"length":1,"stats":{"Line":1}},{"line":95,"address":[576838,576968,577215],"length":1,"stats":{"Line":2}},{"line":96,"address":[577153],"length":1,"stats":{"Line":1}},{"line":99,"address":[571584],"length":1,"stats":{"Line":1}},{"line":100,"address":[571619],"length":1,"stats":{"Line":1}},{"line":101,"address":[571686],"length":1,"stats":{"Line":1}},{"line":104,"address":[572598,572573,572160],"length":1,"stats":{"Line":1}},{"line":105,"address":[572571,572191,572324],"length":1,"stats":{"Line":2}},{"line":106,"address":[572509],"length":1,"stats":{"Line":1}},{"line":109,"address":[572608,573021,573046],"length":1,"stats":{"Line":1}},{"line":110,"address":[572639,573019,572772],"length":1,"stats":{"Line":2}},{"line":111,"address":[572957],"length":1,"stats":{"Line":1}}],"covered":31,"coverable":31},{"path":["/","home","lucac","github","mermaid-builder","src","diagrams","class_diagram","class_edge","multiplicity.rs"],"content":"//! Submodule defining the multiplicities which may be used to characterize\n//! a class edge in a class diagram in Mermaid syntax.\n//!\n//! The different cardinality options are :\n//!\n//! - `1` Only 1\n//! - `0..1` Zero or One\n//! - `1..*` One or more\n//! - `*` Many\n//! - `n` n (where n\u003e1)\n//! - `0..n` zero to n (where n\u003e1)\n//! - `1..n` one to n (where n\u003e1)\n\nuse std::fmt::Display;\n\n#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// An enumeration representing the multiplicity of a class edge in a Mermaid\n/// class diagram.\npub enum Multiplicity {\n    /// Only 1\n    One,\n    /// Zero or One\n    ZeroOrOne,\n    /// One or more\n    OneOrMore,\n    /// Many, which is analogous to `Zero or More`\n    Many,\n    /// n (where n\u003e1)\n    N,\n    /// Zero to n (where n\u003e1)\n    ZeroToN,\n    /// One to n (where n\u003e1)\n    OneToN,\n}\n\nimpl Display for Multiplicity {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Multiplicity::One =\u003e write!(f, \"1\"),\n            Multiplicity::ZeroOrOne =\u003e write!(f, \"0..1\"),\n            Multiplicity::OneOrMore =\u003e write!(f, \"1..*\"),\n            Multiplicity::Many =\u003e write!(f, \"*\"),\n            Multiplicity::N =\u003e write!(f, \"n\"),\n            Multiplicity::ZeroToN =\u003e write!(f, \"0..n\"),\n            Multiplicity::OneToN =\u003e write!(f, \"1..n\"),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_multiplicity_display() {\n        assert_eq!(Multiplicity::One.to_string(), \"1\");\n        assert_eq!(Multiplicity::ZeroOrOne.to_string(), \"0..1\");\n        assert_eq!(Multiplicity::OneOrMore.to_string(), \"1..*\");\n        assert_eq!(Multiplicity::Many.to_string(), \"*\");\n        assert_eq!(Multiplicity::N.to_string(), \"n\");\n        assert_eq!(Multiplicity::ZeroToN.to_string(), \"0..n\");\n        assert_eq!(Multiplicity::OneToN.to_string(), \"1..n\");\n    }\n}\n","traces":[{"line":38,"address":[535152],"length":1,"stats":{"Line":1}},{"line":39,"address":[535170],"length":1,"stats":{"Line":1}},{"line":40,"address":[535201],"length":1,"stats":{"Line":1}},{"line":41,"address":[535241],"length":1,"stats":{"Line":1}},{"line":42,"address":[535281],"length":1,"stats":{"Line":1}},{"line":43,"address":[535321],"length":1,"stats":{"Line":1}},{"line":44,"address":[535358],"length":1,"stats":{"Line":1}},{"line":45,"address":[535395],"length":1,"stats":{"Line":1}},{"line":46,"address":[535432],"length":1,"stats":{"Line":1}}],"covered":9,"coverable":9},{"path":["/","home","lucac","github","mermaid-builder","src","diagrams","class_diagram","class_edge.rs"],"content":"//! Submodule defining an edge which may be used in a flowchart diagram\n//! in Mermaid syntax.\n\nuse std::{fmt::Display, rc::Rc};\n\nuse crate::{\n    diagrams::class_diagram::{class_edge::multiplicity::Multiplicity, class_node::ClassNode},\n    shared::{ArrowShape, GenericEdge, LineStyle, NODE_LETTER},\n    traits::{Edge, node::Node},\n};\n\npub mod builder;\npub mod multiplicity;\npub use builder::ClassEdgeBuilder;\n\n#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// An edge in a Mermaid class diagram, connecting two class nodes with optional\n/// multiplicities.\n///\n/// # Examples\n///\n/// ```\n/// use std::rc::Rc;\n///\n/// use mermaid_builder::{\n///     diagrams::class_diagram::{ClassEdgeBuilder, ClassNodeBuilder},\n///     traits::{EdgeBuilder, NodeBuilder},\n/// };\n///\n/// fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n///     let node1 = Rc::new(ClassNodeBuilder::default().label(\"A\")?.id(1).build()?);\n///     let node2 = Rc::new(ClassNodeBuilder::default().label(\"B\")?.id(2).build()?);\n///\n///     let edge = ClassEdgeBuilder::default().source(node1)?.destination(node2)?.build()?;\n///     Ok(())\n/// }\n/// ```\npub struct ClassEdge {\n    /// Underlying generic edge.\n    edge: GenericEdge\u003cClassNode\u003e,\n    /// Left multiplicity of the edge.\n    left_multiplicity: Option\u003cMultiplicity\u003e,\n    /// Right multiplicity of the edge.\n    right_multiplicity: Option\u003cMultiplicity\u003e,\n}\n\nimpl Edge for ClassEdge {\n    type Builder = ClassEdgeBuilder;\n    type Node = ClassNode;\n\n    fn label(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n        self.edge.label()\n    }\n\n    fn source(\u0026self) -\u003e \u0026Rc\u003cSelf::Node\u003e {\n        self.edge.source()\n    }\n\n    fn destination(\u0026self) -\u003e \u0026Rc\u003cSelf::Node\u003e {\n        self.edge.destination()\n    }\n\n    fn line_style(\u0026self) -\u003e LineStyle {\n        self.edge.line_style()\n    }\n\n    fn classes(\u0026self) -\u003e impl Iterator\u003cItem = \u0026crate::shared::StyleClass\u003e {\n        std::iter::empty()\n    }\n\n    fn left_arrow_shape(\u0026self) -\u003e Option\u003cArrowShape\u003e {\n        self.edge.left_arrow_shape()\n    }\n\n    fn right_arrow_shape(\u0026self) -\u003e Option\u003cArrowShape\u003e {\n        self.edge.right_arrow_shape()\n    }\n}\n\nimpl Display for ClassEdge {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        use crate::traits::TabbedDisplay;\n        self.fmt_tabbed(f, 0)\n    }\n}\n\nimpl crate::traits::TabbedDisplay for ClassEdge {\n    fn fmt_tabbed(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e, tab_count: usize) -\u003e std::fmt::Result {\n        let indent = \" \".repeat(tab_count * 2);\n        writeln!(\n            f,\n            \"{indent}{NODE_LETTER}{} {left_multiplicity}{left_arrow}{segment}{right_arrow}{right_multiplicity} {NODE_LETTER}{}{}\",\n            self.source().id(),\n            self.destination().id(),\n            self.label().map_or_else(String::new, |label| format!(\" : \\\"`{label}`\\\"\")),\n            left_multiplicity =\n                self.left_multiplicity.as_ref().map_or_else(String::new, |lm| format!(\"{lm} \")),\n            left_arrow = self.left_arrow_shape().as_ref().map_or_else(|| \"\", |shape| shape.left()),\n            segment = match self.line_style() {\n                LineStyle::Solid =\u003e \"--\",\n                LineStyle::Thick =\u003e \"==\",\n                LineStyle::Dashed =\u003e \"..\",\n            },\n            right_arrow =\n                self.right_arrow_shape().as_ref().map_or_else(|| \"\", |shape| shape.right()),\n            right_multiplicity =\n                self.right_multiplicity.as_ref().map_or_else(String::new, |rm| format!(\" {rm}\")),\n        )\n    }\n}\n","traces":[{"line":52,"address":[637504],"length":1,"stats":{"Line":1}},{"line":53,"address":[637509],"length":1,"stats":{"Line":1}},{"line":56,"address":[637520],"length":1,"stats":{"Line":1}},{"line":57,"address":[637525],"length":1,"stats":{"Line":1}},{"line":60,"address":[637456],"length":1,"stats":{"Line":1}},{"line":61,"address":[637461],"length":1,"stats":{"Line":1}},{"line":64,"address":[637440],"length":1,"stats":{"Line":1}},{"line":65,"address":[637445],"length":1,"stats":{"Line":1}},{"line":68,"address":[637536],"length":1,"stats":{"Line":0}},{"line":69,"address":[637541],"length":1,"stats":{"Line":0}},{"line":72,"address":[637472],"length":1,"stats":{"Line":1}},{"line":73,"address":[637477],"length":1,"stats":{"Line":1}},{"line":76,"address":[637488],"length":1,"stats":{"Line":1}},{"line":77,"address":[637493],"length":1,"stats":{"Line":1}},{"line":82,"address":[640192],"length":1,"stats":{"Line":0}},{"line":84,"address":[640206],"length":1,"stats":{"Line":0}},{"line":89,"address":[639290,637616,639296],"length":1,"stats":{"Line":0}},{"line":90,"address":[637743,637666],"length":1,"stats":{"Line":0}},{"line":91,"address":[638519,638110,638027],"length":1,"stats":{"Line":0}},{"line":94,"address":[637728,637808],"length":1,"stats":{"Line":0}},{"line":95,"address":[637870],"length":1,"stats":{"Line":0}},{"line":96,"address":[637955],"length":1,"stats":{"Line":0}},{"line":98,"address":[638011,638084],"length":1,"stats":{"Line":0}},{"line":99,"address":[638155,638099],"length":1,"stats":{"Line":0}},{"line":100,"address":[638238],"length":1,"stats":{"Line":0}},{"line":101,"address":[638284],"length":1,"stats":{"Line":0}},{"line":102,"address":[638313],"length":1,"stats":{"Line":0}},{"line":103,"address":[638342],"length":1,"stats":{"Line":0}},{"line":106,"address":[638377],"length":1,"stats":{"Line":0}},{"line":108,"address":[638475],"length":1,"stats":{"Line":0}}],"covered":12,"coverable":30},{"path":["/","home","lucac","github","mermaid-builder","src","diagrams","class_diagram","class_node","builder.rs"],"content":"//! Submodule defining a builder struct for the class node in class diagrams.\n\nuse std::rc::Rc;\n\nuse crate::{\n    diagrams::class_diagram::class_node::{ClassAttribute, ClassMethod, ClassNode},\n    errors::NodeError,\n    shared::{ClickEvent, StyleClass, StyleClassError, generic_node::GenericNodeBuilder},\n    traits::NodeBuilder,\n};\n\n/// Builder for `ClassNode`.\n///\n/// # Example\n///\n/// ```\n/// use mermaid_builder::prelude::*;\n///\n/// let node = ClassNodeBuilder::default()\n///     .label(\"MyClass\")\n///     .unwrap()\n///     .annotation(\"interface\")\n///     .id(0)\n///     .build()\n///     .unwrap();\n/// ```\n#[derive(Default, Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\npub struct ClassNodeBuilder {\n    /// Underlying generic node builder.\n    builder: GenericNodeBuilder,\n    /// The click event associated with the node, if any.\n    click_event: Option\u003cClickEvent\u003e,\n    /// The annotation of the class node, which usually\n    /// contains functional information such as `trait`, `interface`, etc.\n    annotation: Option\u003cString\u003e,\n    /// Attributes of the class node.\n    attributes: Vec\u003cClassAttribute\u003e,\n    /// Methods of the class node.\n    methods: Vec\u003cClassMethod\u003e,\n}\n\nimpl ClassNodeBuilder {\n    /// Sets the click event for the class node.\n    #[must_use]\n    pub fn click_event(mut self, click_event: ClickEvent) -\u003e Self {\n        self.click_event = Some(click_event);\n        self\n    }\n\n    /// Sets the annotation for the class node.\n    #[must_use]\n    pub fn annotation\u003cS: ToString + ?Sized\u003e(mut self, annotation: \u0026S) -\u003e Self {\n        self.annotation = Some(annotation.to_string());\n        self\n    }\n\n    /// Adds an attribute to the class node.\n    #[must_use]\n    pub fn attribute(mut self, attribute: ClassAttribute) -\u003e Self {\n        self.attributes.push(attribute);\n        self\n    }\n\n    /// Adds a method to the class node.\n    #[must_use]\n    pub fn method(mut self, method: ClassMethod) -\u003e Self {\n        self.methods.push(method);\n        self\n    }\n}\n\nimpl TryFrom\u003cClassNodeBuilder\u003e for ClassNode {\n    type Error = NodeError;\n\n    fn try_from(builder: ClassNodeBuilder) -\u003e Result\u003cSelf, Self::Error\u003e {\n        Ok(ClassNode {\n            node: builder.builder.try_into()?,\n            click_event: builder.click_event,\n            annotation: builder.annotation,\n            attributes: builder.attributes,\n            methods: builder.methods,\n        })\n    }\n}\n\nimpl NodeBuilder for ClassNodeBuilder {\n    type Node = ClassNode;\n    type Error = NodeError;\n\n    fn build(self) -\u003e Result\u003cSelf::Node, Self::Error\u003e {\n        self.try_into()\n    }\n\n    fn id(mut self, id: u64) -\u003e Self {\n        self.builder = self.builder.id(id);\n        self\n    }\n\n    fn get_id(\u0026self) -\u003e Option\u003cu64\u003e {\n        self.builder.get_id()\n    }\n\n    fn label\u003cS: ToString\u003e(mut self, label: S) -\u003e Result\u003cSelf, Self::Error\u003e {\n        self.builder = self.builder.label(label)?;\n        Ok(self)\n    }\n\n    fn get_label(\u0026self) -\u003e Option\u003c\u0026String\u003e {\n        self.builder.get_label()\n    }\n\n    fn style_class(mut self, style_class: Rc\u003cStyleClass\u003e) -\u003e Result\u003cSelf, StyleClassError\u003e {\n        self.builder = self.builder.style_class(style_class)?;\n        Ok(self)\n    }\n\n    fn style_property(\n        mut self,\n        property: crate::shared::StyleProperty,\n    ) -\u003e Result\u003cSelf, StyleClassError\u003e {\n        self.builder = self.builder.style_property(property)?;\n        Ok(self)\n    }\n\n    fn style_properties(\u0026self) -\u003e impl Iterator\u003cItem = \u0026crate::prelude::StyleProperty\u003e {\n        self.builder.style_properties()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::{\n        diagrams::class_diagram::class_node::{ClassAttribute, ClassMethod},\n        shared::{\n            ClickEvent, StyleClassBuilder, StyleProperty,\n            click_event::Navigation,\n            style_class::Unit,\n        },\n        traits::node::Node,\n    };\n\n    #[test]\n    fn test_class_node_builder() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n        let style_class = Rc::new(\n            StyleClassBuilder::default()\n                .name(\"test\")?\n                .property(StyleProperty::StrokeWidth(Unit::Pixel(2)))?\n                .build()?,\n        );\n        \n        let node = ClassNodeBuilder::default()\n            .id(1)\n            .label(\"MyClass\")?\n            .annotation(\"interface\")\n            .attribute(ClassAttribute::new(\"int\", \"id\"))\n            .method(ClassMethod::new(\"void\", \"method\", vec![]))\n            .click_event(ClickEvent::Navigation(Navigation::new(\"https://example.com\")))\n            .style_class(style_class.clone())?\n            .style_property(StyleProperty::StrokeWidth(Unit::Pixel(2)))?\n            .build()?;\n\n        assert_eq!(node.id(), 1);\n        assert_eq!(node.label(), \"MyClass\");\n        assert_eq!(node.annotation, Some(\"interface\".to_string()));\n        assert_eq!(node.attributes.len(), 1);\n        assert_eq!(node.methods.len(), 1);\n        assert!(matches!(node.click_event, Some(ClickEvent::Navigation(_))));\n        assert_eq!(node.classes().count(), 1);\n        assert_eq!(node.styles().count(), 1);\n        \n        Ok(())\n    }\n}\n","traces":[{"line":46,"address":[444112,444321],"length":1,"stats":{"Line":1}},{"line":47,"address":[444139,444269],"length":1,"stats":{"Line":2}},{"line":48,"address":[444301],"length":1,"stats":{"Line":1}},{"line":53,"address":[702432,702706],"length":1,"stats":{"Line":1}},{"line":54,"address":[702495,702541],"length":1,"stats":{"Line":2}},{"line":55,"address":[702683],"length":1,"stats":{"Line":1}},{"line":60,"address":[444528,444664],"length":1,"stats":{"Line":1}},{"line":61,"address":[444555],"length":1,"stats":{"Line":1}},{"line":62,"address":[444644],"length":1,"stats":{"Line":1}},{"line":67,"address":[444506,444352],"length":1,"stats":{"Line":1}},{"line":68,"address":[444382],"length":1,"stats":{"Line":1}},{"line":69,"address":[444483],"length":1,"stats":{"Line":1}},{"line":76,"address":[284512,285514],"length":1,"stats":{"Line":1}},{"line":77,"address":[284534,285100],"length":1,"stats":{"Line":2}},{"line":78,"address":[284749,284598],"length":1,"stats":{"Line":2}},{"line":79,"address":[284918],"length":1,"stats":{"Line":1}},{"line":80,"address":[284956],"length":1,"stats":{"Line":1}},{"line":81,"address":[285009],"length":1,"stats":{"Line":1}},{"line":82,"address":[285053],"length":1,"stats":{"Line":1}},{"line":91,"address":[446688],"length":1,"stats":{"Line":1}},{"line":92,"address":[446704],"length":1,"stats":{"Line":1}},{"line":95,"address":[446675,446416,446621],"length":1,"stats":{"Line":1}},{"line":96,"address":[446445,446574],"length":1,"stats":{"Line":3}},{"line":97,"address":[446598],"length":1,"stats":{"Line":2}},{"line":100,"address":[446752],"length":1,"stats":{"Line":0}},{"line":101,"address":[446757],"length":1,"stats":{"Line":0}},{"line":104,"address":[702736,703368],"length":1,"stats":{"Line":1}},{"line":105,"address":[702940,702774],"length":1,"stats":{"Line":2}},{"line":106,"address":[703116],"length":1,"stats":{"Line":1}},{"line":109,"address":[446768],"length":1,"stats":{"Line":0}},{"line":110,"address":[446773],"length":1,"stats":{"Line":0}},{"line":113,"address":[444752,445405],"length":1,"stats":{"Line":1}},{"line":114,"address":[444948,444782],"length":1,"stats":{"Line":2}},{"line":115,"address":[445153],"length":1,"stats":{"Line":1}},{"line":118,"address":[446284,445520],"length":1,"stats":{"Line":1}},{"line":122,"address":[445827,445578],"length":1,"stats":{"Line":2}},{"line":123,"address":[446032],"length":1,"stats":{"Line":1}},{"line":126,"address":[446400],"length":1,"stats":{"Line":0}},{"line":127,"address":[446405],"length":1,"stats":{"Line":0}}],"covered":33,"coverable":39},{"path":["/","home","lucac","github","mermaid-builder","src","diagrams","class_diagram","class_node","class_attribute.rs"],"content":"//! Submodule defining a class attribute struct for the class diagram in\n//! Mermaid syntax, including its visibility and type.\n\nuse std::fmt::Display;\n\nuse crate::diagrams::class_diagram::visibility::Visibility;\n\n#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// Struct representing a class attribute in a class diagram.\npub struct ClassAttribute {\n    /// The name of the class attribute.\n    name: String,\n    /// The type of the class attribute.\n    attribute_type: String,\n    /// The visibility of the class attribute (e.g., public, private).\n    visibility: Visibility,\n}\n\nimpl ClassAttribute {\n    /// Creates a new class attribute.\n    pub fn new(attribute_type: impl Into\u003cString\u003e, name: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            name: name.into(),\n            attribute_type: attribute_type.into(),\n            visibility: Visibility::Public,\n        }\n    }\n}\n\nimpl Display for ClassAttribute {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{} {}: {}\", self.visibility, self.name, self.attribute_type)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_class_attribute_display() {\n        let attr = ClassAttribute {\n            name: \"attr1\".to_string(),\n            attribute_type: \"int\".to_string(),\n            visibility: Visibility::Public,\n        };\n        assert_eq!(attr.to_string(), \"+ attr1: int\");\n    }\n}\n","traces":[{"line":22,"address":[306550,306256,306544],"length":1,"stats":{"Line":1}},{"line":24,"address":[306330],"length":1,"stats":{"Line":1}},{"line":25,"address":[306407],"length":1,"stats":{"Line":1}},{"line":32,"address":[558784],"length":1,"stats":{"Line":1}},{"line":33,"address":[558815],"length":1,"stats":{"Line":1}}],"covered":5,"coverable":5},{"path":["/","home","lucac","github","mermaid-builder","src","diagrams","class_diagram","class_node","class_method.rs"],"content":"//! Submodule defining a class method struct for the class diagram in\n//! Mermaid syntax, including its visibility and parameters signatures.\n\nuse std::fmt::Display;\n\nuse crate::diagrams::class_diagram::visibility::Visibility;\n\n#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// Represents a method argument in a Mermaid class diagram.\npub struct Argument {\n    /// The name of the argument (e.g., `x`).\n    name: String,\n    /// The type of the argument (e.g., `int`, `String`).\n    arg_type: String,\n}\n\nimpl Display for Argument {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{}: {}\", self.name, self.arg_type)\n    }\n}\n\n#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// Represents a class method for Mermaid class diagrams, including its name,\n/// arguments, and visibility.\npub struct ClassMethod {\n    /// The name of the class method (e.g., `doSomething`).\n    name: String,\n    /// The list of arguments for the method, each with a name and type.\n    arguments: Vec\u003cArgument\u003e,\n    /// The return type of the method (e.g., `void`, `int`).\n    return_type: Option\u003cString\u003e,\n    /// The visibility of the method (e.g., public, private, protected).\n    visibility: Visibility,\n}\n\nimpl ClassMethod {\n    /// Creates a new class method.\n    pub fn new(\n        return_type: impl Into\u003cString\u003e,\n        name: impl Into\u003cString\u003e,\n        arguments: Vec\u003cArgument\u003e,\n    ) -\u003e Self {\n        Self {\n            name: name.into(),\n            arguments,\n            return_type: Some(return_type.into()),\n            visibility: Visibility::Public,\n        }\n    }\n}\n\nimpl Display for ClassMethod {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{}\", self.visibility)?;\n        write!(f, \"{}\", self.name)?;\n\n        if self.arguments.is_empty() {\n            write!(f, \"()\")?;\n        } else {\n            write!(f, \"(\")?;\n            for (i, arg) in self.arguments.iter().enumerate() {\n                if i \u003e 0 {\n                    write!(f, \", \")?;\n                }\n                write!(f, \"{arg}\")?;\n            }\n            write!(f, \")\")?;\n        }\n\n        if let Some(return_type) = \u0026self.return_type {\n            write!(f, \": {return_type}\")?;\n        } else {\n            write!(f, \": void\")?;\n        }\n\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_argument_display() {\n        let arg = Argument { name: \"arg1\".to_string(), arg_type: \"int\".to_string() };\n        assert_eq!(arg.to_string(), \"arg1: int\");\n    }\n\n    #[test]\n    fn test_class_method_display() {\n        let method = ClassMethod {\n            name: \"method1\".to_string(),\n            arguments: vec![\n                Argument { name: \"arg1\".to_string(), arg_type: \"int\".to_string() },\n                Argument { name: \"arg2\".to_string(), arg_type: \"String\".to_string() },\n            ],\n            return_type: Some(\"bool\".to_string()),\n            visibility: Visibility::Public,\n        };\n        assert_eq!(method.to_string(), \"+method1(arg1: int, arg2: String): bool\");\n\n        let method_void = ClassMethod {\n            name: \"method2\".to_string(),\n            arguments: vec![],\n            return_type: None,\n            visibility: Visibility::Private,\n        };\n        assert_eq!(method_void.to_string(), \"-method2(): void\");\n    }\n}\n","traces":[{"line":19,"address":[523072],"length":1,"stats":{"Line":1}},{"line":20,"address":[523097],"length":1,"stats":{"Line":1}},{"line":41,"address":[246658,246706,246224],"length":1,"stats":{"Line":1}},{"line":47,"address":[246313],"length":1,"stats":{"Line":1}},{"line":49,"address":[246521,246444],"length":1,"stats":{"Line":2}},{"line":56,"address":[523360],"length":1,"stats":{"Line":1}},{"line":57,"address":[523399],"length":1,"stats":{"Line":1}},{"line":58,"address":[523524],"length":1,"stats":{"Line":1}},{"line":60,"address":[523646],"length":1,"stats":{"Line":1}},{"line":61,"address":[524382,523715],"length":1,"stats":{"Line":1}},{"line":63,"address":[523659,523778],"length":1,"stats":{"Line":1}},{"line":64,"address":[523893,523806],"length":1,"stats":{"Line":2}},{"line":65,"address":[523985],"length":1,"stats":{"Line":1}},{"line":66,"address":[524278],"length":1,"stats":{"Line":1}},{"line":68,"address":[524359,524146],"length":1,"stats":{"Line":1}},{"line":70,"address":[524000],"length":1,"stats":{"Line":1}},{"line":73,"address":[524409,524079],"length":1,"stats":{"Line":2}},{"line":74,"address":[524417,524601],"length":1,"stats":{"Line":1}},{"line":76,"address":[524634,524545],"length":1,"stats":{"Line":1}},{"line":79,"address":[524624],"length":1,"stats":{"Line":1}}],"covered":20,"coverable":20},{"path":["/","home","lucac","github","mermaid-builder","src","diagrams","class_diagram","class_node.rs"],"content":"//! Submodule defining a node struct for the class diagram in\n//! Mermaid syntax.\n\nmod builder;\nmod class_attribute;\nmod class_method;\nuse std::fmt::Display;\n\npub use builder::ClassNodeBuilder;\npub use class_attribute::ClassAttribute;\npub use class_method::ClassMethod;\n\nuse crate::{\n    shared::{ClickEvent, GenericNode, NODE_LETTER, StyleClass, StyleProperty},\n    traits::Node,\n};\n\n#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// Struct representing a class node in a class diagram.\n///\n/// # Examples\n///\n/// ```\n/// use mermaid_builder::{\n///     diagrams::class_diagram::ClassNodeBuilder,\n///     traits::{Node, NodeBuilder},\n/// };\n///\n/// fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n///     let node =\n///         ClassNodeBuilder::default().label(\"MyClass\")?.id(1).annotation(\"interface\").build()?;\n///\n///     assert_eq!(node.label(), \"MyClass\");\n///     Ok(())\n/// }\n/// ```\npub struct ClassNode {\n    /// Underlying generic node.\n    node: GenericNode,\n    /// The click event associated with the node, if any.\n    click_event: Option\u003cClickEvent\u003e,\n    /// The annotation of the class node, which usually\n    /// contains functional information such as `trait`, `interface`, etc.\n    annotation: Option\u003cString\u003e,\n    /// Attributes of the class node.\n    attributes: Vec\u003cClassAttribute\u003e,\n    /// Methods of the class node.\n    methods: Vec\u003cClassMethod\u003e,\n}\n\nimpl Node for ClassNode {\n    type Builder = ClassNodeBuilder;\n\n    fn label(\u0026self) -\u003e \u0026str {\n        self.node.label()\n    }\n\n    fn id(\u0026self) -\u003e u64 {\n        self.node.id()\n    }\n\n    fn styles(\u0026self) -\u003e impl Iterator\u003cItem = \u0026StyleProperty\u003e {\n        self.node.styles()\n    }\n\n    fn classes(\u0026self) -\u003e impl Iterator\u003cItem = \u0026StyleClass\u003e {\n        self.node.classes()\n    }\n\n    fn is_compatible_arrow_shape(shape: crate::shared::ArrowShape) -\u003e bool {\n        matches!(\n            shape,\n            crate::shared::ArrowShape::Triangle\n                | crate::shared::ArrowShape::Star\n                | crate::shared::ArrowShape::Circle\n                | crate::shared::ArrowShape::Normal\n        )\n    }\n}\n\nimpl Display for ClassNode {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        use crate::traits::TabbedDisplay;\n        self.fmt_tabbed(f, 0)\n    }\n}\n\nimpl crate::traits::TabbedDisplay for ClassNode {\n    fn fmt_tabbed(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e, tab_count: usize) -\u003e std::fmt::Result {\n        let indent = \" \".repeat(tab_count * 2);\n        writeln!(f, \"{indent}class {NODE_LETTER}{}[{}] {{\", self.id(), self.label())?;\n        if let Some(annotation) = \u0026self.annotation {\n            writeln!(f, \"{indent}    \u003c\u003c{annotation}\u003e\u003e\")?;\n        }\n\n        for attr in \u0026self.attributes {\n            writeln!(f, \"{indent}    {attr}\")?;\n        }\n        for method in \u0026self.methods {\n            writeln!(f, \"{indent}    {method}\")?;\n        }\n        writeln!(f, \"{indent}}}\")?;\n\n        if let Some(click_event) = \u0026self.click_event {\n            writeln!(f, \"{indent}click {NODE_LETTER}{} {}\", self.id(), click_event)?;\n        }\n\n        for class in self.classes() {\n            writeln!(f, \"{indent}cssClass {NODE_LETTER}{} {}\", self.id(), class.name())?;\n        }\n\n        Ok(())\n    }\n}\n","traces":[{"line":55,"address":[279344],"length":1,"stats":{"Line":1}},{"line":56,"address":[279349],"length":1,"stats":{"Line":1}},{"line":59,"address":[279328],"length":1,"stats":{"Line":1}},{"line":60,"address":[279333],"length":1,"stats":{"Line":1}},{"line":63,"address":[279360],"length":1,"stats":{"Line":1}},{"line":64,"address":[279365],"length":1,"stats":{"Line":1}},{"line":67,"address":[279376],"length":1,"stats":{"Line":1}},{"line":68,"address":[279381],"length":1,"stats":{"Line":1}},{"line":71,"address":[279264],"length":1,"stats":{"Line":1}},{"line":72,"address":[279279],"length":1,"stats":{"Line":1}},{"line":73,"address":[279271],"length":1,"stats":{"Line":1}},{"line":83,"address":[284480],"length":1,"stats":{"Line":0}},{"line":85,"address":[284494],"length":1,"stats":{"Line":0}},{"line":90,"address":[282704,282710,279456],"length":1,"stats":{"Line":0}},{"line":91,"address":[279506,279583],"length":1,"stats":{"Line":0}},{"line":92,"address":[282690,279656,279568],"length":1,"stats":{"Line":0}},{"line":93,"address":[280109],"length":1,"stats":{"Line":0}},{"line":94,"address":[280186,280283],"length":1,"stats":{"Line":0}},{"line":97,"address":[280525,280237],"length":1,"stats":{"Line":0}},{"line":98,"address":[280635,282505],"length":1,"stats":{"Line":0}},{"line":100,"address":[280689],"length":1,"stats":{"Line":0}},{"line":101,"address":[280842,282311],"length":1,"stats":{"Line":0}},{"line":103,"address":[282281,280896],"length":1,"stats":{"Line":0}},{"line":105,"address":[281094],"length":1,"stats":{"Line":0}},{"line":106,"address":[281228,281171],"length":1,"stats":{"Line":0}},{"line":109,"address":[281194,281652],"length":1,"stats":{"Line":0}},{"line":110,"address":[281788,281849],"length":1,"stats":{"Line":0}},{"line":113,"address":[281800],"length":1,"stats":{"Line":0}}],"covered":11,"coverable":28},{"path":["/","home","lucac","github","mermaid-builder","src","diagrams","class_diagram","configuration","builder.rs"],"content":"//! Submodule providing a builder struct for the configuration of class diagrams\n//! in Mermaid syntax.\n\nuse crate::{\n    diagrams::class_diagram::configuration::ClassDiagramConfiguration, errors::ConfigError,\n    shared::generic_configuration::GenericConfigurationBuilder, traits::ConfigurationBuilder,\n};\n\n#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\npub struct ClassDiagramConfigurationBuilder {\n    /// Generic configuration options which apply to all Mermaid diagrams.\n    generic: GenericConfigurationBuilder,\n    /// Whether to hide empty members in the class diagram.\n    hide_empty_members_box: bool,\n}\n\nimpl ClassDiagramConfigurationBuilder {\n    /// Sets whether to hide empty members in the class diagram.\n    pub fn hide_empty_members_box(mut self, hide: bool) -\u003e Self {\n        self.hide_empty_members_box = hide;\n        self\n    }\n\n    /// Sets the theme to use for the diagram.\n    pub fn theme(mut self, theme: crate::shared::generic_configuration::Theme) -\u003e Self {\n        self.generic = self.generic.theme(theme);\n        self\n    }\n\n    /// Sets the look to use for the diagram.\n    pub fn look(mut self, look: crate::shared::generic_configuration::Look) -\u003e Self {\n        self.generic = self.generic.look(look);\n        self\n    }\n}\n\nimpl TryFrom\u003cClassDiagramConfigurationBuilder\u003e for ClassDiagramConfiguration {\n    type Error = ConfigError;\n\n    fn try_from(builder: ClassDiagramConfigurationBuilder) -\u003e Result\u003cSelf, Self::Error\u003e {\n        Ok(ClassDiagramConfiguration {\n            generic: builder.generic.try_into()?,\n            hide_empty_members_box: builder.hide_empty_members_box,\n        })\n    }\n}\n\nimpl ConfigurationBuilder for ClassDiagramConfigurationBuilder {\n    type Configuration = ClassDiagramConfiguration;\n    type Error = ConfigError;\n\n    fn build(self) -\u003e Result\u003cSelf::Configuration, Self::Error\u003e {\n        self.try_into()\n    }\n\n    fn title\u003cS: ToString\u003e(mut self, title: S) -\u003e Result\u003cSelf, Self::Error\u003e {\n        self.generic = self.generic.title(title)?;\n        Ok(self)\n    }\n\n    fn direction(mut self, direction: crate::shared::generic_configuration::Direction) -\u003e Self {\n        self.generic = self.generic.direction(direction);\n        self\n    }\n\n    fn renderer(mut self, renderer: crate::shared::generic_configuration::Renderer) -\u003e Self {\n        self.generic = self.generic.renderer(renderer);\n        self\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::{\n        shared::generic_configuration::{Direction, Look, Renderer, Theme},\n        traits::Configuration,\n    };\n\n    #[test]\n    fn test_class_diagram_configuration_builder() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n        let config = ClassDiagramConfigurationBuilder::default()\n            .title(\"My Class Diagram\")?\n            .direction(Direction::LeftToRight)\n            .renderer(Renderer::Dagre)\n            .theme(Theme::Forest)\n            .look(Look::HandDrawn)\n            .hide_empty_members_box(true)\n            .build()?;\n\n        assert!(config.hide_empty_members_box);\n        assert_eq!(config.title(), Some(\"My Class Diagram\"));\n        assert_eq!(config.direction(), Direction::LeftToRight);\n        assert_eq!(config.renderer(), Renderer::Dagre);\n        assert_eq!(config.theme(), Theme::Forest);\n        assert_eq!(config.look(), Look::HandDrawn);\n        Ok(())\n    }\n}\n","traces":[{"line":20,"address":[812976],"length":1,"stats":{"Line":1}},{"line":21,"address":[812999],"length":1,"stats":{"Line":1}},{"line":22,"address":[813004],"length":1,"stats":{"Line":1}},{"line":26,"address":[813168],"length":1,"stats":{"Line":1}},{"line":27,"address":[813193],"length":1,"stats":{"Line":1}},{"line":28,"address":[813291],"length":1,"stats":{"Line":1}},{"line":32,"address":[813024],"length":1,"stats":{"Line":1}},{"line":33,"address":[813049],"length":1,"stats":{"Line":1}},{"line":34,"address":[813147],"length":1,"stats":{"Line":1}},{"line":41,"address":[348384],"length":1,"stats":{"Line":1}},{"line":42,"address":[348605],"length":1,"stats":{"Line":1}},{"line":43,"address":[348405],"length":1,"stats":{"Line":1}},{"line":44,"address":[348602],"length":1,"stats":{"Line":1}},{"line":53,"address":[813376],"length":1,"stats":{"Line":1}},{"line":54,"address":[813389],"length":1,"stats":{"Line":1}},{"line":57,"address":[815954,815568,815979],"length":1,"stats":{"Line":1}},{"line":58,"address":[815715,815952,815606],"length":1,"stats":{"Line":2}},{"line":59,"address":[815890],"length":1,"stats":{"Line":1}},{"line":62,"address":[813600],"length":1,"stats":{"Line":1}},{"line":63,"address":[813625],"length":1,"stats":{"Line":1}},{"line":64,"address":[813723],"length":1,"stats":{"Line":1}},{"line":67,"address":[813440],"length":1,"stats":{"Line":1}},{"line":68,"address":[813470],"length":1,"stats":{"Line":1}},{"line":69,"address":[813571],"length":1,"stats":{"Line":1}}],"covered":24,"coverable":24},{"path":["/","home","lucac","github","mermaid-builder","src","diagrams","class_diagram","configuration.rs"],"content":"//! Submodule defining configuration specifically for class diagrams in\n//! Mermaid.\n\nmod builder;\nuse std::fmt::Display;\n\npub use builder::ClassDiagramConfigurationBuilder;\n\nuse crate::{\n    shared::{\n        Direction, Renderer,\n        generic_configuration::{GenericConfiguration, Look, Theme},\n    },\n    traits::Configuration,\n};\n\n#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// Configuration for class diagrams in Mermaid syntax.\npub struct ClassDiagramConfiguration {\n    /// Generic configuration options which apply to all Mermaid diagrams.\n    generic: GenericConfiguration,\n    /// Whether to hide empty members in the class diagram.\n    hide_empty_members_box: bool,\n}\n\nimpl Display for ClassDiagramConfiguration {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        writeln!(f, \"---\")?;\n        if let Some(title) = \u0026self.title() {\n            writeln!(f, \"title: {title}\")?;\n        }\n        writeln!(f, \"config:\")?;\n        writeln!(f, \"  class:\")?;\n        writeln!(f, \"    hideEmptyMembersBox: \\\"{}\\\"\", self.hide_empty_members_box)?;\n        writeln!(f, \"---\")?;\n\n        Ok(())\n    }\n}\n\nimpl Configuration for ClassDiagramConfiguration {\n    type Builder = ClassDiagramConfigurationBuilder;\n\n    fn title(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n        self.generic.title()\n    }\n\n    fn direction(\u0026self) -\u003e Direction {\n        self.generic.direction()\n    }\n\n    fn renderer(\u0026self) -\u003e Renderer {\n        self.generic.renderer()\n    }\n\n    fn theme(\u0026self) -\u003e Theme {\n        self.generic.theme()\n    }\n\n    fn look(\u0026self) -\u003e Look {\n        self.generic.look()\n    }\n}\n","traces":[{"line":28,"address":[346800],"length":1,"stats":{"Line":0}},{"line":29,"address":[346830],"length":1,"stats":{"Line":0}},{"line":30,"address":[346912],"length":1,"stats":{"Line":0}},{"line":31,"address":[347124,346965],"length":1,"stats":{"Line":0}},{"line":33,"address":[347068,347156],"length":1,"stats":{"Line":0}},{"line":34,"address":[347176],"length":1,"stats":{"Line":0}},{"line":35,"address":[347255],"length":1,"stats":{"Line":0}},{"line":36,"address":[347375],"length":1,"stats":{"Line":0}},{"line":38,"address":[347452],"length":1,"stats":{"Line":0}},{"line":45,"address":[348336],"length":1,"stats":{"Line":1}},{"line":46,"address":[348341],"length":1,"stats":{"Line":1}},{"line":49,"address":[348368],"length":1,"stats":{"Line":1}},{"line":50,"address":[348373],"length":1,"stats":{"Line":1}},{"line":53,"address":[348352],"length":1,"stats":{"Line":1}},{"line":54,"address":[348357],"length":1,"stats":{"Line":1}},{"line":57,"address":[348320],"length":1,"stats":{"Line":1}},{"line":58,"address":[348325],"length":1,"stats":{"Line":1}},{"line":61,"address":[348304],"length":1,"stats":{"Line":1}},{"line":62,"address":[348309],"length":1,"stats":{"Line":1}}],"covered":10,"coverable":19},{"path":["/","home","lucac","github","mermaid-builder","src","diagrams","class_diagram","visibility.rs"],"content":"//! Submodule providing an enumeration for visibility modifiers employable\n//! in class entries of Mermaid class diagrams.\n//!\n//! These include: Public (`+`), Private (`-`), Protected (`#`), and\n//! Package/Internal (`~`).\n\nuse std::fmt::Display;\n\n#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// An enumeration representing the visibility of class members in Mermaid class\n/// diagrams.\npub enum Visibility {\n    /// Public visibility, denoted by `+`.\n    Public,\n    /// Private visibility, denoted by `-`.\n    Private,\n    /// Protected visibility, denoted by `#`.\n    Protected,\n    /// Package/Internal visibility, denoted by `~`.\n    Package,\n}\n\nimpl Display for Visibility {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Visibility::Public =\u003e write!(f, \"+\"),\n            Visibility::Private =\u003e write!(f, \"-\"),\n            Visibility::Protected =\u003e write!(f, \"#\"),\n            Visibility::Package =\u003e write!(f, \"~\"),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_visibility_display() {\n        assert_eq!(Visibility::Public.to_string(), \"+\");\n        assert_eq!(Visibility::Private.to_string(), \"-\");\n        assert_eq!(Visibility::Protected.to_string(), \"#\");\n        assert_eq!(Visibility::Package.to_string(), \"~\");\n    }\n}\n","traces":[{"line":25,"address":[394064],"length":1,"stats":{"Line":1}},{"line":26,"address":[394082],"length":1,"stats":{"Line":1}},{"line":27,"address":[394113],"length":1,"stats":{"Line":3}},{"line":28,"address":[394150],"length":1,"stats":{"Line":1}},{"line":29,"address":[394187],"length":1,"stats":{"Line":1}},{"line":30,"address":[394224],"length":1,"stats":{"Line":1}}],"covered":6,"coverable":6},{"path":["/","home","lucac","github","mermaid-builder","src","diagrams","class_diagram.rs"],"content":"//! Submodule defining a class diagram in Mermaid syntax.\n\npub mod class_edge;\npub mod class_node;\nmod configuration;\npub mod visibility;\nuse std::fmt::Display;\n\nuse class_edge::ClassEdge;\npub use class_edge::ClassEdgeBuilder;\nuse class_node::ClassNode;\npub use class_node::ClassNodeBuilder;\npub use configuration::ClassDiagramConfiguration;\n\nuse crate::{\n    shared::generic_diagram::{GenericDiagram, GenericDiagramBuilder},\n    traits::{configuration::Configuration, diagram::Diagram},\n};\n\n/// Represents a class diagram in Mermaid syntax.\npub type ClassDiagram = GenericDiagram\u003cClassNode, ClassEdge, ClassDiagramConfiguration\u003e;\n/// Represents a builder for a class diagram in Mermaid syntax.\npub type ClassDiagramBuilder =\n    GenericDiagramBuilder\u003cClassNode, ClassEdge, ClassDiagramConfiguration\u003e;\n\nimpl Display for ClassDiagram {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        use crate::traits::TabbedDisplay;\n        self.fmt_tabbed(f, 0)\n    }\n}\n\nimpl crate::traits::TabbedDisplay for ClassDiagram {\n    fn fmt_tabbed(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e, tab_count: usize) -\u003e std::fmt::Result {\n        let indent = \" \".repeat(tab_count * 2);\n        write!(f, \"{}\", self.configuration())?; // Configuration might need tabbed display too? Usually it's frontmatter or directives.\n        writeln!(f, \"{indent}classDiagram\")?;\n        writeln!(f, \"{indent}  direction {}\", self.configuration().direction())?;\n        for style_class in self.style_classes() {\n            style_class.fmt_tabbed(f, tab_count + 1)?;\n        }\n        for node in self.nodes() {\n            node.fmt_tabbed(f, tab_count + 1)?;\n        }\n        for edge in self.edges() {\n            edge.fmt_tabbed(f, tab_count + 1)?;\n        }\n        Ok(())\n    }\n}\n","traces":[{"line":27,"address":[578896],"length":1,"stats":{"Line":0}},{"line":29,"address":[578910],"length":1,"stats":{"Line":0}},{"line":34,"address":[579088,581133,581139],"length":1,"stats":{"Line":0}},{"line":35,"address":[579146,579223],"length":1,"stats":{"Line":0}},{"line":36,"address":[579208,581119,579288],"length":1,"stats":{"Line":0}},{"line":37,"address":[579502,581098],"length":1,"stats":{"Line":0}},{"line":38,"address":[579704,581077],"length":1,"stats":{"Line":0}},{"line":39,"address":[580016],"length":1,"stats":{"Line":0}},{"line":40,"address":[580212,580960],"length":1,"stats":{"Line":0}},{"line":42,"address":[580249],"length":1,"stats":{"Line":0}},{"line":43,"address":[580826,580412],"length":1,"stats":{"Line":0}},{"line":45,"address":[580446],"length":1,"stats":{"Line":0}},{"line":46,"address":[580609,580685],"length":1,"stats":{"Line":0}},{"line":48,"address":[580628],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":14},{"path":["/","home","lucac","github","mermaid-builder","src","diagrams","entity_relationship","entity_relationship_edge.rs"],"content":"//! Submodule defining an edge struct for entity-relationship diagrams in\n//! Mermaid syntax.\n\nuse std::{fmt::Display, rc::Rc};\n\nuse crate::{\n    diagrams::entity_relationship::entity_relationship_node::ERNode,\n    shared::{ArrowShape, GenericEdge, LineStyle, NODE_LETTER, generic_edge::GenericEdgeBuilder},\n    traits::{edge::Edge, edge_builder::EdgeBuilder, node::Node},\n};\n/// Type alias for an entity-relationship edge builder.\npub type EREdgeBuilder = GenericEdgeBuilder\u003cERNode\u003e;\n/// Type alias for an entity-relationship edge.\npub type EREdge = GenericEdge\u003cERNode\u003e;\n\nimpl EREdgeBuilder {\n    /// Creates a new entity-relationship edge builder.\n    ///\n    /// # Arguments\n    ///\n    /// * `source` - The source node of the edge.\n    /// * `destination` - The destination node of the edge.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use std::rc::Rc;\n    ///\n    /// use mermaid_builder::prelude::*;\n    ///\n    /// fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    ///     let node1 = Rc::new(ERNodeBuilder::default().label(\"A\")?.id(0).build()?);\n    ///     let node2 = Rc::new(ERNodeBuilder::default().label(\"B\")?.id(1).build()?);\n    ///\n    ///     let builder = EREdgeBuilder::zero_or_one(node1, node2);\n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn zero_or_one(source: Rc\u003cERNode\u003e, destination: Rc\u003cERNode\u003e) -\u003e Self {\n        Self::default()\n            .source(source)\n            .unwrap()\n            .destination(destination)\n            .unwrap()\n            .left_arrow_shape(ArrowShape::ZeroOrOne)\n            .unwrap()\n            .right_arrow_shape(ArrowShape::ZeroOrOne)\n            .unwrap()\n            .line_style(LineStyle::Solid)\n    }\n\n    /// Creates a new entity-relationship edge builder with a one-to-one\n    /// relationship.\n    ///\n    /// # Arguments\n    ///\n    /// * `source` - The source node of the edge.\n    /// * `destination` - The destination node of the edge.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use std::rc::Rc;\n    ///\n    /// use mermaid_builder::prelude::*;\n    ///\n    /// fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    ///     let node1 = Rc::new(ERNodeBuilder::default().label(\"A\")?.id(0).build()?);\n    ///     let node2 = Rc::new(ERNodeBuilder::default().label(\"B\")?.id(1).build()?);\n    ///\n    ///     let builder = EREdgeBuilder::one_to_one(node1, node2);\n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn one_to_one(source: Rc\u003cERNode\u003e, destination: Rc\u003cERNode\u003e) -\u003e Self {\n        Self::default()\n            .source(source)\n            .unwrap()\n            .destination(destination)\n            .unwrap()\n            .left_arrow_shape(ArrowShape::ExactlyOne)\n            .unwrap()\n            .right_arrow_shape(ArrowShape::ExactlyOne)\n            .unwrap()\n            .line_style(LineStyle::Solid)\n    }\n\n    /// Creates a new entity-relationship edge builder with a zero-or-one\n    /// relationship.\n    ///\n    /// # Arguments\n    ///\n    /// * `source` - The source node of the edge.\n    /// * `destination` - The destination node of the edge.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use std::rc::Rc;\n    ///\n    /// use mermaid_builder::prelude::*;\n    ///\n    /// fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    ///     let node1 = Rc::new(ERNodeBuilder::default().label(\"A\")?.id(0).build()?);\n    ///     let node2 = Rc::new(ERNodeBuilder::default().label(\"B\")?.id(1).build()?);\n    ///\n    ///     let builder = EREdgeBuilder::zero_or_more(node1, node2);\n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn zero_or_more(source: Rc\u003cERNode\u003e, destination: Rc\u003cERNode\u003e) -\u003e Self {\n        Self::default()\n            .source(source)\n            .unwrap()\n            .destination(destination)\n            .unwrap()\n            .left_arrow_shape(ArrowShape::ZeroOrMore)\n            .unwrap()\n            .right_arrow_shape(ArrowShape::ZeroOrMore)\n            .unwrap()\n            .line_style(LineStyle::Solid)\n    }\n\n    /// Creates a new entity-relationship edge builder with a one-or-more\n    /// relationship.\n    ///\n    /// # Arguments\n    ///\n    /// * `source` - The source node of the edge.\n    /// * `destination` - The destination node of the edge.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use std::rc::Rc;\n    ///\n    /// use mermaid_builder::prelude::*;\n    ///\n    /// fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    ///     let node1 = Rc::new(ERNodeBuilder::default().label(\"A\")?.id(0).build()?);\n    ///     let node2 = Rc::new(ERNodeBuilder::default().label(\"B\")?.id(1).build()?);\n    ///\n    ///     let builder = EREdgeBuilder::one_or_more(node1, node2);\n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn one_or_more(source: Rc\u003cERNode\u003e, destination: Rc\u003cERNode\u003e) -\u003e Self {\n        Self::default()\n            .source(source)\n            .unwrap()\n            .destination(destination)\n            .unwrap()\n            .left_arrow_shape(ArrowShape::OneOrMore)\n            .unwrap()\n            .right_arrow_shape(ArrowShape::OneOrMore)\n            .unwrap()\n            .line_style(LineStyle::Solid)\n    }\n}\n\nimpl Display for EREdge {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        use crate::traits::TabbedDisplay;\n        self.fmt_tabbed(f, 0)\n    }\n}\n\nimpl crate::traits::TabbedDisplay for EREdge {\n    fn fmt_tabbed(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e, tab_count: usize) -\u003e std::fmt::Result {\n        let indent = \" \".repeat(tab_count * 2);\n        writeln!(\n            f,\n            \"{indent}{NODE_LETTER}{} {left_arrow}{segment}{right_arrow} {NODE_LETTER}{} : \\\"{label}\\\"\",\n            self.source().id(),\n            self.destination().id(),\n            label = self.label().unwrap_or(\"\"),\n            left_arrow = self.left_arrow_shape().as_ref().map_or_else(|| \"\", |shape| shape.left()),\n            segment = match self.line_style() {\n                LineStyle::Solid =\u003e \"--\",\n                LineStyle::Thick =\u003e \"==\",\n                LineStyle::Dashed =\u003e \"..\",\n            },\n            right_arrow =\n                self.right_arrow_shape().as_ref().map_or_else(|| \"\", |shape| shape.right()),\n        )\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::diagrams::entity_relationship::entity_relationship_node::ERNodeBuilder;\n    use crate::traits::node_builder::NodeBuilder;\n\n    #[test]\n    fn test_er_edge_builder_methods() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n        let node1 = Rc::new(ERNodeBuilder::default().label(\"A\")?.id(0).build()?);\n        let node2 = Rc::new(ERNodeBuilder::default().label(\"B\")?.id(1).build()?);\n\n        let edge_zero_one = EREdgeBuilder::zero_or_one(node1.clone(), node2.clone()).build()?;\n        assert_eq!(edge_zero_one.left_arrow_shape(), Some(ArrowShape::ZeroOrOne));\n        assert_eq!(edge_zero_one.right_arrow_shape(), Some(ArrowShape::ZeroOrOne));\n\n        let edge_one_one = EREdgeBuilder::one_to_one(node1.clone(), node2.clone()).build()?;\n        assert_eq!(edge_one_one.left_arrow_shape(), Some(ArrowShape::ExactlyOne));\n        assert_eq!(edge_one_one.right_arrow_shape(), Some(ArrowShape::ExactlyOne));\n\n        let edge_zero_more = EREdgeBuilder::zero_or_more(node1.clone(), node2.clone()).build()?;\n        assert_eq!(edge_zero_more.left_arrow_shape(), Some(ArrowShape::ZeroOrMore));\n        assert_eq!(edge_zero_more.right_arrow_shape(), Some(ArrowShape::ZeroOrMore));\n\n        let edge_one_more = EREdgeBuilder::one_or_more(node1.clone(), node2.clone()).build()?;\n        assert_eq!(edge_one_more.left_arrow_shape(), Some(ArrowShape::OneOrMore));\n        assert_eq!(edge_one_more.right_arrow_shape(), Some(ArrowShape::OneOrMore));\n\n        Ok(())\n    }\n\n    #[test]\n    fn test_er_edge_display() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n        let node1 = Rc::new(ERNodeBuilder::default().label(\"A\")?.id(0).build()?);\n        let node2 = Rc::new(ERNodeBuilder::default().label(\"B\")?.id(1).build()?);\n\n        let edge = EREdgeBuilder::zero_or_one(node1, node2)\n            .label(\"relates to\")?\n            .build()?;\n\n        let output = format!(\"{}\", edge);\n        // Expected format: v0 |o--o| v1 : \"relates to\"\n        assert!(output.contains(\"v0\"));\n        assert!(output.contains(\"v1\"));\n        assert!(output.contains(\"relates to\"));\n        assert!(output.contains(\"|o--o|\"));\n\n        Ok(())\n    }\n}\n","traces":[{"line":39,"address":[436696,436288,436702],"length":1,"stats":{"Line":2}},{"line":40,"address":[436314],"length":1,"stats":{"Line":2}},{"line":41,"address":[436402],"length":1,"stats":{"Line":2}},{"line":43,"address":[436468],"length":1,"stats":{"Line":2}},{"line":45,"address":[436555],"length":1,"stats":{"Line":2}},{"line":47,"address":[436610],"length":1,"stats":{"Line":2}},{"line":49,"address":[436652],"length":1,"stats":{"Line":2}},{"line":75,"address":[435392,435800,435806],"length":1,"stats":{"Line":1}},{"line":76,"address":[435418],"length":1,"stats":{"Line":1}},{"line":77,"address":[435506],"length":1,"stats":{"Line":1}},{"line":79,"address":[435572],"length":1,"stats":{"Line":1}},{"line":81,"address":[435659],"length":1,"stats":{"Line":1}},{"line":83,"address":[435714],"length":1,"stats":{"Line":1}},{"line":85,"address":[435756],"length":1,"stats":{"Line":1}},{"line":111,"address":[436736,437150,437144],"length":1,"stats":{"Line":1}},{"line":112,"address":[436762],"length":1,"stats":{"Line":1}},{"line":113,"address":[436850],"length":1,"stats":{"Line":1}},{"line":115,"address":[436916],"length":1,"stats":{"Line":1}},{"line":117,"address":[437003],"length":1,"stats":{"Line":1}},{"line":119,"address":[437058],"length":1,"stats":{"Line":1}},{"line":121,"address":[437100],"length":1,"stats":{"Line":1}},{"line":147,"address":[435840,436248,436254],"length":1,"stats":{"Line":1}},{"line":148,"address":[435866],"length":1,"stats":{"Line":1}},{"line":149,"address":[435954],"length":1,"stats":{"Line":1}},{"line":151,"address":[436020],"length":1,"stats":{"Line":1}},{"line":153,"address":[436107],"length":1,"stats":{"Line":1}},{"line":155,"address":[436162],"length":1,"stats":{"Line":1}},{"line":157,"address":[436204],"length":1,"stats":{"Line":1}},{"line":162,"address":[438656],"length":1,"stats":{"Line":1}},{"line":164,"address":[438670],"length":1,"stats":{"Line":1}},{"line":169,"address":[437312,438637,438643],"length":1,"stats":{"Line":1}},{"line":170,"address":[437362,437439],"length":1,"stats":{"Line":1}},{"line":171,"address":[438085],"length":1,"stats":{"Line":1}},{"line":174,"address":[437504,437424],"length":1,"stats":{"Line":2}},{"line":175,"address":[437566],"length":1,"stats":{"Line":1}},{"line":176,"address":[437651],"length":1,"stats":{"Line":1}},{"line":177,"address":[437750],"length":1,"stats":{"Line":3}},{"line":178,"address":[437848],"length":1,"stats":{"Line":1}},{"line":179,"address":[437894],"length":1,"stats":{"Line":1}},{"line":180,"address":[437923],"length":1,"stats":{"Line":0}},{"line":181,"address":[437952],"length":1,"stats":{"Line":0}},{"line":184,"address":[437987],"length":1,"stats":{"Line":3}}],"covered":40,"coverable":42},{"path":["/","home","lucac","github","mermaid-builder","src","diagrams","entity_relationship","entity_relationship_node","attribute.rs"],"content":"//! Submodule defining an attribute of an Entity-Relationship (ER) node\n//! for the entity-relationship diagram in Mermaid syntax.\n\nuse std::fmt::Display;\n\n#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// Struct representing an attribute of an entity-relationship node.\npub struct EntityRelationshipAttribute {\n    /// The name of the class attribute.\n    name: String,\n    /// The type of the class attribute.\n    attribute_type: String,\n}\n\nimpl EntityRelationshipAttribute {\n    /// Creates a new entity-relationship attribute.\n    pub fn new(attribute_type: String, name: String) -\u003e Self {\n        Self { name, attribute_type }\n    }\n\n    /// Returns the name of the attribute.\n    #[must_use]\n    pub fn name(\u0026self) -\u003e \u0026str {\n        \u0026self.name\n    }\n\n    /// Returns the type of the attribute.\n    #[must_use]\n    pub fn attribute_type(\u0026self) -\u003e \u0026str {\n        \u0026self.attribute_type\n    }\n}\n\nimpl Display for EntityRelationshipAttribute {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{} {}\", self.name, self.attribute_type)\n    }\n}\n","traces":[{"line":18,"address":[394896],"length":1,"stats":{"Line":1}},{"line":24,"address":[394960],"length":1,"stats":{"Line":1}},{"line":25,"address":[394965],"length":1,"stats":{"Line":1}},{"line":30,"address":[394880],"length":1,"stats":{"Line":1}},{"line":31,"address":[394885],"length":1,"stats":{"Line":1}},{"line":36,"address":[395744],"length":1,"stats":{"Line":0}},{"line":37,"address":[395769],"length":1,"stats":{"Line":0}}],"covered":5,"coverable":7},{"path":["/","home","lucac","github","mermaid-builder","src","diagrams","entity_relationship","entity_relationship_node","builder.rs"],"content":"//! Submodule defining a builder struct for the entity-relationship node in\n//! entity-relationship diagrams.\n\nuse std::rc::Rc;\n\nuse crate::{\n    diagrams::entity_relationship::entity_relationship_node::{\n        ERNode, attribute::EntityRelationshipAttribute,\n    },\n    errors::NodeError,\n    shared::{StyleClass, StyleClassError, generic_node::GenericNodeBuilder},\n    traits::NodeBuilder,\n};\n\n#[derive(Default, Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// Builder for the entity-relationship node in Mermaid syntax.\n///\n/// # Example\n///\n/// ```\n/// use mermaid_builder::prelude::*;\n///\n/// fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n///     let node = ERNodeBuilder::default().label(\"CUSTOMER\")?.id(0).build()?;\n///     Ok(())\n/// }\n/// ```\npub struct ERNodeBuilder {\n    /// Shared attributes builder for the node.\n    builder: GenericNodeBuilder,\n    /// The attributes of the entity-relationship node.\n    class_attributes: Vec\u003cEntityRelationshipAttribute\u003e,\n}\n\nimpl ERNodeBuilder {\n    /// Adds an attribute to the entity-relationship node.\n    #[must_use]\n    pub fn attribute\u003cS: ToString + ?Sized\u003e(mut self, attribute_type: \u0026S, name: \u0026S) -\u003e Self {\n        self.class_attributes\n            .push(EntityRelationshipAttribute::new(attribute_type.to_string(), name.to_string()));\n        self\n    }\n}\n\nimpl TryFrom\u003cERNodeBuilder\u003e for ERNode {\n    type Error = NodeError;\n\n    fn try_from(builder: ERNodeBuilder) -\u003e Result\u003cSelf, Self::Error\u003e {\n        Ok(ERNode { node: builder.builder.try_into()?, attributes: builder.class_attributes })\n    }\n}\n\nimpl NodeBuilder for ERNodeBuilder {\n    type Node = ERNode;\n    type Error = NodeError;\n\n    fn build(self) -\u003e Result\u003cSelf::Node, Self::Error\u003e {\n        self.try_into()\n    }\n\n    fn id(mut self, id: u64) -\u003e Self {\n        self.builder = self.builder.id(id);\n        self\n    }\n\n    fn get_id(\u0026self) -\u003e Option\u003cu64\u003e {\n        self.builder.get_id()\n    }\n\n    fn label\u003cS: ToString\u003e(mut self, label: S) -\u003e Result\u003cSelf, Self::Error\u003e {\n        self.builder = self.builder.label(label)?;\n        Ok(self)\n    }\n\n    fn get_label(\u0026self) -\u003e Option\u003c\u0026String\u003e {\n        self.builder.get_label()\n    }\n\n    fn style_class(mut self, style_class: Rc\u003cStyleClass\u003e) -\u003e Result\u003cSelf, StyleClassError\u003e {\n        self.builder = self.builder.style_class(style_class)?;\n        Ok(self)\n    }\n\n    fn style_property(\n        mut self,\n        property: crate::shared::StyleProperty,\n    ) -\u003e Result\u003cSelf, StyleClassError\u003e {\n        self.builder = self.builder.style_property(property)?;\n        Ok(self)\n    }\n\n    fn style_properties(\u0026self) -\u003e impl Iterator\u003cItem = \u0026crate::prelude::StyleProperty\u003e {\n        self.builder.style_properties()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::{\n        shared::{StyleClassBuilder, StyleProperty, style_class::Color},\n        traits::node::Node,\n    };\n\n    #[test]\n    fn test_er_node_builder() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n        let style = Rc::new(\n            StyleClassBuilder::default()\n                .name(\"myStyle\")?\n                .property(StyleProperty::Fill(Color::from((255, 0, 0))))?\n                .build()?,\n        );\n\n        let node = ERNodeBuilder::default()\n            .id(1)\n            .label(\"CUSTOMER\")?\n            .attribute(\"string\", \"name\")\n            .attribute(\"int\", \"age\")\n            .style_class(style)?\n            .style_property(StyleProperty::Fill(Color::from((255, 0, 0))))?\n            .build()?;\n\n        assert_eq!(node.node.id(), 1);\n        assert_eq!(node.node.label(), \"CUSTOMER\");\n        assert_eq!(node.attributes.len(), 2);\n        assert_eq!(node.attributes[0].attribute_type(), \"string\");\n        assert_eq!(node.attributes[0].name(), \"name\");\n        assert_eq!(node.attributes[1].attribute_type(), \"int\");\n        assert_eq!(node.attributes[1].name(), \"age\");\n        \n        // Check styles\n        let styles: Vec\u003c_\u003e = node.node.styles().collect();\n        assert!(styles.contains(\u0026\u0026StyleProperty::Fill(Color::from((255, 0, 0)))));\n\n        Ok(())\n    }\n}\n","traces":[{"line":39,"address":[238379,238048],"length":1,"stats":{"Line":1}},{"line":40,"address":[238137],"length":1,"stats":{"Line":1}},{"line":41,"address":[238159,238360,238212],"length":1,"stats":{"Line":2}},{"line":42,"address":[238337],"length":1,"stats":{"Line":1}},{"line":49,"address":[692510,692538,692000],"length":1,"stats":{"Line":2}},{"line":50,"address":[692021,692188],"length":1,"stats":{"Line":4}},{"line":58,"address":[350176],"length":1,"stats":{"Line":2}},{"line":59,"address":[350193],"length":1,"stats":{"Line":2}},{"line":62,"address":[349952,350154],"length":1,"stats":{"Line":1}},{"line":63,"address":[349981,350107],"length":1,"stats":{"Line":6}},{"line":64,"address":[350131],"length":1,"stats":{"Line":3}},{"line":67,"address":[350240],"length":1,"stats":{"Line":0}},{"line":68,"address":[350245],"length":1,"stats":{"Line":0}},{"line":71,"address":[238886,238400],"length":1,"stats":{"Line":2}},{"line":72,"address":[238438,238604],"length":1,"stats":{"Line":4}},{"line":73,"address":[238780],"length":1,"stats":{"Line":2}},{"line":76,"address":[350256],"length":1,"stats":{"Line":0}},{"line":77,"address":[350261],"length":1,"stats":{"Line":0}},{"line":80,"address":[348768,349275],"length":1,"stats":{"Line":1}},{"line":81,"address":[348798,348964],"length":1,"stats":{"Line":2}},{"line":82,"address":[349169],"length":1,"stats":{"Line":1}},{"line":85,"address":[349914,349296],"length":1,"stats":{"Line":1}},{"line":89,"address":[349603,349354],"length":1,"stats":{"Line":2}},{"line":90,"address":[349808],"length":1,"stats":{"Line":1}},{"line":93,"address":[349936],"length":1,"stats":{"Line":0}},{"line":94,"address":[349941],"length":1,"stats":{"Line":0}}],"covered":20,"coverable":26},{"path":["/","home","lucac","github","mermaid-builder","src","diagrams","entity_relationship","entity_relationship_node.rs"],"content":"//! Submodule defining the struct to represent an entity-relationship node\n//! for the entity-relationship diagram in Mermaid syntax.\n\nuse std::fmt::Display;\n\nmod attribute;\nmod builder;\nuse attribute::EntityRelationshipAttribute;\npub use builder::ERNodeBuilder;\n\nuse crate::{\n    shared::{GenericNode, NODE_LETTER, StyleClass, StyleProperty},\n    traits::Node,\n};\n\n#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// Struct representing an entity-relationship node in an ER diagram.\n///\n/// # Examples\n///\n/// ```\n/// use mermaid_builder::{\n///     diagrams::entity_relationship::ERNodeBuilder,\n///     traits::{Node, NodeBuilder},\n/// };\n///\n/// fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n///     let node = ERNodeBuilder::default()\n///         .label(\"USER\")?\n///         .id(1)\n///         .attribute(\"string\", \"username\")\n///         .build()?;\n///\n///     assert_eq!(node.label(), \"USER\");\n///     Ok(())\n/// }\n/// ```\npub struct ERNode {\n    /// Underlying node structure.\n    node: GenericNode,\n    /// Attributes of the entity-relationship node.\n    attributes: Vec\u003cEntityRelationshipAttribute\u003e,\n}\n\nimpl Node for ERNode {\n    type Builder = ERNodeBuilder;\n\n    fn label(\u0026self) -\u003e \u0026str {\n        self.node.label()\n    }\n\n    fn id(\u0026self) -\u003e u64 {\n        self.node.id()\n    }\n\n    fn styles(\u0026self) -\u003e impl Iterator\u003cItem = \u0026StyleProperty\u003e {\n        self.node.styles()\n    }\n\n    fn classes(\u0026self) -\u003e impl Iterator\u003cItem = \u0026StyleClass\u003e {\n        self.node.classes()\n    }\n\n    fn is_compatible_arrow_shape(shape: crate::shared::ArrowShape) -\u003e bool {\n        matches!(\n            shape,\n            crate::shared::ArrowShape::OneOrMore\n                | crate::shared::ArrowShape::ExactlyOne\n                | crate::shared::ArrowShape::ZeroOrOne\n                | crate::shared::ArrowShape::ZeroOrMore\n        )\n    }\n}\n\nimpl Display for ERNode {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        use crate::traits::TabbedDisplay;\n        self.fmt_tabbed(f, 0)\n    }\n}\n\nimpl crate::traits::TabbedDisplay for ERNode {\n    fn fmt_tabbed(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e, tab_count: usize) -\u003e std::fmt::Result {\n        let indent = \" \".repeat(tab_count * 2);\n        write!(f, \"{indent}{NODE_LETTER}{}[\\\"{}\\\"]\", self.id(), self.label())?;\n\n        if self.attributes.is_empty() {\n            writeln!(f)?;\n        } else {\n            writeln!(f, \" {{\")?;\n\n            for attr in \u0026self.attributes {\n                writeln!(f, \"{indent}    {attr}\")?;\n            }\n            writeln!(f, \"{indent}}}\")?;\n        }\n\n        for class in self.classes() {\n            writeln!(f, \"{indent}class {NODE_LETTER}{} {}\", self.id(), class.name())?;\n        }\n\n        Ok(())\n    }\n}\n","traces":[{"line":49,"address":[688848],"length":1,"stats":{"Line":0}},{"line":50,"address":[688853],"length":1,"stats":{"Line":0}},{"line":53,"address":[688832],"length":1,"stats":{"Line":1}},{"line":54,"address":[688837],"length":1,"stats":{"Line":1}},{"line":57,"address":[688864],"length":1,"stats":{"Line":0}},{"line":58,"address":[688869],"length":1,"stats":{"Line":0}},{"line":61,"address":[688880],"length":1,"stats":{"Line":0}},{"line":62,"address":[688885],"length":1,"stats":{"Line":0}},{"line":65,"address":[688784],"length":1,"stats":{"Line":2}},{"line":66,"address":[688794],"length":1,"stats":{"Line":2}},{"line":67,"address":[688791],"length":1,"stats":{"Line":2}},{"line":77,"address":[691968],"length":1,"stats":{"Line":0}},{"line":79,"address":[691982],"length":1,"stats":{"Line":0}},{"line":84,"address":[691263,688960,691257],"length":1,"stats":{"Line":0}},{"line":85,"address":[689087,689010],"length":1,"stats":{"Line":0}},{"line":86,"address":[689160,691243,689072],"length":1,"stats":{"Line":0}},{"line":88,"address":[689613],"length":1,"stats":{"Line":0}},{"line":89,"address":[690512,689679,691222],"length":1,"stats":{"Line":0}},{"line":91,"address":[689644,689741,690474],"length":1,"stats":{"Line":0}},{"line":93,"address":[689834],"length":1,"stats":{"Line":0}},{"line":94,"address":[689987,690289],"length":1,"stats":{"Line":0}},{"line":96,"address":[690041,690245],"length":1,"stats":{"Line":0}},{"line":99,"address":[690596,690221],"length":1,"stats":{"Line":0}},{"line":100,"address":[690793,690732],"length":1,"stats":{"Line":0}},{"line":103,"address":[690744],"length":1,"stats":{"Line":0}}],"covered":5,"coverable":25},{"path":["/","home","lucac","github","mermaid-builder","src","diagrams","entity_relationship.rs"],"content":"//! Submodule providing structs to characterize an ER (Entity-Relationship)\n//! Diagram in Mermaid syntax.\n\nmod entity_relationship_edge;\nmod entity_relationship_node;\nuse std::fmt::Display;\n\nuse entity_relationship_edge::EREdge;\npub use entity_relationship_edge::EREdgeBuilder;\nuse entity_relationship_node::ERNode;\npub use entity_relationship_node::ERNodeBuilder;\n\nuse crate::{\n    shared::{\n        generic_configuration::{GenericConfiguration, GenericConfigurationBuilder},\n        generic_diagram::{GenericDiagram, GenericDiagramBuilder},\n    },\n    traits::{configuration::Configuration, diagram::Diagram},\n};\n\n/// Represents the configuration for an entity-relationship diagram.\npub type ERDiagramConfiguration = GenericConfiguration;\n/// Represents the configuration builder for an entity-relationship diagram.\npub type ERDiagramConfigurationBuilder = GenericConfigurationBuilder;\n/// Represents an entity-relationship diagram in Mermaid syntax.\npub type ERDiagram = GenericDiagram\u003cERNode, EREdge, GenericConfiguration\u003e;\n/// Represents a builder for an entity-relationship diagram in Mermaid syntax.\npub type ERDiagramBuilder = GenericDiagramBuilder\u003cERNode, EREdge, GenericConfiguration\u003e;\n\nimpl Display for ERDiagram {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        use crate::traits::TabbedDisplay;\n        self.fmt_tabbed(f, 0)\n    }\n}\n\nimpl crate::traits::TabbedDisplay for ERDiagram {\n    fn fmt_tabbed(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e, tab_count: usize) -\u003e std::fmt::Result {\n        let indent = \" \".repeat(tab_count * 2);\n        write!(f, \"{}\", self.configuration())?;\n        writeln!(f, \"{indent}erDiagram\")?;\n        writeln!(f, \"{indent}  direction {}\", self.configuration().direction())?;\n        for style_class in self.style_classes() {\n            style_class.fmt_tabbed(f, tab_count + 1)?;\n        }\n        for node in self.nodes() {\n            node.fmt_tabbed(f, tab_count + 1)?;\n        }\n        for edge in self.edges() {\n            edge.fmt_tabbed(f, tab_count + 1)?;\n        }\n        Ok(())\n    }\n}\n","traces":[{"line":31,"address":[578928],"length":1,"stats":{"Line":0}},{"line":33,"address":[578942],"length":1,"stats":{"Line":0}},{"line":38,"address":[583193,583199,581152],"length":1,"stats":{"Line":0}},{"line":39,"address":[581210,581287],"length":1,"stats":{"Line":0}},{"line":40,"address":[581352,583179,581272],"length":1,"stats":{"Line":0}},{"line":41,"address":[583158,581566],"length":1,"stats":{"Line":0}},{"line":42,"address":[583137,581764],"length":1,"stats":{"Line":0}},{"line":43,"address":[582076],"length":1,"stats":{"Line":0}},{"line":44,"address":[582272,583020],"length":1,"stats":{"Line":0}},{"line":46,"address":[582309],"length":1,"stats":{"Line":0}},{"line":47,"address":[582472,582886],"length":1,"stats":{"Line":0}},{"line":49,"address":[582506],"length":1,"stats":{"Line":0}},{"line":50,"address":[582669,582745],"length":1,"stats":{"Line":0}},{"line":52,"address":[582688],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":14},{"path":["/","home","lucac","github","mermaid-builder","src","diagrams","flowchart","builder.rs"],"content":"//! Submodule providing a builder for flowchart diagrams in Mermaid syntax.\n\nuse crate::{\n    prelude::{\n        Flowchart, FlowchartConfiguration, FlowchartConfigurationBuilder, FlowchartEdge,\n        FlowchartEdgeBuilder, FlowchartNode, FlowchartNodeBuilder,\n    },\n    shared::{StyleClass, StyleClassBuilder, generic_diagram::GenericDiagramBuilder},\n    traits::DiagramBuilder,\n};\n\n#[derive(Default, Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// Represents a builder for a flowchart diagram in Mermaid syntax.\npub struct FlowchartBuilder {\n    /// The configuration of the flowchart.\n    generic: GenericDiagramBuilder\u003cFlowchartNode, FlowchartEdge, FlowchartConfiguration\u003e,\n}\n\nimpl From\u003cFlowchartBuilder\u003e for Flowchart {\n    fn from(builder: FlowchartBuilder) -\u003e Self {\n        let generic = builder.generic.into();\n        Flowchart { generic }\n    }\n}\n\nimpl DiagramBuilder for FlowchartBuilder {\n    type Configuration = FlowchartConfiguration;\n    type ConfigurationBuilder = FlowchartConfigurationBuilder;\n    type Diagram = Flowchart;\n    type Edge = FlowchartEdge;\n    type EdgeBuilder = FlowchartEdgeBuilder;\n    type Node = FlowchartNode;\n    type NodeBuilder = FlowchartNodeBuilder;\n    type Error = crate::errors::Error;\n\n    fn configuration(\n        mut self,\n        configuration: Self::ConfigurationBuilder,\n    ) -\u003e Result\u003cSelf, Self::Error\u003e {\n        self.generic = self.generic.configuration(configuration)?;\n        Ok(self)\n    }\n\n    fn edge(\n        \u0026mut self,\n        mut edge: Self::EdgeBuilder,\n    ) -\u003e Result\u003cstd::rc::Rc\u003cSelf::Edge\u003e, Self::Error\u003e {\n        edge = edge.id(self.number_of_edges());\n        self.generic.edge(edge)\n    }\n\n    fn get_node_by_id(\u0026self, id: u64) -\u003e Option\u003cstd::rc::Rc\u003cSelf::Node\u003e\u003e {\n        self.generic.get_node_by_id(id)\n    }\n\n    fn node(\u0026mut self, node: Self::NodeBuilder) -\u003e Result\u003cstd::rc::Rc\u003cSelf::Node\u003e, Self::Error\u003e {\n        self.generic.node(node)\n    }\n\n    fn nodes(\u0026self) -\u003e impl Iterator\u003cItem = \u0026std::rc::Rc\u003cSelf::Node\u003e\u003e + '_ {\n        self.generic.nodes()\n    }\n\n    fn number_of_edges(\u0026self) -\u003e usize {\n        self.generic.number_of_edges()\n    }\n\n    fn number_of_nodes(\u0026self) -\u003e usize {\n        self.generic.number_of_nodes()\n    }\n\n    fn style_class(\n        \u0026mut self,\n        style_class: StyleClassBuilder,\n    ) -\u003e Result\u003cstd::rc::Rc\u003cStyleClass\u003e, Self::Error\u003e {\n        self.generic.style_class(style_class)\n    }\n\n    fn get_style_class_by_name(\u0026self, name: \u0026str) -\u003e Option\u003cstd::rc::Rc\u003cStyleClass\u003e\u003e {\n        self.generic.get_style_class_by_name(name)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::{\n        prelude::{FlowchartConfigurationBuilder, FlowchartEdgeBuilder, FlowchartNodeBuilder},\n        shared::{StyleClassBuilder, StyleProperty, style_class::Color},\n        traits::{ConfigurationBuilder, DiagramBuilder, EdgeBuilder, NodeBuilder, edge::Edge, node::Node},\n    };\n\n    #[test]\n    fn test_flowchart_builder() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n        let mut builder = FlowchartBuilder::default();\n\n        // Test configuration\n        let config = FlowchartConfigurationBuilder::default().title(\"My Flowchart\")?;\n        builder = builder.configuration(config)?;\n\n        // Test style class\n        let style_class_builder = StyleClassBuilder::default()\n            .name(\"myStyle\")?\n            .property(StyleProperty::Fill(Color::from((255, 0, 0))))?;\n        let style_class = builder.style_class(style_class_builder)?;\n        assert_eq!(style_class.name(), \"myStyle\");\n        assert!(builder.get_style_class_by_name(\"myStyle\").is_some());\n\n        // Test node\n        let node_builder = FlowchartNodeBuilder::default().label(\"Node A\")?;\n        let node_a = builder.node(node_builder)?;\n        assert_eq!(builder.number_of_nodes(), 1);\n        assert!(builder.get_node_by_id(node_a.id()).is_some());\n\n        let node_builder_b = FlowchartNodeBuilder::default().label(\"Node B\")?;\n        let node_b = builder.node(node_builder_b)?;\n        assert_eq!(builder.number_of_nodes(), 2);\n\n        // Test nodes iterator\n        let nodes: Vec\u003c_\u003e = builder.nodes().collect();\n        assert_eq!(nodes.len(), 2);\n\n        // Test edge\n        let edge_builder = FlowchartEdgeBuilder::default()\n            .source(node_a.clone())?\n            .destination(node_b.clone())?;\n        let edge = builder.edge(edge_builder)?;\n        assert_eq!(builder.number_of_edges(), 1);\n        assert_eq!(edge.source().id(), node_a.id());\n        assert_eq!(edge.destination().id(), node_b.id());\n\n        // Test build (into Flowchart)\n        let flowchart: Flowchart = builder.into();\n        // We can't easily inspect the flowchart internals here without more accessors,\n        // but the conversion should succeed.\n\n        Ok(())\n    }\n}\n","traces":[{"line":21,"address":[562400],"length":1,"stats":{"Line":1}},{"line":22,"address":[562417],"length":1,"stats":{"Line":1}},{"line":37,"address":[788624,789151,789176],"length":1,"stats":{"Line":1}},{"line":41,"address":[788873,789149,788646],"length":1,"stats":{"Line":2}},{"line":42,"address":[789087],"length":1,"stats":{"Line":1}},{"line":45,"address":[789280,789632,789604],"length":1,"stats":{"Line":1}},{"line":49,"address":[789322,789625],"length":1,"stats":{"Line":1}},{"line":50,"address":[789550],"length":1,"stats":{"Line":1}},{"line":53,"address":[789184],"length":1,"stats":{"Line":1}},{"line":54,"address":[789198],"length":1,"stats":{"Line":1}},{"line":57,"address":[789648],"length":1,"stats":{"Line":1}},{"line":58,"address":[789686],"length":1,"stats":{"Line":1}},{"line":61,"address":[789744],"length":1,"stats":{"Line":1}},{"line":62,"address":[789749],"length":1,"stats":{"Line":1}},{"line":65,"address":[789216],"length":1,"stats":{"Line":1}},{"line":66,"address":[789221],"length":1,"stats":{"Line":1}},{"line":69,"address":[789232],"length":1,"stats":{"Line":1}},{"line":70,"address":[789237],"length":1,"stats":{"Line":1}},{"line":73,"address":[788544],"length":1,"stats":{"Line":1}},{"line":77,"address":[788579],"length":1,"stats":{"Line":1}},{"line":80,"address":[789248],"length":1,"stats":{"Line":1}},{"line":81,"address":[789266],"length":1,"stats":{"Line":1}}],"covered":22,"coverable":22},{"path":["/","home","lucac","github","mermaid-builder","src","diagrams","flowchart","configuration","builder.rs"],"content":"//! Submodule providing a builder struct for the configuration of flowchart\n//! diagrams in Mermaid syntax.\n\nuse crate::{\n    diagrams::flowchart::{configuration::FlowchartConfiguration, curve_styles::CurveStyle},\n    errors::ConfigError,\n    shared::generic_configuration::GenericConfigurationBuilder,\n    traits::ConfigurationBuilder,\n};\n\n#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// Builder for creating flowchart configurations with various properties.\npub struct FlowchartConfigurationBuilder {\n    /// Generic configuration options which apply to all Mermaid diagrams.\n    generic: GenericConfigurationBuilder,\n    /// Whether to enable html labels in the flowchart.\n    html_labels: bool,\n    /// Whether to automatically wrap markdown labels.\n    markdown_auto_wrap: bool,\n    /// The curve style used for edges in the flowchart.\n    curve_style: CurveStyle,\n}\n\nimpl FlowchartConfigurationBuilder {\n    #[must_use]\n    /// Sets whether to enable html labels in the flowchart.\n    pub fn html_labels(mut self, enable: bool) -\u003e Self {\n        self.html_labels = enable;\n        self\n    }\n\n    #[must_use]\n    /// Sets whether to automatically wrap markdown labels.\n    pub fn markdown_auto_wrap(mut self, auto_wrap: bool) -\u003e Self {\n        self.markdown_auto_wrap = auto_wrap;\n        self\n    }\n\n    #[must_use]\n    /// Sets the curve style for edges in the flowchart.\n    pub fn curve_style(mut self, style: CurveStyle) -\u003e Self {\n        self.curve_style = style;\n        self\n    }\n\n    /// Sets the theme to use for the diagram.\n    #[must_use]\n    pub fn theme(mut self, theme: crate::shared::generic_configuration::Theme) -\u003e Self {\n        self.generic = self.generic.theme(theme);\n        self\n    }\n\n    /// Sets the look to use for the diagram.\n    #[must_use]\n    pub fn look(mut self, look: crate::shared::generic_configuration::Look) -\u003e Self {\n        self.generic = self.generic.look(look);\n        self\n    }\n}\n\nimpl TryFrom\u003cFlowchartConfigurationBuilder\u003e for FlowchartConfiguration {\n    type Error = ConfigError;\n\n    fn try_from(builder: FlowchartConfigurationBuilder) -\u003e Result\u003cSelf, Self::Error\u003e {\n        Ok(FlowchartConfiguration {\n            generic: builder.generic.try_into()?,\n            markdown_auto_wrap: builder.markdown_auto_wrap,\n            html_labels: builder.html_labels,\n            curve_style: builder.curve_style,\n        })\n    }\n}\n\nimpl ConfigurationBuilder for FlowchartConfigurationBuilder {\n    type Configuration = FlowchartConfiguration;\n    type Error = ConfigError;\n\n    fn build(self) -\u003e Result\u003cSelf::Configuration, Self::Error\u003e {\n        self.try_into()\n    }\n\n    fn title\u003cS: ToString\u003e(mut self, title: S) -\u003e Result\u003cSelf, Self::Error\u003e {\n        self.generic = self.generic.title(title)?;\n        Ok(self)\n    }\n\n    fn direction(mut self, direction: crate::shared::generic_configuration::Direction) -\u003e Self {\n        self.generic = self.generic.direction(direction);\n        self\n    }\n\n    fn renderer(mut self, renderer: crate::shared::generic_configuration::Renderer) -\u003e Self {\n        self.generic = self.generic.renderer(renderer);\n        self\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::{\n        shared::generic_configuration::{Direction, Look, Renderer, Theme},\n        traits::Configuration,\n    };\n\n    #[test]\n    fn test_flowchart_configuration_builder() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n        let config = FlowchartConfigurationBuilder::default()\n            .title(\"My Flowchart\")?\n            .direction(Direction::TopToBottom)\n            .renderer(Renderer::EclipseLayoutKernel)\n            .theme(Theme::Forest)\n            .look(Look::HandDrawn)\n            .html_labels(true)\n            .markdown_auto_wrap(false)\n            .curve_style(CurveStyle::Basis)\n            .build()?;\n\n        assert!(config.html_labels);\n        assert!(!config.markdown_auto_wrap);\n        assert_eq!(config.curve_style, CurveStyle::Basis);\n        assert_eq!(config.title(), Some(\"My Flowchart\"));\n        assert_eq!(config.direction(), Direction::TopToBottom);\n        assert_eq!(config.renderer(), Renderer::EclipseLayoutKernel);\n        assert_eq!(config.theme(), Theme::Forest);\n        assert_eq!(config.look(), Look::HandDrawn);\n        Ok(())\n    }\n}\n","traces":[{"line":28,"address":[285696],"length":1,"stats":{"Line":1}},{"line":29,"address":[285719],"length":1,"stats":{"Line":1}},{"line":30,"address":[285724],"length":1,"stats":{"Line":1}},{"line":35,"address":[285744],"length":1,"stats":{"Line":1}},{"line":36,"address":[285767],"length":1,"stats":{"Line":1}},{"line":37,"address":[285772],"length":1,"stats":{"Line":1}},{"line":42,"address":[285648],"length":1,"stats":{"Line":1}},{"line":43,"address":[285666],"length":1,"stats":{"Line":1}},{"line":44,"address":[285669],"length":1,"stats":{"Line":1}},{"line":49,"address":[285936],"length":1,"stats":{"Line":2}},{"line":50,"address":[285961],"length":1,"stats":{"Line":3}},{"line":51,"address":[286059],"length":1,"stats":{"Line":3}},{"line":56,"address":[285792],"length":1,"stats":{"Line":3}},{"line":57,"address":[285817],"length":1,"stats":{"Line":3}},{"line":58,"address":[285915],"length":1,"stats":{"Line":3}},{"line":65,"address":[384080],"length":1,"stats":{"Line":1}},{"line":66,"address":[384307],"length":1,"stats":{"Line":3}},{"line":67,"address":[384101],"length":1,"stats":{"Line":1}},{"line":68,"address":[384298],"length":1,"stats":{"Line":3}},{"line":69,"address":[384301],"length":1,"stats":{"Line":3}},{"line":70,"address":[384304],"length":1,"stats":{"Line":3}},{"line":79,"address":[286144],"length":1,"stats":{"Line":1}},{"line":80,"address":[286157],"length":1,"stats":{"Line":1}},{"line":83,"address":[412194,411808,412219],"length":1,"stats":{"Line":3}},{"line":84,"address":[412192,411846,411955],"length":1,"stats":{"Line":7}},{"line":85,"address":[412130],"length":1,"stats":{"Line":4}},{"line":88,"address":[286368],"length":1,"stats":{"Line":2}},{"line":89,"address":[286393],"length":1,"stats":{"Line":2}},{"line":90,"address":[286491],"length":1,"stats":{"Line":2}},{"line":93,"address":[286208],"length":1,"stats":{"Line":1}},{"line":94,"address":[286238],"length":1,"stats":{"Line":1}},{"line":95,"address":[286339],"length":1,"stats":{"Line":1}}],"covered":32,"coverable":32},{"path":["/","home","lucac","github","mermaid-builder","src","diagrams","flowchart","configuration.rs"],"content":"//! Submodule defining configuration specifically for flowchart diagrams in\n//! Mermaid.\n\nmod builder;\n\nuse std::fmt::Display;\n\npub use builder::FlowchartConfigurationBuilder;\n\nuse crate::{\n    diagrams::flowchart::curve_styles::CurveStyle,\n    shared::{\n        Direction, Renderer,\n        generic_configuration::{GenericConfiguration, Look, Theme},\n    },\n    traits::Configuration,\n};\n\n#[derive(Default, Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// Represents the configuration for a flowchart diagram in Mermaid syntax.\npub struct FlowchartConfiguration {\n    /// Generic configuration options which apply to all Mermaid diagrams.\n    generic: GenericConfiguration,\n    /// Whether to automatically wrap markdown labels.\n    markdown_auto_wrap: bool,\n    /// Whether to enable html labels in the flowchart.\n    html_labels: bool,\n    /// The curve style used for edges in the flowchart.\n    curve_style: CurveStyle,\n}\n\nimpl Display for FlowchartConfiguration {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        if self.generic.title().is_none() \u0026\u0026 self.renderer() == Renderer::default() {\n            return Ok(());\n        }\n        writeln!(f, \"---\")?;\n        writeln!(f, \"config:\")?;\n        writeln!(f, \"  theme: {}\", self.theme())?;\n        writeln!(f, \"  look: {}\", self.look())?;\n        writeln!(f, \"  flowchart:\")?;\n        writeln!(f, \"    defaultRenderer: \\\"{}\\\"\", self.renderer())?;\n        if let Some(title) = \u0026self.generic.title() {\n            writeln!(f, \"title: {title}\")?;\n        }\n        writeln!(f, \"---\")?;\n\n        Ok(())\n    }\n}\n\nimpl Configuration for FlowchartConfiguration {\n    type Builder = FlowchartConfigurationBuilder;\n\n    fn title(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n        self.generic.title()\n    }\n\n    fn direction(\u0026self) -\u003e Direction {\n        self.generic.direction()\n    }\n\n    fn renderer(\u0026self) -\u003e Renderer {\n        self.generic.renderer()\n    }\n\n    fn theme(\u0026self) -\u003e Theme {\n        self.generic.theme()\n    }\n\n    fn look(\u0026self) -\u003e Look {\n        self.generic.look()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::traits::ConfigurationBuilder;\n\n    #[test]\n    fn test_flowchart_configuration_display_default() {\n        let config = FlowchartConfiguration::default();\n        assert_eq!(format!(\"{config}\"), \"\");\n    }\n\n    #[test]\n    fn test_flowchart_configuration_display_full() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n        let config = FlowchartConfigurationBuilder::default()\n            .title(\"My Flowchart\")?\n            .renderer(Renderer::EclipseLayoutKernel)\n            .theme(Theme::Forest)\n            .look(Look::HandDrawn)\n            .build()?;\n\n        let output = format!(\"{config}\");\n        assert!(output.contains(\"title: My Flowchart\"));\n        assert!(output.contains(\"defaultRenderer: \\\"elk\\\"\"));\n        assert!(output.contains(\"theme: forest\"));\n        assert!(output.contains(\"look: handDrawn\"));\n        Ok(())\n    }\n\n    #[test]\n    fn test_flowchart_configuration_traits() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n        let config = FlowchartConfigurationBuilder::default()\n            .title(\"My Flowchart\")?\n            .direction(Direction::TopToBottom)\n            .renderer(Renderer::EclipseLayoutKernel)\n            .theme(Theme::Forest)\n            .look(Look::HandDrawn)\n            .build()?;\n\n        assert_eq!(config.title(), Some(\"My Flowchart\"));\n        assert_eq!(config.direction(), Direction::TopToBottom);\n        assert_eq!(config.renderer(), Renderer::EclipseLayoutKernel);\n        assert_eq!(config.theme(), Theme::Forest);\n        assert_eq!(config.look(), Look::HandDrawn);\n        Ok(())\n    }\n}\n","traces":[{"line":34,"address":[381504],"length":1,"stats":{"Line":1}},{"line":35,"address":[381536,381625],"length":1,"stats":{"Line":2}},{"line":36,"address":[381668],"length":1,"stats":{"Line":1}},{"line":38,"address":[381565,381678],"length":1,"stats":{"Line":1}},{"line":39,"address":[381701],"length":1,"stats":{"Line":1}},{"line":40,"address":[381782],"length":1,"stats":{"Line":1}},{"line":41,"address":[381921],"length":1,"stats":{"Line":1}},{"line":42,"address":[382055],"length":1,"stats":{"Line":1}},{"line":43,"address":[382136],"length":1,"stats":{"Line":1}},{"line":44,"address":[382294],"length":1,"stats":{"Line":1}},{"line":45,"address":[382366,382549],"length":1,"stats":{"Line":1}},{"line":47,"address":[382581,382493],"length":1,"stats":{"Line":1}},{"line":49,"address":[382601],"length":1,"stats":{"Line":1}},{"line":56,"address":[384032],"length":1,"stats":{"Line":1}},{"line":57,"address":[384037],"length":1,"stats":{"Line":1}},{"line":60,"address":[384064],"length":1,"stats":{"Line":1}},{"line":61,"address":[384069],"length":1,"stats":{"Line":2}},{"line":64,"address":[384048],"length":1,"stats":{"Line":1}},{"line":65,"address":[384053],"length":1,"stats":{"Line":1}},{"line":68,"address":[384016],"length":1,"stats":{"Line":1}},{"line":69,"address":[384021],"length":1,"stats":{"Line":3}},{"line":72,"address":[384000],"length":1,"stats":{"Line":2}},{"line":73,"address":[384005],"length":1,"stats":{"Line":3}}],"covered":23,"coverable":23},{"path":["/","home","lucac","github","mermaid-builder","src","diagrams","flowchart","curve_styles.rs"],"content":"//! Submodule providing an enumeration of possible curve styles for flowchart\n//! edges in Mermaid diagrams.\n\n#[derive(Default, Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// Represents the curve styles available for flowchart edges in Mermaid syntax.\npub enum CurveStyle {\n    /// Basis curve style.\n    #[default]\n    Basis,\n    /// `BumpX` curve style.\n    BumpX,\n    /// `BumpY` curve style.\n    BumpY,\n    /// `Cardinal` curve style.\n    Cardinal,\n    /// `CatmullRom` curve style.\n    CatmullRom,\n    /// `Linear` curve style.\n    Linear,\n    /// `MonotoneX` curve style.\n    MonotoneX,\n    /// `MonotoneY` curve style.\n    MonotoneY,\n    /// `Natural` curve style.\n    Natural,\n    /// `Step` curve style.\n    Step,\n    /// `StepAfter` curve style.\n    StepAfter,\n    /// `StepBefore` curve style.\n    StepBefore,\n}\n\nimpl std::fmt::Display for CurveStyle {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            CurveStyle::Basis =\u003e write!(f, \"basis\"),\n            CurveStyle::BumpX =\u003e write!(f, \"bumpX\"),\n            CurveStyle::BumpY =\u003e write!(f, \"bumpY\"),\n            CurveStyle::Cardinal =\u003e write!(f, \"cardinal\"),\n            CurveStyle::CatmullRom =\u003e write!(f, \"catmullRom\"),\n            CurveStyle::Linear =\u003e write!(f, \"linear\"),\n            CurveStyle::MonotoneX =\u003e write!(f, \"monotoneX\"),\n            CurveStyle::MonotoneY =\u003e write!(f, \"monotoneY\"),\n            CurveStyle::Natural =\u003e write!(f, \"natural\"),\n            CurveStyle::Step =\u003e write!(f, \"step\"),\n            CurveStyle::StepAfter =\u003e write!(f, \"stepAfter\"),\n            CurveStyle::StepBefore =\u003e write!(f, \"stepBefore\"),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_curve_style_display() {\n        assert_eq!(CurveStyle::Basis.to_string(), \"basis\");\n        assert_eq!(CurveStyle::BumpX.to_string(), \"bumpX\");\n        assert_eq!(CurveStyle::BumpY.to_string(), \"bumpY\");\n        assert_eq!(CurveStyle::Cardinal.to_string(), \"cardinal\");\n        assert_eq!(CurveStyle::CatmullRom.to_string(), \"catmullRom\");\n        assert_eq!(CurveStyle::Linear.to_string(), \"linear\");\n        assert_eq!(CurveStyle::MonotoneX.to_string(), \"monotoneX\");\n        assert_eq!(CurveStyle::MonotoneY.to_string(), \"monotoneY\");\n        assert_eq!(CurveStyle::Natural.to_string(), \"natural\");\n        assert_eq!(CurveStyle::Step.to_string(), \"step\");\n        assert_eq!(CurveStyle::StepAfter.to_string(), \"stepAfter\");\n        assert_eq!(CurveStyle::StepBefore.to_string(), \"stepBefore\");\n    }\n}\n","traces":[{"line":36,"address":[384416],"length":1,"stats":{"Line":1}},{"line":37,"address":[384434],"length":1,"stats":{"Line":1}},{"line":38,"address":[384465],"length":1,"stats":{"Line":1}},{"line":39,"address":[384505],"length":1,"stats":{"Line":1}},{"line":40,"address":[384545],"length":1,"stats":{"Line":1}},{"line":41,"address":[384585],"length":1,"stats":{"Line":1}},{"line":42,"address":[384625],"length":1,"stats":{"Line":1}},{"line":43,"address":[384665],"length":1,"stats":{"Line":1}},{"line":44,"address":[384705],"length":1,"stats":{"Line":1}},{"line":45,"address":[384745],"length":1,"stats":{"Line":1}},{"line":46,"address":[384785],"length":1,"stats":{"Line":1}},{"line":47,"address":[384822],"length":1,"stats":{"Line":1}},{"line":48,"address":[384859],"length":1,"stats":{"Line":1}},{"line":49,"address":[384896],"length":1,"stats":{"Line":1}}],"covered":14,"coverable":14},{"path":["/","home","lucac","github","mermaid-builder","src","diagrams","flowchart","flowchart_edge","builder.rs"],"content":"//! Submodule defining the struct for building a flowchart edge.\n\nuse std::rc::Rc;\n\nuse crate::{\n    diagrams::flowchart::{\n        curve_styles::CurveStyle, flowchart_edge::FlowchartEdge, flowchart_node::FlowchartNode,\n    },\n    errors::EdgeError,\n    shared::{StyleClass, StyleClassError, StyleProperty, generic_edge::GenericEdgeBuilder},\n    traits::EdgeBuilder,\n};\n\n#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// Builder for creating a `FlowchartEdge`.\n///\n/// # Example\n///\n/// ```\n/// use std::rc::Rc;\n///\n/// use mermaid_builder::prelude::*;\n///\n/// let node1 = Rc::new(FlowchartNodeBuilder::default().label(\"A\").unwrap().id(0).build().unwrap());\n/// let node2 = Rc::new(FlowchartNodeBuilder::default().label(\"B\").unwrap().id(1).build().unwrap());\n///\n/// let edge = FlowchartEdgeBuilder::default()\n///     .source(node1)\n///     .unwrap()\n///     .destination(node2)\n///     .unwrap()\n///     .length(2)\n///     .id(0)\n///     .build()\n///     .unwrap();\n/// ```\npub struct FlowchartEdgeBuilder {\n    /// Unique identifier for the edge.\n    id: Option\u003cusize\u003e,\n    /// Underlying generic edge builder.\n    edge_builder: GenericEdgeBuilder\u003cFlowchartNode\u003e,\n    /// Classes associated with the edge.\n    style_classes: Vec\u003cRc\u003cStyleClass\u003e\u003e,\n    /// Style properties for the edge.\n    style_properties: Vec\u003cStyleProperty\u003e,\n    /// The curve style for the edge.\n    curve_style: CurveStyle,\n    /// Length of the edge.\n    length: u8,\n}\n\nimpl FlowchartEdgeBuilder {\n    #[must_use]\n    /// Creates a new `FlowchartEdgeBuilder`.\n    pub fn id(mut self, id: usize) -\u003e Self {\n        self.id = Some(id);\n        self\n    }\n\n    /// Adds a style class to the edge builder.\n    ///\n    /// # Arguments\n    ///\n    /// * `class`: The style class to be added\n    ///\n    /// # Errors\n    ///\n    /// * If the class is already present, an error is returned.\n    pub fn style_class(mut self, class: Rc\u003cStyleClass\u003e) -\u003e Result\u003cSelf, StyleClassError\u003e {\n        if self.style_classes.iter().any(|c| c.name() == class.name()) {\n            return Err(StyleClassError::DuplicateClass(class.name().to_string()));\n        }\n        self.style_classes.push(class);\n        Ok(self)\n    }\n\n    /// Adds a style property to the edge builder.\n    ///\n    /// # Arguments\n    ///\n    /// * `property`: The style property to be added.\n    ///\n    /// # Errors\n    ///\n    /// * If the property is already present, an error is returned.\n    pub fn style_property(mut self, property: StyleProperty) -\u003e Result\u003cSelf, StyleClassError\u003e {\n        if self.style_properties.iter().any(|p| p.is_same_type(property)) {\n            return Err(StyleClassError::DuplicateProperty(property));\n        }\n        self.style_properties.push(property);\n        Ok(self)\n    }\n\n    #[must_use]\n    /// Sets the curve style for the edge.\n    pub fn curve_style(mut self, style: CurveStyle) -\u003e Self {\n        self.curve_style = style;\n        self\n    }\n\n    #[must_use]\n    /// Sets the length of the edge.\n    pub fn length(mut self, length: u8) -\u003e Self {\n        self.length = length;\n        self\n    }\n}\n\nimpl Default for FlowchartEdgeBuilder {\n    fn default() -\u003e Self {\n        Self {\n            id: None,\n            edge_builder: GenericEdgeBuilder::default(),\n            style_classes: Vec::new(),\n            style_properties: Vec::new(),\n            curve_style: CurveStyle::default(),\n            length: 1,\n        }\n    }\n}\n\nimpl TryFrom\u003cFlowchartEdgeBuilder\u003e for FlowchartEdge {\n    type Error = EdgeError;\n\n    fn try_from(builder: FlowchartEdgeBuilder) -\u003e Result\u003cSelf, Self::Error\u003e {\n        if builder.length == 0 {\n            return Err(EdgeError::InvalidLength);\n        }\n\n        Ok(FlowchartEdge {\n            id: builder.id.ok_or(EdgeError::MissingId)?,\n            edge: builder.edge_builder.try_into()?,\n            style_classes: builder.style_classes,\n            style_properties: builder.style_properties,\n            curve_style: builder.curve_style,\n            length: builder.length,\n        })\n    }\n}\n\nimpl EdgeBuilder for FlowchartEdgeBuilder {\n    type Edge = FlowchartEdge;\n    type Node = FlowchartNode;\n    type Error = EdgeError;\n\n    fn build(self) -\u003e Result\u003cSelf::Edge, Self::Error\u003e {\n        self.try_into()\n    }\n\n    fn source(mut self, node: std::rc::Rc\u003cSelf::Node\u003e) -\u003e Result\u003cSelf, Self::Error\u003e {\n        self.edge_builder = self.edge_builder.source(node)?;\n        Ok(self)\n    }\n\n    fn destination(mut self, node: std::rc::Rc\u003cSelf::Node\u003e) -\u003e Result\u003cSelf, Self::Error\u003e {\n        self.edge_builder = self.edge_builder.destination(node)?;\n        Ok(self)\n    }\n\n    fn label\u003cS: ToString\u003e(mut self, label: S) -\u003e Result\u003cSelf, Self::Error\u003e {\n        self.edge_builder = self.edge_builder.label(label)?;\n        Ok(self)\n    }\n\n    fn line_style(mut self, style: crate::shared::LineStyle) -\u003e Self {\n        self.edge_builder = self.edge_builder.line_style(style);\n        self\n    }\n\n    fn left_arrow_shape(mut self, shape: crate::shared::ArrowShape) -\u003e Result\u003cSelf, Self::Error\u003e {\n        self.edge_builder = self.edge_builder.left_arrow_shape(shape)?;\n        Ok(self)\n    }\n\n    fn right_arrow_shape(mut self, shape: crate::shared::ArrowShape) -\u003e Result\u003cSelf, Self::Error\u003e {\n        self.edge_builder = self.edge_builder.right_arrow_shape(shape)?;\n        Ok(self)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use std::rc::Rc;\n\n    use super::*;\n    use crate::{\n        diagrams::flowchart::flowchart_node::FlowchartNodeBuilder,\n        shared::{ArrowShape, LineStyle, StyleClassBuilder, style_class::Unit},\n        traits::{NodeBuilder, edge::Edge, node::Node},\n    };\n\n    #[test]\n    fn test_flowchart_edge_builder() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n        let node1 = Rc::new(FlowchartNodeBuilder::default().label(\"A\")?.id(0).build()?);\n        let node2 = Rc::new(FlowchartNodeBuilder::default().label(\"B\")?.id(1).build()?);\n        let style_class = Rc::new(\n            StyleClassBuilder::default()\n                .name(\"test\")?\n                .property(StyleProperty::StrokeWidth(Unit::Pixel(2)))?\n                .build()?,\n        );\n\n        let edge = FlowchartEdgeBuilder::default()\n            .id(1)\n            .source(node1.clone())?\n            .destination(node2.clone())?\n            .label(\"Edge Label\")?\n            .line_style(LineStyle::Dashed)\n            .left_arrow_shape(ArrowShape::Circle)?\n            .right_arrow_shape(ArrowShape::X)?\n            .curve_style(CurveStyle::StepAfter)\n            .length(2)\n            .style_class(style_class.clone())?\n            .style_property(StyleProperty::StrokeWidth(Unit::Pixel(2)))?\n            .build()?;\n\n        assert_eq!(edge.id, 1);\n        assert_eq!(edge.source().id(), 0);\n        assert_eq!(edge.destination().id(), 1);\n        assert_eq!(edge.label(), Some(\"Edge Label\"));\n        assert_eq!(edge.line_style(), LineStyle::Dashed);\n        assert_eq!(edge.left_arrow_shape(), Some(ArrowShape::Circle));\n        assert_eq!(edge.right_arrow_shape(), Some(ArrowShape::X));\n        assert_eq!(edge.curve_style, CurveStyle::StepAfter);\n        assert_eq!(edge.length, 2);\n        assert_eq!(edge.style_classes.len(), 1);\n        assert_eq!(edge.style_properties.len(), 1);\n        Ok(())\n    }\n}\n","traces":[{"line":56,"address":[208256],"length":1,"stats":{"Line":3}},{"line":57,"address":[208273],"length":1,"stats":{"Line":3}},{"line":58,"address":[208284],"length":1,"stats":{"Line":3}},{"line":70,"address":[207264,207767],"length":1,"stats":{"Line":1}},{"line":71,"address":[207387,207299],"length":1,"stats":{"Line":2}},{"line":72,"address":[207489,207565],"length":1,"stats":{"Line":0}},{"line":74,"address":[207460],"length":1,"stats":{"Line":1}},{"line":75,"address":[207506],"length":1,"stats":{"Line":1}},{"line":87,"address":[207792,208227],"length":1,"stats":{"Line":2}},{"line":88,"address":[207858,207926],"length":1,"stats":{"Line":4}},{"line":89,"address":[208092],"length":1,"stats":{"Line":0}},{"line":91,"address":[207999],"length":1,"stats":{"Line":2}},{"line":92,"address":[208173],"length":1,"stats":{"Line":2}},{"line":97,"address":[207216],"length":1,"stats":{"Line":2}},{"line":98,"address":[207234],"length":1,"stats":{"Line":2}},{"line":99,"address":[207237],"length":1,"stats":{"Line":2}},{"line":104,"address":[208304],"length":1,"stats":{"Line":2}},{"line":105,"address":[208322],"length":1,"stats":{"Line":2}},{"line":106,"address":[208325],"length":1,"stats":{"Line":2}},{"line":111,"address":[212868,212874,212592],"length":1,"stats":{"Line":4}},{"line":114,"address":[212614],"length":1,"stats":{"Line":4}},{"line":115,"address":[212624],"length":1,"stats":{"Line":4}},{"line":116,"address":[212670],"length":1,"stats":{"Line":4}},{"line":117,"address":[212708],"length":1,"stats":{"Line":4}},{"line":126,"address":[670082,669008],"length":1,"stats":{"Line":3}},{"line":127,"address":[669030],"length":1,"stats":{"Line":3}},{"line":128,"address":[669089],"length":1,"stats":{"Line":0}},{"line":131,"address":[669777],"length":1,"stats":{"Line":5}},{"line":132,"address":[669950,669264,669150],"length":1,"stats":{"Line":6}},{"line":133,"address":[669418,669945],"length":1,"stats":{"Line":3}},{"line":134,"address":[669675],"length":1,"stats":{"Line":5}},{"line":135,"address":[669719],"length":1,"stats":{"Line":3}},{"line":136,"address":[669763],"length":1,"stats":{"Line":5}},{"line":137,"address":[669770],"length":1,"stats":{"Line":5}},{"line":147,"address":[210368],"length":1,"stats":{"Line":3}},{"line":148,"address":[210384],"length":1,"stats":{"Line":3}},{"line":151,"address":[210432,210914],"length":1,"stats":{"Line":1}},{"line":152,"address":[210462,210593],"length":1,"stats":{"Line":7}},{"line":153,"address":[210782],"length":1,"stats":{"Line":6}},{"line":156,"address":[209170,208688],"length":1,"stats":{"Line":3}},{"line":157,"address":[208718,208849],"length":1,"stats":{"Line":12}},{"line":158,"address":[209038],"length":1,"stats":{"Line":6}},{"line":161,"address":[426970,426480],"length":1,"stats":{"Line":2}},{"line":162,"address":[426649,426518],"length":1,"stats":{"Line":4}},{"line":163,"address":[426838],"length":1,"stats":{"Line":2}},{"line":166,"address":[208480,208653,208675],"length":1,"stats":{"Line":2}},{"line":167,"address":[208511,208601],"length":1,"stats":{"Line":4}},{"line":168,"address":[208630],"length":1,"stats":{"Line":2}},{"line":171,"address":[209248,209734],"length":1,"stats":{"Line":2}},{"line":172,"address":[209279,209413],"length":1,"stats":{"Line":4}},{"line":173,"address":[209602],"length":1,"stats":{"Line":2}},{"line":176,"address":[210294,209808],"length":1,"stats":{"Line":2}},{"line":177,"address":[209839,209973],"length":1,"stats":{"Line":4}},{"line":178,"address":[210162],"length":1,"stats":{"Line":2}}],"covered":51,"coverable":54},{"path":["/","home","lucac","github","mermaid-builder","src","diagrams","flowchart","flowchart_edge.rs"],"content":"//! Submodule defining an edge which may be used in a flowchart diagram\n//! in Mermaid syntax.\n\nuse std::{fmt::Display, rc::Rc};\n\nuse crate::{\n    diagrams::flowchart::{curve_styles::CurveStyle, flowchart_node::FlowchartNode},\n    shared::{\n        ArrowShape, EDGE_LETTER, GenericEdge, LineStyle, NODE_LETTER, StyleClass, StyleProperty,\n    },\n    traits::{Edge, node::Node},\n};\n\npub mod builder;\npub use builder::FlowchartEdgeBuilder;\n\n#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// Represents an edge in a flowchart diagram, connecting two nodes with various\n/// properties such as styles, classes, and curve styles.\n///\n/// # Examples\n///\n/// ```\n/// use std::rc::Rc;\n///\n/// use mermaid_builder::{\n///     diagrams::flowchart::{FlowchartEdgeBuilder, FlowchartNodeBuilder},\n///     traits::{EdgeBuilder, NodeBuilder},\n/// };\n///\n/// fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n///     let node1 = Rc::new(FlowchartNodeBuilder::default().label(\"A\")?.id(1).build()?);\n///     let node2 = Rc::new(FlowchartNodeBuilder::default().label(\"B\")?.id(2).build()?);\n///\n///     let edge =\n///         FlowchartEdgeBuilder::default().source(node1)?.destination(node2)?.id(1).build()?;\n///     Ok(())\n/// }\n/// ```\npub struct FlowchartEdge {\n    /// Unique identifier for the edge.\n    id: usize,\n    /// Underlying generic edge.\n    edge: GenericEdge\u003cFlowchartNode\u003e,\n    /// Classes associated with the edge, used for styling.\n    style_classes: Vec\u003cRc\u003cStyleClass\u003e\u003e,\n    /// Styling properties for the edge, such as color and font.\n    style_properties: Vec\u003cStyleProperty\u003e,\n    /// The curve style of the edge.\n    curve_style: CurveStyle,\n    /// The number of segments composing the link style.\n    length: u8,\n}\n\nimpl Edge for FlowchartEdge {\n    type Builder = FlowchartEdgeBuilder;\n    type Node = FlowchartNode;\n\n    fn label(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n        self.edge.label()\n    }\n\n    fn source(\u0026self) -\u003e \u0026Rc\u003cSelf::Node\u003e {\n        self.edge.source()\n    }\n\n    fn destination(\u0026self) -\u003e \u0026Rc\u003cSelf::Node\u003e {\n        self.edge.destination()\n    }\n\n    fn classes(\u0026self) -\u003e impl Iterator\u003cItem = \u0026StyleClass\u003e {\n        self.style_classes.iter().map(AsRef::as_ref)\n    }\n\n    fn line_style(\u0026self) -\u003e LineStyle {\n        self.edge.line_style()\n    }\n\n    fn left_arrow_shape(\u0026self) -\u003e Option\u003cArrowShape\u003e {\n        self.edge.left_arrow_shape()\n    }\n\n    fn right_arrow_shape(\u0026self) -\u003e Option\u003cArrowShape\u003e {\n        self.edge.right_arrow_shape()\n    }\n}\n\nimpl Display for FlowchartEdge {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        use crate::traits::TabbedDisplay;\n        self.fmt_tabbed(f, 0)\n    }\n}\n\nimpl crate::traits::TabbedDisplay for FlowchartEdge {\n    fn fmt_tabbed(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e, tab_count: usize) -\u003e std::fmt::Result {\n        let indent = \" \".repeat(tab_count * 2);\n        let segment = match self.line_style() {\n            LineStyle::Solid =\u003e \"-\".repeat(2 + self.length as usize),\n            LineStyle::Thick =\u003e \"=\".repeat(2 + self.length as usize),\n            LineStyle::Dashed =\u003e format!(\"-{}-\", \".\".repeat(self.length as usize)),\n        };\n\n        let edge_prefix = if self.curve_style != CurveStyle::default()\n            || !self.style_classes.is_empty()\n            || !self.style_properties.is_empty()\n        {\n            format!(\"{EDGE_LETTER}{}@\", self.id)\n        } else {\n            String::default()\n        };\n\n        writeln!(\n            f,\n            \"{indent}{NODE_LETTER}{} {edge_prefix}{left_arrow}{segment}{right_arrow}{} {NODE_LETTER}{}\",\n            self.source().id(),\n            self.label().map_or_else(String::new, |label| format!(\"|\\\"`{label}`\\\"|\")),\n            self.destination().id(),\n            left_arrow = self.left_arrow_shape().as_ref().map_or_else(|| \"\", |shape| shape.left()),\n            right_arrow =\n                self.right_arrow_shape().as_ref().map_or_else(|| \"\", |shape| shape.right()),\n        )?;\n\n        if self.curve_style != CurveStyle::default() {\n            writeln!(f, \"{indent}{EDGE_LETTER}{}@{{curve: {}}}\", self.id, self.curve_style)?;\n        }\n\n        for class in \u0026self.style_classes {\n            writeln!(f, \"{indent}class {EDGE_LETTER}{} {}\", self.id, class.name())?;\n        }\n\n        if !self.style_properties.is_empty() {\n            write!(f, \"{indent}linkStyle {EDGE_LETTER}{} \", self.id)?;\n            for (style_number, style) in self.style_properties.iter().enumerate() {\n                if style_number \u003e 0 {\n                    write!(f, \", \")?;\n                }\n                write!(f, \"{style} \")?;\n            }\n            writeln!(f)?;\n        }\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::{\n        diagrams::flowchart::flowchart_node::FlowchartNodeBuilder,\n        shared::{StyleClassBuilder, style_class::Color},\n        traits::{EdgeBuilder, NodeBuilder},\n    };\n\n    #[test]\n    fn test_flowchart_edge_display() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n        let node1 = Rc::new(FlowchartNodeBuilder::default().label(\"A\")?.id(0).build()?);\n        let node2 = Rc::new(FlowchartNodeBuilder::default().label(\"B\")?.id(1).build()?);\n        let style_class = Rc::new(\n            StyleClassBuilder::default()\n                .name(\"myStyle\")?\n                .property(StyleProperty::Stroke(Color::from((255, 0, 0))))?\n                .build()?,\n        );\n\n        let edge = FlowchartEdgeBuilder::default()\n            .id(1)\n            .source(node1.clone())?\n            .destination(node2.clone())?\n            .label(\"Edge Label\")?\n            .line_style(LineStyle::Dashed)\n            .left_arrow_shape(ArrowShape::Circle)?\n            .right_arrow_shape(ArrowShape::X)?\n            .curve_style(CurveStyle::StepAfter)\n            .length(2)\n            .style_class(style_class.clone())?\n            .style_property(StyleProperty::Stroke(Color::from((255, 0, 0))))?\n            .build()?;\n\n        let output = format!(\"{}\", edge);\n        assert!(output.contains(\"v0 e1@o-..-x|\\\"`Edge Label`\\\"| v1\"));\n        assert!(output.contains(\"e1@{curve: stepAfter}\"));\n        assert!(output.contains(\"class e1 myStyle\"));\n        assert!(output.contains(\"linkStyle e1 stroke: #ff0000\"));\n\n        Ok(())\n    }\n\n    #[test]\n    fn test_flowchart_edge_traits() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n        let node1 = Rc::new(FlowchartNodeBuilder::default().label(\"A\")?.id(0).build()?);\n        let node2 = Rc::new(FlowchartNodeBuilder::default().label(\"B\")?.id(1).build()?);\n        let style_class = Rc::new(\n            StyleClassBuilder::default()\n                .name(\"myStyle\")?\n                .property(StyleProperty::Stroke(Color::from((255, 0, 0))))?\n                .build()?,\n        );\n\n        let edge = FlowchartEdgeBuilder::default()\n            .id(1)\n            .source(node1.clone())?\n            .destination(node2.clone())?\n            .style_class(style_class.clone())?\n            .build()?;\n\n        assert_eq!(edge.classes().count(), 1);\n        assert_eq!(edge.classes().next().unwrap().name(), \"myStyle\");\n        Ok(())\n    }\n}\n","traces":[{"line":60,"address":[664016],"length":1,"stats":{"Line":1}},{"line":61,"address":[664021],"length":1,"stats":{"Line":1}},{"line":64,"address":[664032],"length":1,"stats":{"Line":4}},{"line":65,"address":[664037],"length":1,"stats":{"Line":3}},{"line":68,"address":[663968],"length":1,"stats":{"Line":3}},{"line":69,"address":[663973],"length":1,"stats":{"Line":3}},{"line":72,"address":[664048],"length":1,"stats":{"Line":1}},{"line":73,"address":[664053],"length":1,"stats":{"Line":1}},{"line":76,"address":[663952],"length":1,"stats":{"Line":1}},{"line":77,"address":[663957],"length":1,"stats":{"Line":2}},{"line":80,"address":[663984],"length":1,"stats":{"Line":1}},{"line":81,"address":[663989],"length":1,"stats":{"Line":1}},{"line":84,"address":[664000],"length":1,"stats":{"Line":1}},{"line":85,"address":[664005],"length":1,"stats":{"Line":1}},{"line":90,"address":[671792],"length":1,"stats":{"Line":1}},{"line":92,"address":[671806],"length":1,"stats":{"Line":1}},{"line":97,"address":[668987,664160,668981],"length":1,"stats":{"Line":1}},{"line":98,"address":[664286,664210],"length":1,"stats":{"Line":1}},{"line":99,"address":[664272,664350],"length":1,"stats":{"Line":2}},{"line":100,"address":[664395,664510],"length":1,"stats":{"Line":0}},{"line":101,"address":[664604,664427],"length":1,"stats":{"Line":0}},{"line":102,"address":[664659,664466],"length":1,"stats":{"Line":2}},{"line":105,"address":[664567,664929],"length":1,"stats":{"Line":2}},{"line":106,"address":[664979,665062],"length":1,"stats":{"Line":0}},{"line":107,"address":[665076],"length":1,"stats":{"Line":0}},{"line":109,"address":[665158,665001],"length":1,"stats":{"Line":2}},{"line":111,"address":[665115],"length":1,"stats":{"Line":0}},{"line":114,"address":[668912,665859],"length":1,"stats":{"Line":1}},{"line":117,"address":[665362,665132],"length":1,"stats":{"Line":2}},{"line":118,"address":[539552,539575],"length":1,"stats":{"Line":3}},{"line":119,"address":[665486,665553],"length":1,"stats":{"Line":2}},{"line":120,"address":[539680,539689,539769,539760],"length":1,"stats":{"Line":3}},{"line":122,"address":[539712,539737,539721,539728],"length":1,"stats":{"Line":3}},{"line":125,"address":[666555],"length":1,"stats":{"Line":1}},{"line":126,"address":[666680,668891],"length":1,"stats":{"Line":1}},{"line":129,"address":[666646,667073],"length":1,"stats":{"Line":2}},{"line":130,"address":[667183,668467],"length":1,"stats":{"Line":2}},{"line":133,"address":[667221],"length":1,"stats":{"Line":1}},{"line":134,"address":[668395,667260,667360],"length":1,"stats":{"Line":2}},{"line":135,"address":[667617],"length":1,"stats":{"Line":1}},{"line":136,"address":[667899],"length":1,"stats":{"Line":1}},{"line":137,"address":[668098,668374],"length":1,"stats":{"Line":0}},{"line":139,"address":[668075,668215],"length":1,"stats":{"Line":2}},{"line":141,"address":[667914],"length":1,"stats":{"Line":1}},{"line":143,"address":[667330],"length":1,"stats":{"Line":1}}],"covered":39,"coverable":45},{"path":["/","home","lucac","github","mermaid-builder","src","diagrams","flowchart","flowchart_node","builder.rs"],"content":"//! Submodule defining a builder struct to construct flowchart nodes in the\n//! flowchart Mermaid diagrams.\n\nuse std::rc::Rc;\n\nuse crate::{\n    diagrams::flowchart::flowchart_node::{ClickEvent, FlowchartNode, shape::FlowchartNodeShape},\n    errors::NodeError,\n    shared::{\n        StyleClass, StyleClassError, generic_configuration::Direction,\n        generic_node::GenericNodeBuilder,\n    },\n    traits::{Node, NodeBuilder},\n};\n\n#[derive(Default, Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// Builder for creating a `FlowchartNode`.\n///\n/// # Example\n///\n/// ```\n/// use mermaid_builder::prelude::*;\n///\n/// let node = FlowchartNodeBuilder::default()\n///     .label(\"My Node\")\n///     .unwrap()\n///     .shape(FlowchartNodeShape::Circle)\n///     .id(0)\n///     .build()\n///     .unwrap();\n/// ```\npub struct FlowchartNodeBuilder {\n    /// Shared attributes builder for the node.\n    builder: GenericNodeBuilder,\n    /// The click event associated with the node, if any.\n    click_event: Option\u003cClickEvent\u003e,\n    /// The shape of the flowchart node.\n    shape: FlowchartNodeShape,\n    /// Possible subnodes of the flowchart node.\n    subnodes: Vec\u003cRc\u003cFlowchartNode\u003e\u003e,\n    /// The direction of the subgraph, if applicable.\n    direction: Option\u003cDirection\u003e,\n}\n\nimpl FlowchartNodeBuilder {\n    #[must_use]\n    /// Sets the click event for the flowchart node.\n    pub fn click_event(mut self, click_event: ClickEvent) -\u003e Self {\n        self.click_event = Some(click_event);\n        self\n    }\n\n    #[must_use]\n    /// Sets the shape of the flowchart node.\n    pub fn shape(mut self, shape: FlowchartNodeShape) -\u003e Self {\n        self.shape = shape;\n        self\n    }\n\n    /// Adds a subnode to the flowchart node.\n    ///\n    /// # Arguments\n    ///\n    /// * `subnode`: The subnode to be added, wrapped in a `Rc` for shared\n    ///   ownership.\n    ///\n    /// # Errors\n    ///\n    /// * If the subnode is already present in the list, an error is returned.\n    pub fn subnode(mut self, subnode: Rc\u003cFlowchartNode\u003e) -\u003e Result\u003cSelf, NodeError\u003e {\n        if self.subnodes.contains(\u0026subnode) {\n            return Err(NodeError::DuplicateNode(subnode.label().to_owned()));\n        }\n\n        self.subnodes.push(subnode);\n        Ok(self)\n    }\n\n    #[must_use]\n    /// Returns whether the current node builder is a subgraph node.\n    pub fn is_subgraph(\u0026self) -\u003e bool {\n        !self.subnodes.is_empty()\n    }\n\n    #[must_use]\n    /// Sets the direction of the subgraph for the flowchart node.\n    ///\n    /// # Arguments\n    ///\n    /// * `direction`: The direction of the subgraph.\n    pub fn direction(mut self, direction: Direction) -\u003e Self {\n        self.direction = Some(direction);\n        self\n    }\n\n    #[must_use]\n    /// Returns the direction of the subgraph, if set.\n    pub fn get_direction(\u0026self) -\u003e Option\u003cDirection\u003e {\n        self.direction\n    }\n\n    #[must_use]\n    /// Resets the direction of the subgraph for the flowchart node.\n    pub fn reset_direction(mut self) -\u003e Self {\n        self.direction = None;\n        self\n    }\n}\n\nimpl TryFrom\u003cFlowchartNodeBuilder\u003e for FlowchartNode {\n    type Error = NodeError;\n\n    fn try_from(mut builder: FlowchartNodeBuilder) -\u003e Result\u003cSelf, Self::Error\u003e {\n        if builder.direction.is_some() \u0026\u0026 builder.subnodes.is_empty() {\n            return Err(NodeError::MissingSubnodes);\n        }\n\n        builder.subnodes.sort_unstable();\n\n        Ok(FlowchartNode {\n            node: builder.builder.try_into()?,\n            click_event: builder.click_event,\n            shape: builder.shape,\n            subnodes: builder.subnodes,\n            direction: builder.direction,\n        })\n    }\n}\n\nimpl NodeBuilder for FlowchartNodeBuilder {\n    type Node = FlowchartNode;\n    type Error = NodeError;\n\n    fn build(self) -\u003e Result\u003cSelf::Node, Self::Error\u003e {\n        self.try_into()\n    }\n\n    fn id(mut self, id: u64) -\u003e Self {\n        self.builder = self.builder.id(id);\n        self\n    }\n\n    fn get_id(\u0026self) -\u003e Option\u003cu64\u003e {\n        self.builder.get_id()\n    }\n\n    fn label\u003cS: ToString\u003e(mut self, label: S) -\u003e Result\u003cSelf, Self::Error\u003e {\n        self.builder = self.builder.label(label)?;\n        Ok(self)\n    }\n\n    fn get_label(\u0026self) -\u003e Option\u003c\u0026String\u003e {\n        self.builder.get_label()\n    }\n\n    fn style_class(mut self, style_class: Rc\u003cStyleClass\u003e) -\u003e Result\u003cSelf, StyleClassError\u003e {\n        self.builder = self.builder.style_class(style_class)?;\n        Ok(self)\n    }\n\n    fn style_property(\n        mut self,\n        property: crate::shared::StyleProperty,\n    ) -\u003e Result\u003cSelf, StyleClassError\u003e {\n        self.builder = self.builder.style_property(property)?;\n        Ok(self)\n    }\n\n    fn style_properties(\u0026self) -\u003e impl Iterator\u003cItem = \u0026crate::prelude::StyleProperty\u003e {\n        self.builder.style_properties()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::{\n        shared::{\n            ClickEvent, StyleClassBuilder, StyleProperty,\n            click_event::Navigation,\n            style_class::Unit,\n        },\n        traits::node::Node,\n    };\n\n    #[test]\n    fn test_flowchart_node_builder() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n        let style_class = Rc::new(\n            StyleClassBuilder::default()\n                .name(\"test\")?\n                .property(StyleProperty::StrokeWidth(Unit::Pixel(2)))?\n                .build()?,\n        );\n        let subnode = Rc::new(FlowchartNodeBuilder::default().label(\"Sub\")?.id(2).build()?);\n\n        let node = FlowchartNodeBuilder::default()\n            .id(1)\n            .label(\"My Node\")?\n            .shape(FlowchartNodeShape::Circle)\n            .click_event(ClickEvent::Navigation(Navigation::new(\"https://example.com\")))\n            .subnode(subnode.clone())?\n            .direction(Direction::TopToBottom)\n            .style_class(style_class.clone())?\n            .style_property(StyleProperty::StrokeWidth(Unit::Pixel(2)))?\n            .build()?;\n\n        assert_eq!(node.id(), 1);\n        assert_eq!(node.label(), \"My Node\");\n        assert_eq!(node.shape, FlowchartNodeShape::Circle);\n        assert!(matches!(node.click_event, Some(ClickEvent::Navigation { .. })));\n        assert_eq!(node.subnodes.len(), 1);\n        assert_eq!(node.direction, Some(Direction::TopToBottom));\n        assert_eq!(node.classes().count(), 1);\n        assert_eq!(node.styles().count(), 1);\n        Ok(())\n    }\n\n    #[test]\n    fn test_flowchart_node_builder_subgraph_methods() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n        let mut builder = FlowchartNodeBuilder::default();\n        assert!(!builder.is_subgraph());\n\n        let subnode = Rc::new(FlowchartNodeBuilder::default().label(\"Sub\")?.id(2).build()?);\n        builder = builder.subnode(subnode)?;\n        assert!(builder.is_subgraph());\n\n        builder = builder.direction(Direction::LeftToRight);\n        assert_eq!(builder.get_direction(), Some(Direction::LeftToRight));\n\n        builder = builder.reset_direction();\n        assert_eq!(builder.get_direction(), None);\n\n        Ok(())\n    }\n}\n","traces":[{"line":49,"address":[611496,611296],"length":1,"stats":{"Line":1}},{"line":50,"address":[611323,611447],"length":1,"stats":{"Line":2}},{"line":51,"address":[611476],"length":1,"stats":{"Line":1}},{"line":56,"address":[611600],"length":1,"stats":{"Line":2}},{"line":57,"address":[611618],"length":1,"stats":{"Line":2}},{"line":58,"address":[611624],"length":1,"stats":{"Line":2}},{"line":71,"address":[611648,612081],"length":1,"stats":{"Line":2}},{"line":72,"address":[611776,611683],"length":1,"stats":{"Line":4}},{"line":73,"address":[611907,611831],"length":1,"stats":{"Line":0}},{"line":76,"address":[611802],"length":1,"stats":{"Line":2}},{"line":77,"address":[611848],"length":1,"stats":{"Line":2}},{"line":82,"address":[611520],"length":1,"stats":{"Line":1}},{"line":83,"address":[611525],"length":1,"stats":{"Line":1}},{"line":92,"address":[612112],"length":1,"stats":{"Line":2}},{"line":93,"address":[612130],"length":1,"stats":{"Line":3}},{"line":94,"address":[612136],"length":1,"stats":{"Line":3}},{"line":99,"address":[611552],"length":1,"stats":{"Line":1}},{"line":100,"address":[611557],"length":1,"stats":{"Line":1}},{"line":105,"address":[611568],"length":1,"stats":{"Line":1}},{"line":106,"address":[611576],"length":1,"stats":{"Line":1}},{"line":107,"address":[611583],"length":1,"stats":{"Line":1}},{"line":114,"address":[781632,782599],"length":1,"stats":{"Line":10}},{"line":115,"address":[781662,781773,781810],"length":1,"stats":{"Line":19}},{"line":116,"address":[781840],"length":1,"stats":{"Line":0}},{"line":119,"address":[781784,781913],"length":1,"stats":{"Line":17}},{"line":121,"address":[782311],"length":1,"stats":{"Line":13}},{"line":122,"address":[782464,781925],"length":1,"stats":{"Line":12}},{"line":123,"address":[782212],"length":1,"stats":{"Line":13}},{"line":124,"address":[782247],"length":1,"stats":{"Line":13}},{"line":125,"address":[782257],"length":1,"stats":{"Line":13}},{"line":126,"address":[782301],"length":1,"stats":{"Line":13}},{"line":135,"address":[613808],"length":1,"stats":{"Line":7}},{"line":136,"address":[613825],"length":1,"stats":{"Line":7}},{"line":139,"address":[613770,613568,613791],"length":1,"stats":{"Line":4}},{"line":140,"address":[613597,613723],"length":1,"stats":{"Line":17}},{"line":141,"address":[613747],"length":1,"stats":{"Line":5}},{"line":144,"address":[613872],"length":1,"stats":{"Line":1}},{"line":145,"address":[613877],"length":1,"stats":{"Line":1}},{"line":148,"address":[530032,530544],"length":1,"stats":{"Line":5}},{"line":149,"address":[530236,530070],"length":1,"stats":{"Line":10}},{"line":150,"address":[530412],"length":1,"stats":{"Line":5}},{"line":153,"address":[613888],"length":1,"stats":{"Line":0}},{"line":154,"address":[613893],"length":1,"stats":{"Line":0}},{"line":157,"address":[612224,612757],"length":1,"stats":{"Line":1}},{"line":158,"address":[612420,612254],"length":1,"stats":{"Line":3}},{"line":159,"address":[612625],"length":1,"stats":{"Line":2}},{"line":162,"address":[613476,612832],"length":1,"stats":{"Line":1}},{"line":166,"address":[613139,612890],"length":1,"stats":{"Line":2}},{"line":167,"address":[613344],"length":1,"stats":{"Line":1}},{"line":170,"address":[613552],"length":1,"stats":{"Line":0}},{"line":171,"address":[613557],"length":1,"stats":{"Line":0}}],"covered":45,"coverable":51},{"path":["/","home","lucac","github","mermaid-builder","src","diagrams","flowchart","flowchart_node","shape.rs"],"content":"//! Submodule defining the possible shapes for nodes in Mermaid diagrams.\nuse std::{fmt::Display, str::FromStr};\n\n#[derive(Default, Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// `FlowchartNodeShape` represents all supported node shapes for Mermaid\n/// diagrams.\npub enum FlowchartNodeShape {\n    /// Standard process shape\n    #[default]\n    Rectangle,\n    /// Represents an event\n    RoundEdges,\n    /// Terminal point\n    StadiumShape,\n    /// Subprocess\n    Subprocess,\n    /// Database storage\n    Cylinder,\n    /// Starting point\n    Circle,\n    /// Odd shape\n    Odd,\n    /// Decision-making step\n    Diamond,\n    /// Preparation or condition step\n    Hexagon,\n    /// Represents input or output (Lean right parallelogram)\n    LRParallelogram,\n    /// Represents output or input (Lean left parallelogram)\n    LLParallelogram,\n    /// Priority action (Base bottom trapezoid)\n    Trapezoid,\n    /// Manual task (Base top trapezoid)\n    ReverseTrapezoid,\n    /// Represents a stop point\n    DoubleCircle,\n    /// Represents a card\n    NotchedRectangle,\n    /// Lined/Shaded process shape\n    Linedrectangle,\n    /// Small starting point\n    SmallCircle,\n    /// Stop point\n    FramedCircle,\n    /// Fork or join in process flow\n    LongRectangle,\n    /// Represents a collate operation\n    Hourglass,\n    /// Adds a comment (Left curly brace)\n    LeftCurlyBrace,\n    /// Adds a comment (Right curly brace)\n    RightCurlyBrace,\n    /// Adds a comment (Braces on both sides)\n    CurlyBraces,\n    /// Communication link\n    LightningBolt,\n    /// Represents a document\n    Document,\n    /// Represents a delay\n    HalfRoundedRectangle,\n    /// Direct access storage\n    HorizontalCylinder,\n    /// Disk storage\n    LinedCylinder,\n    /// Represents a display\n    CurvedTrapezoid,\n    /// Divided process shape\n    DividedRectangle,\n    /// Extraction process\n    SmallTriangle,\n    /// Internal storage\n    WindowPane,\n    /// Junction point\n    FilledCircle,\n    /// Lined document\n    LinedDocument,\n    /// Loop limit step\n    NotchedPentagon,\n    /// Manual file operation\n    FlippedTriangle,\n    /// Manual input step\n    SlopedRectangle,\n    /// Multiple documents\n    StackedDocument,\n    /// Multiple processes\n    StackedRectangle,\n    /// Paper tape\n    Flag,\n    /// Stored data\n    BowTieRectangle,\n    /// Summary\n    CrossedCircle,\n    /// Tagged document\n    TaggedDocument,\n    /// Tagged process\n    TaggedRectangle,\n    /// Subprocess (framed rectangle)\n    FramedRectangle,\n    /// Text block\n    TextBlock,\n}\n\nimpl Display for FlowchartNodeShape {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::Rectangle =\u003e write!(f, \"rect\"),\n            Self::RoundEdges =\u003e write!(f, \"rounded\"),\n            Self::StadiumShape =\u003e write!(f, \"stadium\"),\n            Self::Subprocess =\u003e write!(f, \"subproc\"),\n            Self::Cylinder =\u003e write!(f, \"cyl\"),\n            Self::Circle =\u003e write!(f, \"circle\"),\n            Self::Odd =\u003e write!(f, \"odd\"),\n            Self::Diamond =\u003e write!(f, \"diamond\"),\n            Self::Hexagon =\u003e write!(f, \"hex\"),\n            Self::LRParallelogram =\u003e write!(f, \"lean-r\"),\n            Self::LLParallelogram =\u003e write!(f, \"lean-l\"),\n            Self::Trapezoid =\u003e write!(f, \"trap-b\"),\n            Self::ReverseTrapezoid =\u003e write!(f, \"trap-t\"),\n            Self::DoubleCircle =\u003e write!(f, \"dbl-circ\"),\n            Self::NotchedRectangle =\u003e write!(f, \"notch-rect\"),\n            Self::Linedrectangle =\u003e write!(f, \"lin-rect\"),\n            Self::SmallCircle =\u003e write!(f, \"sm-circ\"),\n            Self::FramedCircle =\u003e write!(f, \"framed-circle\"),\n            Self::LongRectangle =\u003e write!(f, \"fork\"),\n            Self::Hourglass =\u003e write!(f, \"hourglass\"),\n            Self::LeftCurlyBrace =\u003e write!(f, \"comment\"),\n            Self::RightCurlyBrace =\u003e write!(f, \"brace-r\"),\n            Self::CurlyBraces =\u003e write!(f, \"braces\"),\n            Self::LightningBolt =\u003e write!(f, \"bolt\"),\n            Self::Document =\u003e write!(f, \"doc\"),\n            Self::HalfRoundedRectangle =\u003e write!(f, \"delay\"),\n            Self::HorizontalCylinder =\u003e write!(f, \"das\"),\n            Self::LinedCylinder =\u003e write!(f, \"lin-cyl\"),\n            Self::CurvedTrapezoid =\u003e write!(f, \"curv-trap\"),\n            Self::DividedRectangle =\u003e write!(f, \"div-rect\"),\n            Self::SmallTriangle =\u003e write!(f, \"tri\"),\n            Self::WindowPane =\u003e write!(f, \"win-pane\"),\n            Self::FilledCircle =\u003e write!(f, \"f-circ\"),\n            Self::LinedDocument =\u003e write!(f, \"lin-doc\"),\n            Self::NotchedPentagon =\u003e write!(f, \"notch-pent\"),\n            Self::FlippedTriangle =\u003e write!(f, \"flip-tri\"),\n            Self::SlopedRectangle =\u003e write!(f, \"sl-rect\"),\n            Self::StackedDocument =\u003e write!(f, \"docs\"),\n            Self::StackedRectangle =\u003e write!(f, \"processes\"),\n            Self::Flag =\u003e write!(f, \"flag\"),\n            Self::BowTieRectangle =\u003e write!(f, \"bow-rect\"),\n            Self::CrossedCircle =\u003e write!(f, \"cross-circ\"),\n            Self::TaggedDocument =\u003e write!(f, \"tag-doc\"),\n            Self::TaggedRectangle =\u003e write!(f, \"tag-rect\"),\n            Self::FramedRectangle =\u003e write!(f, \"fr-rect\"),\n            Self::TextBlock =\u003e write!(f, \"text\"),\n        }\n    }\n}\n\nimpl FromStr for FlowchartNodeShape {\n    type Err = ();\n    fn from_str(s: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        match s.to_ascii_lowercase().as_str() {\n            // Rectangle\n            \"rect\" | \"rectangle\" | \"proc\" | \"process\" =\u003e Ok(Self::Rectangle),\n            // Rounded Rectangle\n            \"rounded\" | \"event\" =\u003e Ok(Self::RoundEdges),\n            // Stadium\n            \"stadium\" | \"pill\" | \"terminal\" =\u003e Ok(Self::StadiumShape),\n            // Subprocess\n            \"subproc\" | \"subprocess\" | \"subroutine\" | \"framed-rectangle\" =\u003e Ok(Self::Subprocess),\n            // Cylinder\n            \"cyl\" | \"cylinder\" | \"database\" | \"db\" =\u003e Ok(Self::Cylinder),\n            // Circle\n            \"circle\" | \"circ\" =\u003e Ok(Self::Circle),\n            // Odd\n            \"odd\" =\u003e Ok(Self::Odd),\n            // Diamond\n            \"diamond\" | \"diam\" | \"decision\" | \"question\" =\u003e Ok(Self::Diamond),\n            // Hexagon\n            \"hex\" | \"hexagon\" | \"prepare\" =\u003e Ok(Self::Hexagon),\n            // Lean right parallelogram\n            \"lean-r\" | \"lean-right\" | \"in-out\" =\u003e Ok(Self::LRParallelogram),\n            // Lean left parallelogram\n            \"lean-l\" | \"lean-left\" | \"out-in\" =\u003e Ok(Self::LLParallelogram),\n            // Base bottom trapezoid\n            \"trap-b\" | \"trapezoid\" | \"priority\" | \"trapezoid-bottom\" =\u003e Ok(Self::Trapezoid),\n            // Base top trapezoid\n            \"trap-t\" | \"inv-trapezoid\" | \"manual\" | \"trapezoid-top\" =\u003e Ok(Self::ReverseTrapezoid),\n            // Double Circle\n            \"dbl-circ\" | \"double-circle\" | \"stop\" =\u003e Ok(Self::DoubleCircle),\n            // Notched Rectangle\n            \"notch-rect\" | \"card\" | \"notched-rectangle\" =\u003e Ok(Self::NotchedRectangle),\n            // Lined Rectangle\n            \"lin-rect\" | \"lin-proc\" | \"lined-process\" | \"lined-rectangle\" | \"shaded-process\" =\u003e {\n                Ok(Self::Linedrectangle)\n            }\n            // Small Circle\n            \"sm-circ\" | \"small-circle\" | \"start\" =\u003e Ok(Self::SmallCircle),\n            // Framed Circle\n            \"framed-circle\" | \"fr-circ\" =\u003e Ok(Self::FramedCircle),\n            // Long Rectangle\n            \"fork\" | \"join\" =\u003e Ok(Self::LongRectangle),\n            // Hourglass\n            \"hourglass\" | \"collate\" =\u003e Ok(Self::Hourglass),\n            // Left Curly Brace\n            \"comment\" | \"brace-l\" =\u003e Ok(Self::LeftCurlyBrace),\n            // Right Curly Brace\n            \"brace-r\" =\u003e Ok(Self::RightCurlyBrace),\n            // Curly Braces\n            \"braces\" =\u003e Ok(Self::CurlyBraces),\n            // Lightning Bolt\n            \"bolt\" | \"com-link\" | \"lightning-bolt\" =\u003e Ok(Self::LightningBolt),\n            // Document\n            \"doc\" | \"document\" =\u003e Ok(Self::Document),\n            // Half-Rounded Rectangle\n            \"delay\" | \"half-rounded-rectangle\" =\u003e Ok(Self::HalfRoundedRectangle),\n            // Horizontal Cylinder\n            \"das\" | \"h-cyl\" | \"horizontal-cylinder\" =\u003e Ok(Self::HorizontalCylinder),\n            // Lined Cylinder\n            \"lin-cyl\" | \"disk\" | \"lined-cylinder\" =\u003e Ok(Self::LinedCylinder),\n            // Curved Trapezoid\n            \"curv-trap\" | \"curved-trapezoid\" | \"display\" =\u003e Ok(Self::CurvedTrapezoid),\n            // Divided Rectangle\n            \"div-rect\" | \"div-proc\" | \"divided-process\" | \"divided-rectangle\" =\u003e {\n                Ok(Self::DividedRectangle)\n            }\n            // Small Triangle\n            \"tri\" | \"extract\" | \"triangle\" =\u003e Ok(Self::SmallTriangle),\n            // Window Pane\n            \"win-pane\" | \"internal-storage\" | \"window-pane\" =\u003e Ok(Self::WindowPane),\n            // Filled Circle\n            \"f-circ\" | \"filled-circle\" | \"junction\" =\u003e Ok(Self::FilledCircle),\n            // Lined Document\n            \"lin-doc\" | \"lined-document\" =\u003e Ok(Self::LinedDocument),\n            // Notched Pentagon\n            \"notch-pent\" | \"loop-limit\" | \"notched-pentagon\" =\u003e Ok(Self::NotchedPentagon),\n            // Flipped Triangle\n            \"flip-tri\" | \"flipped-triangle\" | \"manual-file\" =\u003e Ok(Self::FlippedTriangle),\n            // Sloped Rectangle\n            \"sl-rect\" | \"manual-input\" | \"sloped-rectangle\" =\u003e Ok(Self::SlopedRectangle),\n            // Stacked Document\n            \"docs\" | \"documents\" | \"st-doc\" | \"stacked-document\" =\u003e Ok(Self::StackedDocument),\n            // Stacked Rectangle\n            \"processes\" | \"procs\" | \"st-rect\" | \"stacked-rectangle\" =\u003e Ok(Self::StackedRectangle),\n            // Flag\n            \"flag\" | \"paper-tape\" =\u003e Ok(Self::Flag),\n            // Bow Tie Rectangle\n            \"bow-rect\" | \"bow-tie-rectangle\" | \"stored-data\" =\u003e Ok(Self::BowTieRectangle),\n            // Crossed Circle\n            \"cross-circ\" | \"crossed-circle\" | \"summary\" =\u003e Ok(Self::CrossedCircle),\n            // Tagged Document\n            \"tag-doc\" | \"tagged-document\" =\u003e Ok(Self::TaggedDocument),\n            // Tagged Rectangle\n            \"tag-rect\" | \"tag-proc\" | \"tagged-process\" | \"tagged-rectangle\" =\u003e {\n                Ok(Self::TaggedRectangle)\n            }\n            // Framed Rectangle (added for completeness)\n            \"fr-rect\" =\u003e Ok(Self::FramedRectangle),\n            // Text Block\n            \"text\" | \"text-block\" =\u003e Ok(Self::TextBlock),\n            _ =\u003e Err(()),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_flowchart_node_shape_display() {\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::Rectangle), \"rect\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::RoundEdges), \"rounded\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::StadiumShape), \"stadium\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::Subprocess), \"subproc\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::Cylinder), \"cyl\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::Circle), \"circle\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::Odd), \"odd\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::Diamond), \"diamond\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::Hexagon), \"hex\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::LRParallelogram), \"lean-r\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::LLParallelogram), \"lean-l\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::Trapezoid), \"trap-b\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::ReverseTrapezoid), \"trap-t\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::DoubleCircle), \"dbl-circ\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::NotchedRectangle), \"notch-rect\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::Linedrectangle), \"lin-rect\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::SmallCircle), \"sm-circ\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::FramedCircle), \"framed-circle\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::LongRectangle), \"fork\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::Hourglass), \"hourglass\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::LeftCurlyBrace), \"comment\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::RightCurlyBrace), \"brace-r\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::CurlyBraces), \"braces\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::LightningBolt), \"bolt\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::Document), \"doc\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::HalfRoundedRectangle), \"delay\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::HorizontalCylinder), \"das\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::LinedCylinder), \"lin-cyl\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::CurvedTrapezoid), \"curv-trap\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::DividedRectangle), \"div-rect\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::SmallTriangle), \"tri\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::WindowPane), \"win-pane\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::FilledCircle), \"f-circ\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::LinedDocument), \"lin-doc\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::NotchedPentagon), \"notch-pent\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::FlippedTriangle), \"flip-tri\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::SlopedRectangle), \"sl-rect\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::StackedDocument), \"docs\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::StackedRectangle), \"processes\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::Flag), \"flag\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::BowTieRectangle), \"bow-rect\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::CrossedCircle), \"cross-circ\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::TaggedDocument), \"tag-doc\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::TaggedRectangle), \"tag-rect\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::FramedRectangle), \"fr-rect\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::TextBlock), \"text\");\n    }\n\n    #[test]\n    #[allow(clippy::too_many_lines)]\n    fn test_flowchart_node_shape_from_str() {\n        assert_eq!(FlowchartNodeShape::from_str(\"rect\").unwrap(), FlowchartNodeShape::Rectangle);\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"rectangle\").unwrap(),\n            FlowchartNodeShape::Rectangle\n        );\n        assert_eq!(FlowchartNodeShape::from_str(\"proc\").unwrap(), FlowchartNodeShape::Rectangle);\n        assert_eq!(FlowchartNodeShape::from_str(\"process\").unwrap(), FlowchartNodeShape::Rectangle);\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"rounded\").unwrap(),\n            FlowchartNodeShape::RoundEdges\n        );\n        assert_eq!(FlowchartNodeShape::from_str(\"event\").unwrap(), FlowchartNodeShape::RoundEdges);\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"stadium\").unwrap(),\n            FlowchartNodeShape::StadiumShape\n        );\n        assert_eq!(FlowchartNodeShape::from_str(\"pill\").unwrap(), FlowchartNodeShape::StadiumShape);\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"terminal\").unwrap(),\n            FlowchartNodeShape::StadiumShape\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"subproc\").unwrap(),\n            FlowchartNodeShape::Subprocess\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"subprocess\").unwrap(),\n            FlowchartNodeShape::Subprocess\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"subroutine\").unwrap(),\n            FlowchartNodeShape::Subprocess\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"framed-rectangle\").unwrap(),\n            FlowchartNodeShape::Subprocess\n        );\n        assert_eq!(FlowchartNodeShape::from_str(\"cyl\").unwrap(), FlowchartNodeShape::Cylinder);\n        assert_eq!(FlowchartNodeShape::from_str(\"cylinder\").unwrap(), FlowchartNodeShape::Cylinder);\n        assert_eq!(FlowchartNodeShape::from_str(\"database\").unwrap(), FlowchartNodeShape::Cylinder);\n        assert_eq!(FlowchartNodeShape::from_str(\"db\").unwrap(), FlowchartNodeShape::Cylinder);\n        assert_eq!(FlowchartNodeShape::from_str(\"circle\").unwrap(), FlowchartNodeShape::Circle);\n        assert_eq!(FlowchartNodeShape::from_str(\"circ\").unwrap(), FlowchartNodeShape::Circle);\n        assert_eq!(FlowchartNodeShape::from_str(\"odd\").unwrap(), FlowchartNodeShape::Odd);\n        assert_eq!(FlowchartNodeShape::from_str(\"diamond\").unwrap(), FlowchartNodeShape::Diamond);\n        assert_eq!(FlowchartNodeShape::from_str(\"diam\").unwrap(), FlowchartNodeShape::Diamond);\n        assert_eq!(FlowchartNodeShape::from_str(\"decision\").unwrap(), FlowchartNodeShape::Diamond);\n        assert_eq!(FlowchartNodeShape::from_str(\"question\").unwrap(), FlowchartNodeShape::Diamond);\n        assert_eq!(FlowchartNodeShape::from_str(\"hex\").unwrap(), FlowchartNodeShape::Hexagon);\n        assert_eq!(FlowchartNodeShape::from_str(\"hexagon\").unwrap(), FlowchartNodeShape::Hexagon);\n        assert_eq!(FlowchartNodeShape::from_str(\"prepare\").unwrap(), FlowchartNodeShape::Hexagon);\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"lean-r\").unwrap(),\n            FlowchartNodeShape::LRParallelogram\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"lean-right\").unwrap(),\n            FlowchartNodeShape::LRParallelogram\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"in-out\").unwrap(),\n            FlowchartNodeShape::LRParallelogram\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"lean-l\").unwrap(),\n            FlowchartNodeShape::LLParallelogram\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"lean-left\").unwrap(),\n            FlowchartNodeShape::LLParallelogram\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"out-in\").unwrap(),\n            FlowchartNodeShape::LLParallelogram\n        );\n        assert_eq!(FlowchartNodeShape::from_str(\"trap-b\").unwrap(), FlowchartNodeShape::Trapezoid);\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"trapezoid\").unwrap(),\n            FlowchartNodeShape::Trapezoid\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"priority\").unwrap(),\n            FlowchartNodeShape::Trapezoid\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"trapezoid-bottom\").unwrap(),\n            FlowchartNodeShape::Trapezoid\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"trap-t\").unwrap(),\n            FlowchartNodeShape::ReverseTrapezoid\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"inv-trapezoid\").unwrap(),\n            FlowchartNodeShape::ReverseTrapezoid\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"manual\").unwrap(),\n            FlowchartNodeShape::ReverseTrapezoid\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"trapezoid-top\").unwrap(),\n            FlowchartNodeShape::ReverseTrapezoid\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"dbl-circ\").unwrap(),\n            FlowchartNodeShape::DoubleCircle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"double-circle\").unwrap(),\n            FlowchartNodeShape::DoubleCircle\n        );\n        assert_eq!(FlowchartNodeShape::from_str(\"stop\").unwrap(), FlowchartNodeShape::DoubleCircle);\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"notch-rect\").unwrap(),\n            FlowchartNodeShape::NotchedRectangle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"card\").unwrap(),\n            FlowchartNodeShape::NotchedRectangle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"notched-rectangle\").unwrap(),\n            FlowchartNodeShape::NotchedRectangle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"lin-rect\").unwrap(),\n            FlowchartNodeShape::Linedrectangle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"lin-proc\").unwrap(),\n            FlowchartNodeShape::Linedrectangle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"lined-process\").unwrap(),\n            FlowchartNodeShape::Linedrectangle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"lined-rectangle\").unwrap(),\n            FlowchartNodeShape::Linedrectangle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"shaded-process\").unwrap(),\n            FlowchartNodeShape::Linedrectangle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"sm-circ\").unwrap(),\n            FlowchartNodeShape::SmallCircle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"small-circle\").unwrap(),\n            FlowchartNodeShape::SmallCircle\n        );\n        assert_eq!(FlowchartNodeShape::from_str(\"start\").unwrap(), FlowchartNodeShape::SmallCircle);\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"framed-circle\").unwrap(),\n            FlowchartNodeShape::FramedCircle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"fr-circ\").unwrap(),\n            FlowchartNodeShape::FramedCircle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"fork\").unwrap(),\n            FlowchartNodeShape::LongRectangle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"join\").unwrap(),\n            FlowchartNodeShape::LongRectangle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"hourglass\").unwrap(),\n            FlowchartNodeShape::Hourglass\n        );\n        assert_eq!(FlowchartNodeShape::from_str(\"collate\").unwrap(), FlowchartNodeShape::Hourglass);\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"comment\").unwrap(),\n            FlowchartNodeShape::LeftCurlyBrace\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"brace-l\").unwrap(),\n            FlowchartNodeShape::LeftCurlyBrace\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"brace-r\").unwrap(),\n            FlowchartNodeShape::RightCurlyBrace\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"braces\").unwrap(),\n            FlowchartNodeShape::CurlyBraces\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"bolt\").unwrap(),\n            FlowchartNodeShape::LightningBolt\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"com-link\").unwrap(),\n            FlowchartNodeShape::LightningBolt\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"lightning-bolt\").unwrap(),\n            FlowchartNodeShape::LightningBolt\n        );\n        assert_eq!(FlowchartNodeShape::from_str(\"doc\").unwrap(), FlowchartNodeShape::Document);\n        assert_eq!(FlowchartNodeShape::from_str(\"document\").unwrap(), FlowchartNodeShape::Document);\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"delay\").unwrap(),\n            FlowchartNodeShape::HalfRoundedRectangle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"half-rounded-rectangle\").unwrap(),\n            FlowchartNodeShape::HalfRoundedRectangle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"das\").unwrap(),\n            FlowchartNodeShape::HorizontalCylinder\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"h-cyl\").unwrap(),\n            FlowchartNodeShape::HorizontalCylinder\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"horizontal-cylinder\").unwrap(),\n            FlowchartNodeShape::HorizontalCylinder\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"lin-cyl\").unwrap(),\n            FlowchartNodeShape::LinedCylinder\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"disk\").unwrap(),\n            FlowchartNodeShape::LinedCylinder\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"lined-cylinder\").unwrap(),\n            FlowchartNodeShape::LinedCylinder\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"curv-trap\").unwrap(),\n            FlowchartNodeShape::CurvedTrapezoid\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"curved-trapezoid\").unwrap(),\n            FlowchartNodeShape::CurvedTrapezoid\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"display\").unwrap(),\n            FlowchartNodeShape::CurvedTrapezoid\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"div-rect\").unwrap(),\n            FlowchartNodeShape::DividedRectangle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"div-proc\").unwrap(),\n            FlowchartNodeShape::DividedRectangle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"divided-process\").unwrap(),\n            FlowchartNodeShape::DividedRectangle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"divided-rectangle\").unwrap(),\n            FlowchartNodeShape::DividedRectangle\n        );\n        assert_eq!(FlowchartNodeShape::from_str(\"tri\").unwrap(), FlowchartNodeShape::SmallTriangle);\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"extract\").unwrap(),\n            FlowchartNodeShape::SmallTriangle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"triangle\").unwrap(),\n            FlowchartNodeShape::SmallTriangle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"win-pane\").unwrap(),\n            FlowchartNodeShape::WindowPane\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"internal-storage\").unwrap(),\n            FlowchartNodeShape::WindowPane\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"window-pane\").unwrap(),\n            FlowchartNodeShape::WindowPane\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"f-circ\").unwrap(),\n            FlowchartNodeShape::FilledCircle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"filled-circle\").unwrap(),\n            FlowchartNodeShape::FilledCircle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"junction\").unwrap(),\n            FlowchartNodeShape::FilledCircle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"lin-doc\").unwrap(),\n            FlowchartNodeShape::LinedDocument\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"lined-document\").unwrap(),\n            FlowchartNodeShape::LinedDocument\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"notch-pent\").unwrap(),\n            FlowchartNodeShape::NotchedPentagon\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"loop-limit\").unwrap(),\n            FlowchartNodeShape::NotchedPentagon\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"notched-pentagon\").unwrap(),\n            FlowchartNodeShape::NotchedPentagon\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"flip-tri\").unwrap(),\n            FlowchartNodeShape::FlippedTriangle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"flipped-triangle\").unwrap(),\n            FlowchartNodeShape::FlippedTriangle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"manual-file\").unwrap(),\n            FlowchartNodeShape::FlippedTriangle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"sl-rect\").unwrap(),\n            FlowchartNodeShape::SlopedRectangle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"manual-input\").unwrap(),\n            FlowchartNodeShape::SlopedRectangle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"sloped-rectangle\").unwrap(),\n            FlowchartNodeShape::SlopedRectangle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"docs\").unwrap(),\n            FlowchartNodeShape::StackedDocument\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"documents\").unwrap(),\n            FlowchartNodeShape::StackedDocument\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"st-doc\").unwrap(),\n            FlowchartNodeShape::StackedDocument\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"stacked-document\").unwrap(),\n            FlowchartNodeShape::StackedDocument\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"processes\").unwrap(),\n            FlowchartNodeShape::StackedRectangle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"procs\").unwrap(),\n            FlowchartNodeShape::StackedRectangle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"st-rect\").unwrap(),\n            FlowchartNodeShape::StackedRectangle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"stacked-rectangle\").unwrap(),\n            FlowchartNodeShape::StackedRectangle\n        );\n        assert_eq!(FlowchartNodeShape::from_str(\"flag\").unwrap(), FlowchartNodeShape::Flag);\n        assert_eq!(FlowchartNodeShape::from_str(\"paper-tape\").unwrap(), FlowchartNodeShape::Flag);\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"bow-rect\").unwrap(),\n            FlowchartNodeShape::BowTieRectangle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"bow-tie-rectangle\").unwrap(),\n            FlowchartNodeShape::BowTieRectangle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"stored-data\").unwrap(),\n            FlowchartNodeShape::BowTieRectangle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"cross-circ\").unwrap(),\n            FlowchartNodeShape::CrossedCircle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"crossed-circle\").unwrap(),\n            FlowchartNodeShape::CrossedCircle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"summary\").unwrap(),\n            FlowchartNodeShape::CrossedCircle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"tag-doc\").unwrap(),\n            FlowchartNodeShape::TaggedDocument\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"tagged-document\").unwrap(),\n            FlowchartNodeShape::TaggedDocument\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"tag-rect\").unwrap(),\n            FlowchartNodeShape::TaggedRectangle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"tag-proc\").unwrap(),\n            FlowchartNodeShape::TaggedRectangle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"tagged-process\").unwrap(),\n            FlowchartNodeShape::TaggedRectangle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"tagged-rectangle\").unwrap(),\n            FlowchartNodeShape::TaggedRectangle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"fr-rect\").unwrap(),\n            FlowchartNodeShape::FramedRectangle\n        );\n        assert_eq!(FlowchartNodeShape::from_str(\"text\").unwrap(), FlowchartNodeShape::TextBlock);\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"text-block\").unwrap(),\n            FlowchartNodeShape::TextBlock\n        );\n        assert!(FlowchartNodeShape::from_str(\"invalid\").is_err());\n    }\n}\n","traces":[{"line":105,"address":[500272],"length":1,"stats":{"Line":1}},{"line":106,"address":[500290],"length":1,"stats":{"Line":1}},{"line":107,"address":[500321],"length":1,"stats":{"Line":1}},{"line":108,"address":[500361],"length":1,"stats":{"Line":1}},{"line":109,"address":[500401],"length":1,"stats":{"Line":1}},{"line":110,"address":[500441],"length":1,"stats":{"Line":1}},{"line":111,"address":[500481],"length":1,"stats":{"Line":1}},{"line":112,"address":[500521],"length":1,"stats":{"Line":1}},{"line":113,"address":[500561],"length":1,"stats":{"Line":1}},{"line":114,"address":[500601],"length":1,"stats":{"Line":1}},{"line":115,"address":[500641],"length":1,"stats":{"Line":1}},{"line":116,"address":[500681],"length":1,"stats":{"Line":1}},{"line":117,"address":[500721],"length":1,"stats":{"Line":1}},{"line":118,"address":[500761],"length":1,"stats":{"Line":1}},{"line":119,"address":[500801],"length":1,"stats":{"Line":1}},{"line":120,"address":[500841],"length":1,"stats":{"Line":1}},{"line":121,"address":[500881],"length":1,"stats":{"Line":1}},{"line":122,"address":[500921],"length":1,"stats":{"Line":1}},{"line":123,"address":[500961],"length":1,"stats":{"Line":1}},{"line":124,"address":[501001],"length":1,"stats":{"Line":1}},{"line":125,"address":[501041],"length":1,"stats":{"Line":1}},{"line":126,"address":[501081],"length":1,"stats":{"Line":1}},{"line":127,"address":[501121],"length":1,"stats":{"Line":1}},{"line":128,"address":[501161],"length":1,"stats":{"Line":1}},{"line":129,"address":[501201],"length":1,"stats":{"Line":1}},{"line":130,"address":[501241],"length":1,"stats":{"Line":1}},{"line":131,"address":[501281],"length":1,"stats":{"Line":1}},{"line":132,"address":[501321],"length":1,"stats":{"Line":1}},{"line":133,"address":[501361],"length":1,"stats":{"Line":1}},{"line":134,"address":[501401],"length":1,"stats":{"Line":1}},{"line":135,"address":[501441],"length":1,"stats":{"Line":1}},{"line":136,"address":[501481],"length":1,"stats":{"Line":1}},{"line":137,"address":[501521],"length":1,"stats":{"Line":1}},{"line":138,"address":[501561],"length":1,"stats":{"Line":1}},{"line":139,"address":[501601],"length":1,"stats":{"Line":1}},{"line":140,"address":[501641],"length":1,"stats":{"Line":1}},{"line":141,"address":[501681],"length":1,"stats":{"Line":1}},{"line":142,"address":[501721],"length":1,"stats":{"Line":1}},{"line":143,"address":[501761],"length":1,"stats":{"Line":1}},{"line":144,"address":[501801],"length":1,"stats":{"Line":1}},{"line":145,"address":[501841],"length":1,"stats":{"Line":1}},{"line":146,"address":[501881],"length":1,"stats":{"Line":1}},{"line":147,"address":[501921],"length":1,"stats":{"Line":1}},{"line":148,"address":[501961],"length":1,"stats":{"Line":1}},{"line":149,"address":[502001],"length":1,"stats":{"Line":1}},{"line":150,"address":[502038],"length":1,"stats":{"Line":1}},{"line":151,"address":[502075],"length":1,"stats":{"Line":1}},{"line":152,"address":[502112],"length":1,"stats":{"Line":1}},{"line":159,"address":[510984,510990,503776],"length":1,"stats":{"Line":1}},{"line":160,"address":[503821,503917],"length":1,"stats":{"Line":2}},{"line":162,"address":[503939],"length":1,"stats":{"Line":1}},{"line":164,"address":[504176],"length":1,"stats":{"Line":1}},{"line":166,"address":[504299],"length":1,"stats":{"Line":1}},{"line":168,"address":[504477],"length":1,"stats":{"Line":1}},{"line":170,"address":[504686],"length":1,"stats":{"Line":1}},{"line":172,"address":[504895],"length":1,"stats":{"Line":1}},{"line":174,"address":[505078,505006],"length":1,"stats":{"Line":2}},{"line":176,"address":[505055,505095],"length":1,"stats":{"Line":2}},{"line":178,"address":[505277],"length":1,"stats":{"Line":1}},{"line":180,"address":[505437],"length":1,"stats":{"Line":1}},{"line":182,"address":[505597],"length":1,"stats":{"Line":1}},{"line":184,"address":[505757],"length":1,"stats":{"Line":1}},{"line":186,"address":[505966],"length":1,"stats":{"Line":1}},{"line":188,"address":[506175],"length":1,"stats":{"Line":1}},{"line":190,"address":[506335],"length":1,"stats":{"Line":1}},{"line":192,"address":[506495,506584],"length":1,"stats":{"Line":2}},{"line":193,"address":[506567],"length":1,"stats":{"Line":1}},{"line":196,"address":[506757],"length":1,"stats":{"Line":1}},{"line":198,"address":[506917],"length":1,"stats":{"Line":1}},{"line":200,"address":[507028],"length":1,"stats":{"Line":1}},{"line":202,"address":[507139],"length":1,"stats":{"Line":1}},{"line":204,"address":[507250],"length":1,"stats":{"Line":1}},{"line":206,"address":[507433,507361],"length":1,"stats":{"Line":2}},{"line":208,"address":[507495,507450,507410],"length":1,"stats":{"Line":3}},{"line":210,"address":[507472,507512],"length":1,"stats":{"Line":2}},{"line":212,"address":[507645],"length":1,"stats":{"Line":1}},{"line":214,"address":[507756],"length":1,"stats":{"Line":1}},{"line":216,"address":[507867],"length":1,"stats":{"Line":1}},{"line":218,"address":[508027],"length":1,"stats":{"Line":1}},{"line":220,"address":[508187],"length":1,"stats":{"Line":1}},{"line":222,"address":[508347,508436],"length":1,"stats":{"Line":2}},{"line":223,"address":[508419],"length":1,"stats":{"Line":1}},{"line":226,"address":[508556],"length":1,"stats":{"Line":1}},{"line":228,"address":[508716],"length":1,"stats":{"Line":1}},{"line":230,"address":[508876],"length":1,"stats":{"Line":1}},{"line":232,"address":[509036],"length":1,"stats":{"Line":1}},{"line":234,"address":[509147],"length":1,"stats":{"Line":1}},{"line":236,"address":[509307],"length":1,"stats":{"Line":1}},{"line":238,"address":[509467],"length":1,"stats":{"Line":1}},{"line":240,"address":[509627],"length":1,"stats":{"Line":1}},{"line":242,"address":[509836],"length":1,"stats":{"Line":1}},{"line":244,"address":[510045],"length":1,"stats":{"Line":1}},{"line":246,"address":[510156],"length":1,"stats":{"Line":1}},{"line":248,"address":[510316],"length":1,"stats":{"Line":1}},{"line":250,"address":[510476],"length":1,"stats":{"Line":1}},{"line":252,"address":[510676,510587],"length":1,"stats":{"Line":2}},{"line":253,"address":[510659],"length":1,"stats":{"Line":1}},{"line":256,"address":[510796,510868],"length":1,"stats":{"Line":2}},{"line":258,"address":[510882,510845],"length":1,"stats":{"Line":2}},{"line":259,"address":[510947],"length":1,"stats":{"Line":1}}],"covered":100,"coverable":100},{"path":["/","home","lucac","github","mermaid-builder","src","diagrams","flowchart","flowchart_node.rs"],"content":"//! Submodule defining a node which may be used in a flowchart diagram\n//! in Mermaid syntax.\n\nmod builder;\nmod shape;\nuse std::{fmt::Display, rc::Rc};\n\npub use builder::FlowchartNodeBuilder;\npub use shape::FlowchartNodeShape;\n\nuse crate::{\n    shared::{\n        ClickEvent, GenericNode, NODE_LETTER, StyleClass, generic_configuration::Direction,\n        style_class::StyleProperty,\n    },\n    traits::Node,\n};\n\n#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// Represents a node in a flowchart diagram, which can have various\n/// properties and may include click events.\n///\n/// # Examples\n///\n/// ```\n/// use mermaid_builder::{\n///     diagrams::flowchart::FlowchartNodeBuilder,\n///     traits::{Node, NodeBuilder},\n/// };\n///\n/// fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n///     let node = FlowchartNodeBuilder::default().label(\"My Node\")?.id(1).build()?;\n///\n///     assert_eq!(node.label(), \"My Node\");\n///     Ok(())\n/// }\n/// ```\npub struct FlowchartNode {\n    /// Underlying node structure.\n    node: GenericNode,\n    /// The click event associated with the node, if any.\n    click_event: Option\u003cClickEvent\u003e,\n    /// The shape of the node, which can be customized.\n    shape: FlowchartNodeShape,\n    /// The sub-nodes, when the node is a subgraph.\n    subnodes: Vec\u003cRc\u003cFlowchartNode\u003e\u003e,\n    /// The direction of the subgraph, if applicable.\n    direction: Option\u003cDirection\u003e,\n}\n\nimpl FlowchartNode {\n    /// Returns an iterator over the subnodes of the flowchart node.\n    pub fn subnodes(\u0026self) -\u003e impl Iterator\u003cItem = \u0026FlowchartNode\u003e {\n        self.subnodes.iter().map(AsRef::as_ref)\n    }\n}\n\nimpl Node for FlowchartNode {\n    type Builder = FlowchartNodeBuilder;\n\n    fn label(\u0026self) -\u003e \u0026str {\n        self.node.label()\n    }\n\n    fn id(\u0026self) -\u003e u64 {\n        self.node.id()\n    }\n\n    fn styles(\u0026self) -\u003e impl Iterator\u003cItem = \u0026StyleProperty\u003e {\n        self.node.styles()\n    }\n\n    fn classes(\u0026self) -\u003e impl Iterator\u003cItem = \u0026StyleClass\u003e {\n        self.node.classes()\n    }\n\n    fn is_compatible_arrow_shape(shape: crate::shared::ArrowShape) -\u003e bool {\n        matches!(\n            shape,\n            crate::shared::ArrowShape::Normal\n                | crate::shared::ArrowShape::Circle\n                | crate::shared::ArrowShape::X\n        )\n    }\n}\n\nimpl Display for FlowchartNode {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        use crate::traits::TabbedDisplay;\n        self.fmt_tabbed(f, 0)\n    }\n}\n\nimpl crate::traits::TabbedDisplay for FlowchartNode {\n    fn fmt_tabbed(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e, tab_count: usize) -\u003e std::fmt::Result {\n        let indent = \" \".repeat(tab_count * 2);\n        if self.subnodes.is_empty() {\n            writeln!(\n                f,\n                \"{indent}{NODE_LETTER}{}@{{shape: {}, label: \\\"{}\\\"}}\",\n                self.id(),\n                self.shape,\n                self.label()\n            )?;\n\n            if let Some(click_event) = \u0026self.click_event {\n                writeln!(f, \"{indent}click {NODE_LETTER}{} {click_event}\", self.id(),)?;\n            }\n\n            for class in self.classes() {\n                writeln!(f, \"{indent}class {NODE_LETTER}{} {}\", self.id(), class.name())?;\n            }\n        } else {\n            writeln!(f, \"{indent}subgraph {NODE_LETTER}{} [\\\"`{}`\\\"]\", self.id(), self.label())?;\n            if let Some(direction) = \u0026self.direction {\n                writeln!(f, \"{indent}    direction {direction}\")?;\n            }\n\n            for node in \u0026self.subnodes {\n                node.fmt_tabbed(f, tab_count + 1)?;\n            }\n            writeln!(f, \"{indent}end\")?;\n        }\n        if self.has_styles() {\n            write!(f, \"{indent}style {NODE_LETTER}{} \", self.id())?;\n            for (style_number, style) in self.styles().enumerate() {\n                if style_number \u003e 0 {\n                    write!(f, \", \")?;\n                }\n                write!(f, \"{style} \")?;\n            }\n            writeln!(f)?;\n        }\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::{\n        shared::{\n            ClickEvent, StyleClassBuilder, StyleProperty, style_class::Color,\n            click_event::Navigation,\n        },\n        traits::NodeBuilder,\n    };\n\n    #[test]\n    fn test_flowchart_node_display_simple() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n        let node = FlowchartNodeBuilder::default()\n            .label(\"My Node\")?\n            .id(1)\n            .shape(FlowchartNodeShape::Circle)\n            .build()?;\n\n        let output = format!(\"{}\", node);\n        assert!(output.contains(\"v1@{shape: circle, label: \\\"My Node\\\"}\"));\n        Ok(())\n    }\n\n    #[test]\n    fn test_flowchart_node_display_full() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n        let style_class = Rc::new(\n            StyleClassBuilder::default()\n                .name(\"myClass\")?\n                .property(StyleProperty::Fill(Color::from((255, 0, 0))))?\n                .build()?,\n        );\n\n        let node = FlowchartNodeBuilder::default()\n            .label(\"My Node\")?\n            .id(1)\n            .shape(FlowchartNodeShape::Rectangle)\n            .style_class(style_class)?\n            .style_property(StyleProperty::Stroke(Color::from((0, 0, 255))))?\n            .click_event(ClickEvent::Navigation(\n                Navigation::new(\"https://example.com\")\n                    .anchor(true)\n                    .tooltip(\"Open link\"),\n            ))\n            .build()?;\n\n        let output = format!(\"{}\", node);\n        assert!(output.contains(\"v1@{shape: rect, label: \\\"My Node\\\"}\"));\n        assert!(output.contains(\"click v1 href \\\"https://example.com\\\" \\\"Open link\\\"\"));\n        assert!(output.contains(\"class v1 myClass\"));\n        assert!(output.contains(\"style v1 stroke: #0000ff\"));\n        Ok(())\n    }\n\n    #[test]\n    fn test_flowchart_node_subgraph() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n        let subnode = Rc::new(FlowchartNodeBuilder::default().label(\"Sub Node\")?.id(2).build()?);\n        \n        let node = FlowchartNodeBuilder::default()\n            .label(\"My Subgraph\")?\n            .id(1)\n            .subnode(subnode)?\n            .direction(Direction::LeftToRight)\n            .build()?;\n\n        let output = format!(\"{}\", node);\n        assert!(output.contains(\"subgraph v1 [\\\"`My Subgraph`\\\"]\"));\n        assert!(output.contains(\"direction LR\"));\n        assert!(output.contains(\"v2@{shape: rect, label: \\\"Sub Node\\\"}\"));\n        assert!(output.contains(\"end\"));\n        Ok(())\n    }\n}\n","traces":[{"line":54,"address":[775104],"length":1,"stats":{"Line":0}},{"line":55,"address":[775109],"length":1,"stats":{"Line":0}},{"line":62,"address":[781584],"length":1,"stats":{"Line":1}},{"line":63,"address":[781589],"length":1,"stats":{"Line":1}},{"line":66,"address":[781568],"length":1,"stats":{"Line":1}},{"line":67,"address":[781573],"length":1,"stats":{"Line":1}},{"line":70,"address":[781600],"length":1,"stats":{"Line":1}},{"line":71,"address":[781605],"length":1,"stats":{"Line":1}},{"line":74,"address":[781616],"length":1,"stats":{"Line":5}},{"line":75,"address":[781621],"length":1,"stats":{"Line":5}},{"line":78,"address":[781504],"length":1,"stats":{"Line":2}},{"line":79,"address":[781519],"length":1,"stats":{"Line":2}},{"line":80,"address":[781511],"length":1,"stats":{"Line":2}},{"line":89,"address":[775216],"length":1,"stats":{"Line":1}},{"line":91,"address":[775230],"length":1,"stats":{"Line":1}},{"line":96,"address":[775312,779909,779915],"length":1,"stats":{"Line":1}},{"line":97,"address":[775450,775370],"length":1,"stats":{"Line":1}},{"line":98,"address":[775432,775514],"length":1,"stats":{"Line":2}},{"line":99,"address":[777033,777121,779895],"length":1,"stats":{"Line":4}},{"line":102,"address":[777025,775551],"length":1,"stats":{"Line":3}},{"line":104,"address":[777050],"length":1,"stats":{"Line":2}},{"line":107,"address":[777550],"length":1,"stats":{"Line":2}},{"line":108,"address":[777622,777679],"length":1,"stats":{"Line":2}},{"line":111,"address":[778103,777645],"length":1,"stats":{"Line":2}},{"line":112,"address":[779463,778264],"length":1,"stats":{"Line":2}},{"line":115,"address":[775528,775585,776995],"length":1,"stats":{"Line":2}},{"line":116,"address":[776038],"length":1,"stats":{"Line":1}},{"line":117,"address":[776105,776202],"length":1,"stats":{"Line":2}},{"line":120,"address":[776156,776444],"length":1,"stats":{"Line":2}},{"line":121,"address":[776546,776817],"length":1,"stats":{"Line":2}},{"line":123,"address":[776572,776795],"length":1,"stats":{"Line":1}},{"line":125,"address":[776771,778289],"length":1,"stats":{"Line":3}},{"line":126,"address":[778330,779433],"length":1,"stats":{"Line":1}},{"line":127,"address":[778692],"length":1,"stats":{"Line":1}},{"line":128,"address":[778937],"length":1,"stats":{"Line":1}},{"line":129,"address":[779136,779412],"length":1,"stats":{"Line":0}},{"line":131,"address":[779113,779253],"length":1,"stats":{"Line":2}},{"line":133,"address":[778952,779091],"length":1,"stats":{"Line":1}},{"line":135,"address":[778295],"length":1,"stats":{"Line":2}}],"covered":36,"coverable":39},{"path":["/","home","lucac","github","mermaid-builder","src","diagrams","flowchart.rs"],"content":"//! Submodule providing structs for creating flowcharts in Mermaid syntax.\n\nmod builder;\nmod configuration;\nmod curve_styles;\nmod flowchart_edge;\nmod flowchart_node;\nuse std::fmt::Display;\n\npub use builder::FlowchartBuilder;\npub use configuration::{FlowchartConfiguration, FlowchartConfigurationBuilder};\npub use curve_styles::CurveStyle;\npub use flowchart_edge::{FlowchartEdge, FlowchartEdgeBuilder};\npub use flowchart_node::{FlowchartNode, FlowchartNodeBuilder, FlowchartNodeShape};\n\nuse crate::{\n    shared::generic_diagram::GenericDiagram,\n    traits::{Configuration, Diagram, Node, edge::Edge},\n};\n\n#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// Represents a flowchart diagram in Mermaid syntax.\n///\n/// # Example\n///\n/// ```\n/// use mermaid_builder::prelude::*;\n///\n/// let mut builder = FlowchartBuilder::default();\n/// let node = builder.node(FlowchartNodeBuilder::default().label(\"Node\").unwrap()).unwrap();\n/// let flowchart = Flowchart::from(builder);\n/// ```\npub struct Flowchart {\n    generic: GenericDiagram\u003cFlowchartNode, FlowchartEdge, FlowchartConfiguration\u003e,\n}\n\nimpl Diagram for Flowchart {\n    type Builder = FlowchartBuilder;\n    type Configuration = FlowchartConfiguration;\n    type Edge = FlowchartEdge;\n    type Node = FlowchartNode;\n\n    fn configuration(\u0026self) -\u003e \u0026Self::Configuration {\n        self.generic.configuration()\n    }\n\n    fn edges(\u0026self) -\u003e impl Iterator\u003cItem = \u0026Self::Edge\u003e {\n        self.generic.edges()\n    }\n\n    fn get_node_by_id(\u0026self, id: u64) -\u003e Option\u003cstd::rc::Rc\u003cSelf::Node\u003e\u003e {\n        self.generic.get_node_by_id(id)\n    }\n\n    fn get_style_class_by_name(\n        \u0026self,\n        name: \u0026str,\n    ) -\u003e Option\u003cstd::rc::Rc\u003ccrate::shared::StyleClass\u003e\u003e {\n        self.generic.get_style_class_by_name(name)\n    }\n\n    fn nodes(\u0026self) -\u003e impl Iterator\u003cItem = \u0026Self::Node\u003e {\n        self.generic.nodes()\n    }\n\n    fn style_classes(\u0026self) -\u003e impl Iterator\u003cItem = \u0026crate::shared::StyleClass\u003e {\n        self.generic.style_classes()\n    }\n}\n\nimpl Display for Flowchart {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        use crate::traits::TabbedDisplay;\n        self.fmt_tabbed(f, 0)\n    }\n}\n\nimpl crate::traits::TabbedDisplay for Flowchart {\n    fn fmt_tabbed(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e, tab_count: usize) -\u003e std::fmt::Result {\n        let indent = \" \".repeat(tab_count * 2);\n        write!(f, \"{}\", self.configuration())?;\n        writeln!(f, \"{indent}flowchart {}\", self.configuration().direction())?;\n        for style_class in self.style_classes() {\n            if !self.nodes().any(|n| n.classes().any(|sc| sc == style_class))\n                \u0026\u0026 !self.edges().any(|e| e.classes().any(|sc| sc == style_class))\n            {\n                continue;\n            }\n\n            style_class.fmt_tabbed(f, tab_count + 1)?;\n        }\n\n        let mut subgraph_nodes = Vec::new();\n        for node in self.nodes() {\n            if subgraph_nodes.contains(\u0026node) {\n                continue;\n            }\n            subgraph_nodes.extend(node.subnodes());\n        }\n        subgraph_nodes.sort_unstable();\n\n        for node in self.nodes() {\n            if subgraph_nodes.contains(\u0026node) {\n                continue;\n            }\n            node.fmt_tabbed(f, tab_count + 1)?;\n        }\n        for edge in self.edges() {\n            edge.fmt_tabbed(f, tab_count + 1)?;\n        }\n        Ok(())\n    }\n}\n","traces":[{"line":44,"address":[562272],"length":1,"stats":{"Line":0}},{"line":45,"address":[562277],"length":1,"stats":{"Line":0}},{"line":48,"address":[562368],"length":1,"stats":{"Line":0}},{"line":49,"address":[562373],"length":1,"stats":{"Line":0}},{"line":52,"address":[562304],"length":1,"stats":{"Line":0}},{"line":53,"address":[562318],"length":1,"stats":{"Line":0}},{"line":56,"address":[562336],"length":1,"stats":{"Line":0}},{"line":60,"address":[562354],"length":1,"stats":{"Line":0}},{"line":63,"address":[562384],"length":1,"stats":{"Line":0}},{"line":64,"address":[562389],"length":1,"stats":{"Line":0}},{"line":67,"address":[562288],"length":1,"stats":{"Line":0}},{"line":68,"address":[562293],"length":1,"stats":{"Line":0}},{"line":73,"address":[565504],"length":1,"stats":{"Line":0}},{"line":75,"address":[565518],"length":1,"stats":{"Line":0}},{"line":80,"address":[562560,565137,564771],"length":1,"stats":{"Line":0}},{"line":81,"address":[562695,562618],"length":1,"stats":{"Line":0}},{"line":82,"address":[565123,562680,562760],"length":1,"stats":{"Line":0}},{"line":83,"address":[562974,565102],"length":1,"stats":{"Line":0}},{"line":84,"address":[563286],"length":1,"stats":{"Line":0}},{"line":85,"address":[564793,563474],"length":1,"stats":{"Line":0}},{"line":86,"address":[564908,564854],"length":1,"stats":{"Line":0}},{"line":91,"address":[564977,564879],"length":1,"stats":{"Line":0}},{"line":94,"address":[563508],"length":1,"stats":{"Line":0}},{"line":95,"address":[563602,563523],"length":1,"stats":{"Line":0}},{"line":96,"address":[563751,564691],"length":1,"stats":{"Line":0}},{"line":99,"address":[564716],"length":1,"stats":{"Line":0}},{"line":101,"address":[563785],"length":1,"stats":{"Line":0}},{"line":103,"address":[563839],"length":1,"stats":{"Line":0}},{"line":104,"address":[564027,564467],"length":1,"stats":{"Line":0}},{"line":107,"address":[564500],"length":1,"stats":{"Line":0}},{"line":109,"address":[564061],"length":1,"stats":{"Line":0}},{"line":110,"address":[564321,564230],"length":1,"stats":{"Line":0}},{"line":112,"address":[564249],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":33},{"path":["/","home","lucac","github","mermaid-builder","src","diagrams.rs"],"content":"//! Submodule defining properties and structures shared across different types\n//! of Mermaid diagrams.\n\npub mod class_diagram;\npub mod entity_relationship;\npub mod flowchart;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","lucac","github","mermaid-builder","src","errors","config_error.rs"],"content":"//! Submodule providing an enumeration of possible errors that can occur in the\n//! configuration of diagrams in Mermaid syntax.\n\nuse thiserror::Error;\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Error)]\n#[cfg_attr(feature = \"serde\", derive(serde::Deserialize, serde::Serialize))]\n/// Enum representing errors related to configuration in Mermaid diagrams.\npub enum ConfigError {\n    /// The provided diagram title is empty.\n    #[error(\"Configuration title cannot be empty.\")]\n    EmptyTitle,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","lucac","github","mermaid-builder","src","errors","edge_error.rs"],"content":"//! Submodule providing an enumeration of possible errors that can occur in the\n//! edges of diagrams in Mermaid syntax.\n\nuse thiserror::Error;\n\nuse crate::shared::ArrowShape;\n\n#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Error)]\n#[cfg_attr(feature = \"serde\", derive(serde::Deserialize, serde::Serialize))]\n/// Enum representing errors related to edges in Mermaid diagrams.\npub enum EdgeError {\n    /// The provided edge label is empty.\n    #[error(\"Edge label cannot be empty.\")]\n    EmptyLabel,\n    /// The provided left arrow shape is not compatible with the diagram.\n    #[error(\"Incompatible left arrow shape: `{}`\", .0.left())]\n    IncompatibleLeftArrowShape(ArrowShape),\n    /// The provided right arrow shape is not compatible with the diagram.\n    #[error(\"Incompatible right arrow shape: `{}`\", .0.right())]\n    IncompatibleRightArrowShape(ArrowShape),\n    /// The provided source node does not exist in the diagram.\n    #[error(\"Source node not found: `{0}`\")]\n    SourceNodeNotFound(String),\n    /// The provided destination node does not exist in the diagram.\n    #[error(\"Destination node not found: `{0}`\")]\n    DestinationNodeNotFound(String),\n    /// The source node is missing.\n    #[error(\"Source node is missing.\")]\n    MissingSource,\n    /// The destination node is missing.\n    #[error(\"Destination node is missing.\")]\n    MissingDestination,\n    /// The edge ID is missing.\n    #[error(\"Edge ID is missing.\")]\n    MissingId,\n    /// The edge length is invalid (must be \u003e 0).\n    #[error(\"Edge length must be greater than 0.\")]\n    InvalidLength,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","lucac","github","mermaid-builder","src","errors","node_error.rs"],"content":"//! Submodule providing an enumeration of possible errors that can occur in the\n//! nodes of diagrams in Mermaid syntax.\n\nuse thiserror::Error;\n\n#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Error)]\n#[cfg_attr(feature = \"serde\", derive(serde::Deserialize, serde::Serialize))]\n/// Enum representing errors related to nodes in Mermaid diagrams.\npub enum NodeError {\n    /// The provided node label is empty.\n    #[error(\"Node label cannot be empty.\")]\n    EmptyLabel,\n    /// The provided node ID is empty.\n    #[error(\"Node ID cannot be empty.\")]\n    EmptyId,\n    /// The provided node ID contains invalid characters.\n    #[error(\"Node ID `{0}` contains invalid characters.\")]\n    InvalidId(String),\n    /// The provided node already exists in the diagram.\n    #[error(\"Node `{0}` already exists.\")]\n    DuplicateNode(String),\n    /// The node ID is missing.\n    #[error(\"Node ID is missing.\")]\n    MissingId,\n    /// The node label is missing.\n    #[error(\"Node label is missing.\")]\n    MissingLabel,\n    /// The subnodes are missing (required for subgraph with direction).\n    #[error(\"Subnodes are missing.\")]\n    MissingSubnodes,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","lucac","github","mermaid-builder","src","errors.rs"],"content":"//! Submodule defining the possible errors that can occur in the Mermaid\n//! library.\n\nuse thiserror::Error;\n\nmod config_error;\npub use config_error::ConfigError;\nmod edge_error;\npub use edge_error::EdgeError;\nmod node_error;\npub use node_error::NodeError;\n\npub use crate::shared::style_class::StyleClassError;\n\n#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Error)]\n#[cfg_attr(feature = \"serde\", derive(serde::Deserialize, serde::Serialize))]\n/// Enum representing the different types of errors that can occur in the\n/// Mermaid library.\npub enum Error {\n    /// An error regarding nodes.\n    #[error(\"Node error: {0}\")]\n    Node(#[from] NodeError),\n    /// An error regarding edges.\n    #[error(\"Edge error: {0}\")]\n    Edge(#[from] EdgeError),\n    /// An error regarding diagram configuration.\n    #[error(\"Configuration error: {0}\")]\n    Config(#[from] ConfigError),\n    /// An error regarding style classes.\n    #[error(\"Style class error: {0}\")]\n    StyleClass(#[from] StyleClassError),\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","lucac","github","mermaid-builder","src","lib.rs"],"content":"#![doc = include_str!(\"../README.md\")]\npub mod diagrams;\nmod errors;\nmod shared;\npub mod traits;\npub use errors::{ConfigError, EdgeError, NodeError, StyleClassError};\n\n/// Submodule providing common traits and types for Mermaid diagrams.\npub mod prelude {\n    pub use crate::{\n        diagrams::{class_diagram::*, entity_relationship::*, flowchart::*},\n        shared::{\n            ArrowShape, Color, Direction, FontWeight, LineStyle, Renderer, StyleClass,\n            StyleClassBuilder, StyleProperty, Unit,\n        },\n        traits::*,\n    };\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","lucac","github","mermaid-builder","src","nodes","shape.rs"],"content":"","traces":[],"covered":0,"coverable":0},{"path":["/","home","lucac","github","mermaid-builder","src","shared","arrow_shape.rs"],"content":"//! Submodule defining the possible arrow shapes for links in Mermaid diagrams.\n\n#[derive(Default, Copy, Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// Represents the shape of an arrow that can be used in Mermaid diagrams.\npub enum ArrowShape {\n    /// Arrow shape with a normal arrowhead.\n    #[default]\n    Normal,\n    /// A sharp arrowhead shape.\n    Sharp,\n    /// X shape arrowhead.\n    X,\n    /// Circle shape arrowhead.\n    Circle,\n    /// Triangle shape arrowhead.\n    Triangle,\n    /// Star shape arrowhead.\n    Star,\n    /// Shape representing zero or one dependency.\n    ZeroOrOne,\n    /// Shape representing exactly one dependency.\n    ExactlyOne,\n    /// Shape representing zero or more dependencies.\n    ZeroOrMore,\n    /// Shape representing one or more dependencies.\n    OneOrMore,\n}\n\nimpl ArrowShape {\n    #[must_use]\n    /// Returns the left-oriented arrow shape.\n    pub fn left(\u0026self) -\u003e \u0026str {\n        match self {\n            ArrowShape::Normal =\u003e \"\u003c\",\n            ArrowShape::Sharp =\u003e \"(\",\n            ArrowShape::X =\u003e \"x\",\n            ArrowShape::Circle =\u003e \"o\",\n            ArrowShape::Triangle =\u003e \"\u003c|\",\n            ArrowShape::Star =\u003e \"*\",\n            ArrowShape::ZeroOrOne =\u003e \"|o\",\n            ArrowShape::ExactlyOne =\u003e \"||\",\n            ArrowShape::ZeroOrMore =\u003e \"}o\",\n            ArrowShape::OneOrMore =\u003e \"}|\",\n        }\n    }\n\n    #[must_use]\n    /// Returns the right-oriented arrow shape.\n    pub fn right(\u0026self) -\u003e \u0026str {\n        match self {\n            ArrowShape::Normal =\u003e \"\u003e\",\n            ArrowShape::Sharp =\u003e \")\",\n            ArrowShape::X =\u003e \"x\",\n            ArrowShape::Circle =\u003e \"o\",\n            ArrowShape::Triangle =\u003e \"|\u003e\",\n            ArrowShape::Star =\u003e \"*\",\n            ArrowShape::ZeroOrOne =\u003e \"o|\",\n            ArrowShape::ExactlyOne =\u003e \"||\",\n            ArrowShape::ZeroOrMore =\u003e \"o{\",\n            ArrowShape::OneOrMore =\u003e \"|{\",\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_arrow_shape_left() {\n        assert_eq!(ArrowShape::Normal.left(), \"\u003c\");\n        assert_eq!(ArrowShape::Sharp.left(), \"(\");\n        assert_eq!(ArrowShape::X.left(), \"x\");\n        assert_eq!(ArrowShape::Circle.left(), \"o\");\n        assert_eq!(ArrowShape::Triangle.left(), \"\u003c|\");\n        assert_eq!(ArrowShape::Star.left(), \"*\");\n        assert_eq!(ArrowShape::ZeroOrOne.left(), \"|o\");\n        assert_eq!(ArrowShape::ExactlyOne.left(), \"||\");\n        assert_eq!(ArrowShape::ZeroOrMore.left(), \"}o\");\n        assert_eq!(ArrowShape::OneOrMore.left(), \"}|\");\n    }\n\n    #[test]\n    fn test_arrow_shape_right() {\n        assert_eq!(ArrowShape::Normal.right(), \"\u003e\");\n        assert_eq!(ArrowShape::Sharp.right(), \")\");\n        assert_eq!(ArrowShape::X.right(), \"x\");\n        assert_eq!(ArrowShape::Circle.right(), \"o\");\n        assert_eq!(ArrowShape::Triangle.right(), \"|\u003e\");\n        assert_eq!(ArrowShape::Star.right(), \"*\");\n        assert_eq!(ArrowShape::ZeroOrOne.right(), \"o|\");\n        assert_eq!(ArrowShape::ExactlyOne.right(), \"||\");\n        assert_eq!(ArrowShape::ZeroOrMore.right(), \"o{\");\n        assert_eq!(ArrowShape::OneOrMore.right(), \"|{\");\n    }\n}\n","traces":[{"line":33,"address":[542000],"length":1,"stats":{"Line":1}},{"line":34,"address":[542005],"length":1,"stats":{"Line":1}},{"line":35,"address":[542036],"length":1,"stats":{"Line":1}},{"line":36,"address":[542062],"length":1,"stats":{"Line":1}},{"line":37,"address":[542088],"length":1,"stats":{"Line":1}},{"line":38,"address":[542114],"length":1,"stats":{"Line":1}},{"line":39,"address":[542140],"length":1,"stats":{"Line":1}},{"line":40,"address":[542163],"length":1,"stats":{"Line":1}},{"line":41,"address":[542186],"length":1,"stats":{"Line":1}},{"line":42,"address":[542209],"length":1,"stats":{"Line":1}},{"line":43,"address":[542232],"length":1,"stats":{"Line":1}},{"line":44,"address":[542255],"length":1,"stats":{"Line":1}},{"line":50,"address":[542288],"length":1,"stats":{"Line":1}},{"line":51,"address":[542293],"length":1,"stats":{"Line":1}},{"line":52,"address":[542324],"length":1,"stats":{"Line":1}},{"line":53,"address":[542350],"length":1,"stats":{"Line":1}},{"line":54,"address":[542376],"length":1,"stats":{"Line":1}},{"line":55,"address":[542402],"length":1,"stats":{"Line":1}},{"line":56,"address":[542428],"length":1,"stats":{"Line":1}},{"line":57,"address":[542451],"length":1,"stats":{"Line":1}},{"line":58,"address":[542474],"length":1,"stats":{"Line":1}},{"line":59,"address":[542497],"length":1,"stats":{"Line":1}},{"line":60,"address":[542520],"length":1,"stats":{"Line":1}},{"line":61,"address":[542543],"length":1,"stats":{"Line":1}}],"covered":24,"coverable":24},{"path":["/","home","lucac","github","mermaid-builder","src","shared","click_event","js_function_call.rs"],"content":"//! Submodule handling click events in Mermaid nodes which lead to calling\n//! JavaScript functions, including the typing of the function signature\n//! and the function call itself.\n\nuse std::fmt::Display;\n\n#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// Represents a JavaScript function call that can be triggered by a click event\n/// on a Mermaid node.\npub struct JsFunctionCall {\n    /// The name of the JavaScript function to call.\n    function_name: String,\n    /// The arguments to pass to the JavaScript function.\n    args: Vec\u003cString\u003e,\n}\n\nimpl Display for JsFunctionCall {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        let args_str = if self.args.is_empty() {\n            String::new()\n        } else {\n            format!(\"({})\", self.args.join(\", \"))\n        };\n        write!(f, \"{}{}\", self.function_name, args_str)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_js_function_call_display() {\n        let call = JsFunctionCall { function_name: \"myFunc\".to_string(), args: vec![] };\n        assert_eq!(format!(\"{call}\"), \"myFunc\");\n\n        let call = JsFunctionCall {\n            function_name: \"myFunc\".to_string(),\n            args: vec![\"arg1\".to_string(), \"arg2\".to_string()],\n        };\n        assert_eq!(format!(\"{call}\"), \"myFunc(arg1, arg2)\");\n    }\n}\n","traces":[{"line":19,"address":[787109,787115,786784],"length":1,"stats":{"Line":1}},{"line":20,"address":[786817],"length":1,"stats":{"Line":1}},{"line":21,"address":[786907],"length":1,"stats":{"Line":1}},{"line":23,"address":[786835,786922],"length":1,"stats":{"Line":1}},{"line":25,"address":[787166,787069],"length":1,"stats":{"Line":2}}],"covered":5,"coverable":5},{"path":["/","home","lucac","github","mermaid-builder","src","shared","click_event","navigation.rs"],"content":"//! Submodule handling navigation click events in Mermaid diagrams, which\n//! can include anchor-like links or JavaScript function calls navigating to\n//! external resources or internal sections, with or without opening in a new\n//! tab.\n\nuse std::fmt::Display;\n\n/// Represents a navigation event triggered by a click on a node in a Mermaid\n/// diagram. This can include external links, with options for opening in a new\n/// tab and whether to use an anchor-like link or a JavaScript function for\n/// navigation.\n///\n/// # Example\n///\n/// Some example of mermaid syntax for a navigation event:\n///\n/// ```mermaid\n/// click A \"https://www.github.com\" _blank\n/// click B \"https://www.github.com\" \"Open this in a new tab\" _blank\n/// click C href \"https://www.github.com\" _blank\n/// click D href \"https://www.github.com\" \"Open this in a new tab\" _blank\n/// ```\n#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\npub struct Navigation {\n    /// The URL to navigate to when the node is clicked.\n    url: String,\n    /// Whether to open the link in a new tab.\n    new_tab: bool,\n    /// Whether to employ an anchor-like link or a JavaScript function for\n    /// navigation.\n    anchor: bool,\n    /// Descriptive tooltip for the navigation link.\n    tooltip: Option\u003cString\u003e,\n}\n\nimpl Navigation {\n    /// Creates a new navigation event.\n    pub fn new(url: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            url: url.into(),\n            new_tab: false,\n            anchor: false,\n            tooltip: None,\n        }\n    }\n\n    /// Sets whether to open the link in a new tab.\n    pub fn new_tab(mut self, new_tab: bool) -\u003e Self {\n        self.new_tab = new_tab;\n        self\n    }\n\n    /// Sets whether to employ an anchor-like link or a JavaScript function for\n    /// navigation.\n    pub fn anchor(mut self, anchor: bool) -\u003e Self {\n        self.anchor = anchor;\n        self\n    }\n\n    /// Sets the tooltip for the navigation link.\n    pub fn tooltip(mut self, tooltip: impl Into\u003cString\u003e) -\u003e Self {\n        self.tooltip = Some(tooltip.into());\n        self\n    }\n}\n\nimpl Display for Navigation {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        // We omit the `click {node_name}` part as it is not relevant for the\n        // display of the navigation event, and is handled by the parent\n        // `ClickEvent` enum.\n        if self.anchor {\n            write!(f, \"href\")?;\n        }\n        write!(f, \" \\\"{}\\\"\", self.url)?;\n\n        if let Some(tooltip) = \u0026self.tooltip {\n            write!(f, \" \\\"{tooltip}\\\"\")?;\n        }\n\n        if self.new_tab {\n            write!(f, \" _blank\")?;\n        }\n\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_navigation_display() {\n        let nav = Navigation {\n            url: \"https://example.com\".to_string(),\n            new_tab: false,\n            anchor: false,\n            tooltip: None,\n        };\n        assert_eq!(format!(\"{nav}\"), \" \\\"https://example.com\\\"\");\n\n        let nav = Navigation {\n            url: \"https://example.com\".to_string(),\n            new_tab: true,\n            anchor: false,\n            tooltip: None,\n        };\n        assert_eq!(format!(\"{nav}\"), \" \\\"https://example.com\\\" _blank\");\n\n        let nav = Navigation {\n            url: \"https://example.com\".to_string(),\n            new_tab: false,\n            anchor: true,\n            tooltip: None,\n        };\n        assert_eq!(format!(\"{nav}\"), \"href \\\"https://example.com\\\"\");\n\n        let nav = Navigation {\n            url: \"https://example.com\".to_string(),\n            new_tab: true,\n            anchor: true,\n            tooltip: Some(\"Tooltip\".to_string()),\n        };\n        assert_eq!(format!(\"{nav}\"), \"href \\\"https://example.com\\\" \\\"Tooltip\\\" _blank\");\n    }\n}\n","traces":[{"line":39,"address":[600512],"length":1,"stats":{"Line":2}},{"line":41,"address":[600536],"length":1,"stats":{"Line":2}},{"line":49,"address":[375440],"length":1,"stats":{"Line":0}},{"line":50,"address":[375463],"length":1,"stats":{"Line":0}},{"line":51,"address":[375468],"length":1,"stats":{"Line":0}},{"line":56,"address":[375392],"length":1,"stats":{"Line":1}},{"line":57,"address":[375415],"length":1,"stats":{"Line":1}},{"line":58,"address":[375420],"length":1,"stats":{"Line":1}},{"line":62,"address":[600916,600656],"length":1,"stats":{"Line":1}},{"line":63,"address":[600772,600714],"length":1,"stats":{"Line":2}},{"line":64,"address":[600893],"length":1,"stats":{"Line":1}},{"line":69,"address":[376704],"length":1,"stats":{"Line":1}},{"line":73,"address":[376731],"length":1,"stats":{"Line":1}},{"line":74,"address":[376838],"length":1,"stats":{"Line":1}},{"line":76,"address":[376742,376919],"length":1,"stats":{"Line":1}},{"line":78,"address":[376947],"length":1,"stats":{"Line":1}},{"line":79,"address":[377118,377002],"length":1,"stats":{"Line":1}},{"line":82,"address":[377110],"length":1,"stats":{"Line":1}},{"line":83,"address":[377157],"length":1,"stats":{"Line":1}},{"line":86,"address":[377150],"length":1,"stats":{"Line":1}}],"covered":17,"coverable":20},{"path":["/","home","lucac","github","mermaid-builder","src","shared","click_event.rs"],"content":"//! Enumeration of events associated with a click action on a node in a Mermaid\n//! diagram.\n\nmod navigation;\nuse std::fmt::Display;\n\npub use navigation::Navigation;\nmod js_function_call;\npub use js_function_call::JsFunctionCall;\n\n#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\npub enum ClickEvent {\n    /// Represents a click event that triggers a navigation event,\n    /// which can be a external link with or without opening in a new tab,\n    /// and that can either be triggered via a real anchor link or a JavaScript\n    /// function.\n    Navigation(Navigation),\n    /// Represents a click event that triggers a JavaScript function call.\n    JsFunctionCall(JsFunctionCall),\n}\n\nimpl Display for ClickEvent {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            ClickEvent::Navigation(nav) =\u003e write!(f, \"{nav}\",),\n            ClickEvent::JsFunctionCall(js_call) =\u003e write!(f, \"{js_call}\",),\n        }\n    }\n}\n","traces":[{"line":24,"address":[219360],"length":1,"stats":{"Line":1}},{"line":25,"address":[219386],"length":1,"stats":{"Line":1}},{"line":26,"address":[219522],"length":1,"stats":{"Line":1}},{"line":27,"address":[219422],"length":1,"stats":{"Line":0}}],"covered":3,"coverable":4},{"path":["/","home","lucac","github","mermaid-builder","src","shared","constants.rs"],"content":"//! Constants used across the mermaid crate.\n\npub(crate) const NODE_LETTER: \u0026str = \"v\";\npub(crate) const EDGE_LETTER: \u0026str = \"e\";\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","lucac","github","mermaid-builder","src","shared","generic_configuration","direction.rs"],"content":"//! Submodule defining whether a flowchart is meant to extend in a horizontal or\n//! vertical direction.\n\nuse std::fmt::Display;\n\n#[derive(Default, Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// Represents the direction of a flowchart in Mermaid diagrams.\npub enum Direction {\n    /// The flowchart extends horizontally.\n    #[default]\n    LeftToRight,\n    /// The flowchart extends vertically.\n    TopToBottom,\n    /// The flowchart extends in a right-to-left direction.\n    RightToLeft,\n    /// The flowchart extends in a bottom-to-top direction.\n    BottomToTop,\n}\n\nimpl Direction {\n    #[must_use]\n    /// Changes the orientation from vertical to horizontal or vice versa.\n    pub fn flip(self) -\u003e Self {\n        match self {\n            Self::LeftToRight =\u003e Self::TopToBottom,\n            Self::TopToBottom =\u003e Self::LeftToRight,\n            Self::RightToLeft =\u003e Self::BottomToTop,\n            Self::BottomToTop =\u003e Self::RightToLeft,\n        }\n    }\n}\n\nimpl Display for Direction {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(\n            f,\n            \"{}\",\n            match self {\n                Self::LeftToRight =\u003e \"LR\",\n                Self::TopToBottom =\u003e \"TB\",\n                Self::RightToLeft =\u003e \"RL\",\n                Self::BottomToTop =\u003e \"BT\",\n            }\n        )\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_direction_display() {\n        assert_eq!(format!(\"{}\", Direction::LeftToRight), \"LR\");\n        assert_eq!(format!(\"{}\", Direction::TopToBottom), \"TB\");\n        assert_eq!(format!(\"{}\", Direction::RightToLeft), \"RL\");\n        assert_eq!(format!(\"{}\", Direction::BottomToTop), \"BT\");\n    }\n\n    #[test]\n    fn test_direction_flip() {\n        assert_eq!(Direction::LeftToRight.flip(), Direction::TopToBottom);\n        assert_eq!(Direction::TopToBottom.flip(), Direction::LeftToRight);\n        assert_eq!(Direction::RightToLeft.flip(), Direction::BottomToTop);\n        assert_eq!(Direction::BottomToTop.flip(), Direction::RightToLeft);\n    }\n}\n","traces":[{"line":24,"address":[762368],"length":1,"stats":{"Line":1}},{"line":25,"address":[762375],"length":1,"stats":{"Line":1}},{"line":26,"address":[762406],"length":1,"stats":{"Line":1}},{"line":27,"address":[762413],"length":1,"stats":{"Line":1}},{"line":28,"address":[762420],"length":1,"stats":{"Line":1}},{"line":29,"address":[762427],"length":1,"stats":{"Line":1}},{"line":35,"address":[762976],"length":1,"stats":{"Line":1}},{"line":36,"address":[763115],"length":1,"stats":{"Line":1}},{"line":39,"address":[762994],"length":1,"stats":{"Line":1}},{"line":40,"address":[763025],"length":1,"stats":{"Line":1}},{"line":41,"address":[763048],"length":1,"stats":{"Line":1}},{"line":42,"address":[763071],"length":1,"stats":{"Line":1}},{"line":43,"address":[763094],"length":1,"stats":{"Line":1}}],"covered":13,"coverable":13},{"path":["/","home","lucac","github","mermaid-builder","src","shared","generic_configuration","look.rs"],"content":"//! The looks enumeration to use for rendering a Mermaid diagram.\n\nuse std::fmt::Display;\n\n#[derive(Default, Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// The looks enumeration to use for rendering a Mermaid diagram.\npub enum Look {\n    /// The Neo look, a modern style for diagrams.\n    Neo,\n    /// The hand-drawn look, a sketch-like style for diagrams.\n    HandDrawn,\n    #[default]\n    /// The Classic look, the traditional Mermaid style.\n    Classic,\n}\n\nimpl Display for Look {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(\n            f,\n            \"{}\",\n            match self {\n                Look::Neo =\u003e \"neo\",\n                Look::HandDrawn =\u003e \"handDrawn\",\n                Look::Classic =\u003e \"classic\",\n            }\n        )\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_look_display() {\n        assert_eq!(format!(\"{}\", Look::Neo), \"neo\");\n        assert_eq!(format!(\"{}\", Look::HandDrawn), \"handDrawn\");\n        assert_eq!(format!(\"{}\", Look::Classic), \"classic\");\n    }\n}\n","traces":[{"line":19,"address":[561552],"length":1,"stats":{"Line":1}},{"line":20,"address":[561669],"length":1,"stats":{"Line":1}},{"line":23,"address":[561570],"length":1,"stats":{"Line":1}},{"line":24,"address":[561602],"length":1,"stats":{"Line":1}},{"line":25,"address":[561625],"length":1,"stats":{"Line":1}},{"line":26,"address":[561648],"length":1,"stats":{"Line":2}}],"covered":6,"coverable":6},{"path":["/","home","lucac","github","mermaid-builder","src","shared","generic_configuration","renderers.rs"],"content":"//! Submodule defining the possible renderers which may be used in a flowchart\n//! configuration in Mermaid.\n\nuse std::fmt::Display;\n\n#[derive(Default, Copy, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// Represents the renderer used for Mermaid diagrams.\npub enum Renderer {\n    /// The dagre renderer, which is the default renderer for flowcharts.\n    #[default]\n    Dagre,\n    /// The newer Eclipse Layout Kernel (ELK) renderer, which is an alternative\n    /// to the dagre renderer.\n    EclipseLayoutKernel,\n}\n\nimpl Display for Renderer {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Renderer::Dagre =\u003e write!(f, \"dagre\"),\n            Renderer::EclipseLayoutKernel =\u003e write!(f, \"elk\"),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_renderer_display() {\n        assert_eq!(format!(\"{}\", Renderer::Dagre), \"dagre\");\n        assert_eq!(format!(\"{}\", Renderer::EclipseLayoutKernel), \"elk\");\n    }\n}\n","traces":[{"line":19,"address":[814512],"length":1,"stats":{"Line":1}},{"line":20,"address":[814531],"length":1,"stats":{"Line":1}},{"line":21,"address":[814584],"length":1,"stats":{"Line":1}},{"line":22,"address":[814546],"length":1,"stats":{"Line":1}}],"covered":4,"coverable":4},{"path":["/","home","lucac","github","mermaid-builder","src","shared","generic_configuration","theme.rs"],"content":"//! The themes enumeration to use for rendering a Mermaid diagram.\n\nuse std::fmt::Display;\n\n#[derive(Default, Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// The themes enumeration to use for rendering a Mermaid diagram.\npub enum Theme {\n    /// The classic Mermaid chart theme.\n    MermaidChart,\n    /// The `Neo` theme, a modern style for diagrams.\n    Neo,\n    /// The `NeoDark` theme, a dark variant of Neo.\n    NeoDark,\n    /// The default theme for Mermaid diagrams.\n    #[default]\n    Default,\n    /// The `Forest` theme, with green accents and natural tones.\n    Forest,\n    /// The `Base` theme, a minimal and clean style.\n    Base,\n    /// The `Dark` theme, for diagrams with a dark background.\n    Dark,\n    /// The `Neutral` theme, with muted and balanced colors.\n    Neutral,\n    /// The `Redux` theme, a vibrant and bold style.\n    Redux,\n    /// The `ReduxDark` theme, a dark variant of Redux.\n    ReduxDark,\n}\n\nimpl Display for Theme {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(\n            f,\n            \"{}\",\n            match self {\n                Theme::MermaidChart =\u003e \"mc\",\n                Theme::Neo =\u003e \"neo\",\n                Theme::NeoDark =\u003e \"neo-dark\",\n                Theme::Default =\u003e \"default\",\n                Theme::Forest =\u003e \"forest\",\n                Theme::Base =\u003e \"base\",\n                Theme::Dark =\u003e \"dark\",\n                Theme::Neutral =\u003e \"neutral\",\n                Theme::Redux =\u003e \"redux\",\n                Theme::ReduxDark =\u003e \"redux-dark\",\n            }\n        )\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_theme_display() {\n        assert_eq!(format!(\"{}\", Theme::MermaidChart), \"mc\");\n        assert_eq!(format!(\"{}\", Theme::Neo), \"neo\");\n        assert_eq!(format!(\"{}\", Theme::NeoDark), \"neo-dark\");\n        assert_eq!(format!(\"{}\", Theme::Default), \"default\");\n        assert_eq!(format!(\"{}\", Theme::Forest), \"forest\");\n        assert_eq!(format!(\"{}\", Theme::Base), \"base\");\n        assert_eq!(format!(\"{}\", Theme::Dark), \"dark\");\n        assert_eq!(format!(\"{}\", Theme::Neutral), \"neutral\");\n        assert_eq!(format!(\"{}\", Theme::Redux), \"redux\");\n        assert_eq!(format!(\"{}\", Theme::ReduxDark), \"redux-dark\");\n    }\n}\n","traces":[{"line":33,"address":[692768],"length":1,"stats":{"Line":1}},{"line":34,"address":[693057],"length":1,"stats":{"Line":1}},{"line":37,"address":[692786],"length":1,"stats":{"Line":1}},{"line":38,"address":[692817],"length":1,"stats":{"Line":1}},{"line":39,"address":[692843],"length":1,"stats":{"Line":1}},{"line":40,"address":[692869],"length":1,"stats":{"Line":1}},{"line":41,"address":[692895],"length":1,"stats":{"Line":1}},{"line":42,"address":[692921],"length":1,"stats":{"Line":1}},{"line":43,"address":[692944],"length":1,"stats":{"Line":1}},{"line":44,"address":[692967],"length":1,"stats":{"Line":1}},{"line":45,"address":[692990],"length":1,"stats":{"Line":1}},{"line":46,"address":[693013],"length":1,"stats":{"Line":1}},{"line":47,"address":[693036],"length":1,"stats":{"Line":1}}],"covered":13,"coverable":13},{"path":["/","home","lucac","github","mermaid-builder","src","shared","generic_configuration.rs"],"content":"//! Submodule defining the configuration options which are applied at the top\n//! level of a Mermaid diagram.\n\nmod renderers;\nuse std::fmt::Display;\n\npub use renderers::Renderer;\nmod direction;\npub use direction::Direction;\nmod theme;\npub use theme::Theme;\nmod look;\npub use look::Look;\n\nuse crate::{\n    errors::ConfigError,\n    traits::{Configuration, ConfigurationBuilder},\n};\n\n#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// Represents the configuration options for a Mermaid diagram.\npub struct GenericConfiguration {\n    /// The title of the diagram.\n    title: Option\u003cString\u003e,\n    /// The renderer to use for the diagram.\n    renderer: Renderer,\n    /// The direction of the flowchart.\n    direction: Direction,\n    /// The theme to use for the diagram.\n    theme: Theme,\n    /// The look to use for the diagram.\n    look: Look,\n}\n\nimpl Configuration for GenericConfiguration {\n    type Builder = GenericConfigurationBuilder;\n\n    fn title(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n        self.title.as_deref()\n    }\n\n    fn renderer(\u0026self) -\u003e Renderer {\n        self.renderer\n    }\n\n    fn direction(\u0026self) -\u003e Direction {\n        self.direction\n    }\n\n    fn theme(\u0026self) -\u003e Theme {\n        self.theme\n    }\n\n    fn look(\u0026self) -\u003e Look {\n        self.look\n    }\n}\n\nimpl Display for GenericConfiguration {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        writeln!(f, \"---\")?;\n        writeln!(f, \"config:\")?;\n        writeln!(f, \"  layout: {}\", self.renderer)?;\n        writeln!(f, \"  theme: {}\", self.theme)?;\n        writeln!(f, \"  look: {}\", self.look)?;\n        if let Some(title) = \u0026self.title {\n            writeln!(f, \"title: {title}\")?;\n        }\n        writeln!(f, \"---\")?;\n\n        Ok(())\n    }\n}\n\n#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// Builder for creating a `GenericConfiguration`.\npub struct GenericConfigurationBuilder {\n    /// The title of the diagram.\n    title: Option\u003cString\u003e,\n    /// The renderer to use for the diagram.\n    renderer: Renderer,\n    /// The direction of the flowchart.\n    direction: Direction,\n    /// The theme to use for the diagram.\n    theme: Theme,\n    /// The look to use for the diagram.\n    look: Look,\n}\n\nimpl TryFrom\u003cGenericConfigurationBuilder\u003e for GenericConfiguration {\n    type Error = ConfigError;\n\n    fn try_from(builder: GenericConfigurationBuilder) -\u003e Result\u003cSelf, Self::Error\u003e {\n        Ok(GenericConfiguration {\n            title: builder.title,\n            renderer: builder.renderer,\n            direction: builder.direction,\n            theme: builder.theme,\n            look: builder.look,\n        })\n    }\n}\n\nimpl ConfigurationBuilder for GenericConfigurationBuilder {\n    type Configuration = GenericConfiguration;\n    type Error = ConfigError;\n\n    fn build(self) -\u003e Result\u003cSelf::Configuration, Self::Error\u003e {\n        self.try_into()\n    }\n\n    fn title\u003cS: ToString\u003e(mut self, title: S) -\u003e Result\u003cSelf, Self::Error\u003e {\n        let title = title.to_string();\n        if title.is_empty() {\n            return Err(ConfigError::EmptyTitle);\n        }\n        self.title = Some(title);\n        Ok(self)\n    }\n\n    fn renderer(mut self, renderer: Renderer) -\u003e Self {\n        self.renderer = renderer;\n        self\n    }\n\n    fn direction(mut self, direction: Direction) -\u003e Self {\n        self.direction = direction;\n        self\n    }\n}\n\nimpl GenericConfigurationBuilder {\n    /// Sets the theme to use for the diagram.\n    #[must_use]\n    pub fn theme(mut self, theme: Theme) -\u003e Self {\n        self.theme = theme;\n        self\n    }\n\n    /// Sets the look to use for the diagram.\n    #[must_use]\n    pub fn look(mut self, look: Look) -\u003e Self {\n        self.look = look;\n        self\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_generic_configuration_display() {\n        let config = GenericConfiguration::default();\n        assert_eq!(\n            format!(\"{config}\"),\n            \"---\\nconfig:\\n  layout: dagre\\n  theme: default\\n  look: classic\\n---\\n\"\n        );\n    }\n\n    #[test]\n    fn test_generic_configuration_builder() -\u003e Result\u003c(), ConfigError\u003e {\n        let config = GenericConfigurationBuilder::default()\n            .title(\"My Diagram\")?\n            .renderer(Renderer::EclipseLayoutKernel)\n            .direction(Direction::TopToBottom)\n            .theme(Theme::Forest)\n            .look(Look::HandDrawn)\n            .build()?;\n\n        assert_eq!(config.title(), Some(\"My Diagram\"));\n        assert_eq!(config.renderer(), Renderer::EclipseLayoutKernel);\n        assert_eq!(config.direction(), Direction::TopToBottom);\n        assert_eq!(config.theme(), Theme::Forest);\n        assert_eq!(config.look(), Look::HandDrawn);\n        Ok(())\n    }\n\n    #[test]\n    fn test_generic_configuration_builder_errors() {\n        let builder = GenericConfigurationBuilder::default();\n        assert!(matches!(builder.title(\"\"), Err(ConfigError::EmptyTitle)));\n    }\n}\n","traces":[{"line":39,"address":[796016],"length":1,"stats":{"Line":1}},{"line":40,"address":[796021],"length":1,"stats":{"Line":1}},{"line":43,"address":[796032],"length":1,"stats":{"Line":1}},{"line":44,"address":[796037],"length":1,"stats":{"Line":1}},{"line":47,"address":[796048],"length":1,"stats":{"Line":1}},{"line":48,"address":[796053],"length":1,"stats":{"Line":1}},{"line":51,"address":[796000],"length":1,"stats":{"Line":1}},{"line":52,"address":[796005],"length":1,"stats":{"Line":1}},{"line":55,"address":[795984],"length":1,"stats":{"Line":1}},{"line":56,"address":[795989],"length":1,"stats":{"Line":1}},{"line":61,"address":[797696],"length":1,"stats":{"Line":1}},{"line":62,"address":[797729],"length":1,"stats":{"Line":1}},{"line":63,"address":[797806],"length":1,"stats":{"Line":1}},{"line":64,"address":[797888],"length":1,"stats":{"Line":1}},{"line":65,"address":[798012],"length":1,"stats":{"Line":1}},{"line":66,"address":[798137],"length":1,"stats":{"Line":1}},{"line":67,"address":[798261],"length":1,"stats":{"Line":1}},{"line":68,"address":[798492,798310],"length":1,"stats":{"Line":0}},{"line":70,"address":[798524,798436],"length":1,"stats":{"Line":1}},{"line":72,"address":[798544],"length":1,"stats":{"Line":1}},{"line":95,"address":[796192],"length":1,"stats":{"Line":1}},{"line":96,"address":[796238],"length":1,"stats":{"Line":4}},{"line":97,"address":[796198],"length":1,"stats":{"Line":1}},{"line":98,"address":[796224],"length":1,"stats":{"Line":1}},{"line":99,"address":[796228],"length":1,"stats":{"Line":1}},{"line":100,"address":[796232],"length":1,"stats":{"Line":1}},{"line":101,"address":[796235],"length":1,"stats":{"Line":4}},{"line":110,"address":[796464],"length":1,"stats":{"Line":1}},{"line":111,"address":[796475],"length":1,"stats":{"Line":1}},{"line":114,"address":[603219,602656,603203],"length":1,"stats":{"Line":2}},{"line":115,"address":[602688,602756],"length":1,"stats":{"Line":9}},{"line":116,"address":[602769,602822],"length":1,"stats":{"Line":14}},{"line":117,"address":[602909],"length":1,"stats":{"Line":1}},{"line":119,"address":[602936,602833],"length":1,"stats":{"Line":1}},{"line":120,"address":[603041],"length":1,"stats":{"Line":6}},{"line":123,"address":[796544],"length":1,"stats":{"Line":1}},{"line":124,"address":[796558],"length":1,"stats":{"Line":1}},{"line":125,"address":[796564],"length":1,"stats":{"Line":1}},{"line":128,"address":[796608],"length":1,"stats":{"Line":1}},{"line":129,"address":[796617],"length":1,"stats":{"Line":1}},{"line":130,"address":[796620],"length":1,"stats":{"Line":1}},{"line":137,"address":[795936],"length":1,"stats":{"Line":1}},{"line":138,"address":[795945],"length":1,"stats":{"Line":1}},{"line":139,"address":[795948],"length":1,"stats":{"Line":1}},{"line":144,"address":[795888],"length":1,"stats":{"Line":1}},{"line":145,"address":[795897],"length":1,"stats":{"Line":1}},{"line":146,"address":[795900],"length":1,"stats":{"Line":1}}],"covered":46,"coverable":47},{"path":["/","home","lucac","github","mermaid-builder","src","shared","generic_diagram.rs"],"content":"//! Submodule defining a generic diagram struct which can be used as a base\n//! for various types of diagrams in Mermaid syntax.\n\nuse std::{fmt::Display, rc::Rc};\n\nuse crate::{\n    shared::{StyleClass, StyleClassError},\n    traits::{\n        Configuration, ConfigurationBuilder, Diagram, DiagramBuilder, Edge, EdgeBuilder, Node,\n        NodeBuilder,\n    },\n};\n\n#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// A generic diagram struct that can be extended for specific diagram types.\npub struct GenericDiagram\u003cNode, Edge, Config\u003e {\n    /// Style classes associated with this diagram.\n    style_classes: Vec\u003cRc\u003cStyleClass\u003e\u003e,\n    /// Nodes in the diagram.\n    nodes: Vec\u003cRc\u003cNode\u003e\u003e,\n    /// Edges in the diagram.\n    edges: Vec\u003cRc\u003cEdge\u003e\u003e,\n    /// Configuration options for the diagram.\n    configuration: Config,\n}\n\nimpl\u003cN: Node + Display, E: Edge\u003cNode = N\u003e + Display, C: Configuration\u003e Diagram\n    for GenericDiagram\u003cN, E, C\u003e\nwhere\n    crate::errors::Error: From\u003c\u003cN::Builder as NodeBuilder\u003e::Error\u003e\n        + From\u003c\u003cE::Builder as EdgeBuilder\u003e::Error\u003e\n        + From\u003c\u003cC::Builder as ConfigurationBuilder\u003e::Error\u003e,\n{\n    type Builder = GenericDiagramBuilder\u003cN, E, C\u003e;\n    type Node = N;\n    type Edge = E;\n    type Configuration = C;\n\n    fn configuration(\u0026self) -\u003e \u0026Self::Configuration {\n        \u0026self.configuration\n    }\n\n    fn nodes(\u0026self) -\u003e impl Iterator\u003cItem = \u0026Self::Node\u003e {\n        self.nodes.iter().map(AsRef::as_ref)\n    }\n\n    fn edges(\u0026self) -\u003e impl Iterator\u003cItem = \u0026Self::Edge\u003e {\n        self.edges.iter().map(AsRef::as_ref)\n    }\n\n    fn style_classes(\u0026self) -\u003e impl Iterator\u003cItem = \u0026StyleClass\u003e {\n        self.style_classes.iter().map(AsRef::as_ref)\n    }\n\n    fn get_node_by_id(\u0026self, id: u64) -\u003e Option\u003cRc\u003cSelf::Node\u003e\u003e {\n        self.nodes.iter().find(|node| node.id() == id).cloned()\n    }\n\n    fn get_style_class_by_name(\u0026self, name: \u0026str) -\u003e Option\u003cRc\u003cStyleClass\u003e\u003e {\n        self.style_classes.iter().find(|sc| sc.name() == name).cloned()\n    }\n}\n\n#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// A builder for creating a generic diagram.\npub struct GenericDiagramBuilder\u003cNode, Edge, Config\u003e {\n    /// Underlying generic diagram.\n    generic_diagram: GenericDiagram\u003cNode, Edge, Config\u003e,\n}\n\nimpl\u003cNode, Edge, Config: Default\u003e Default for GenericDiagramBuilder\u003cNode, Edge, Config\u003e {\n    fn default() -\u003e Self {\n        Self {\n            generic_diagram: GenericDiagram {\n                style_classes: Vec::new(),\n                nodes: Vec::new(),\n                edges: Vec::new(),\n                configuration: Config::default(),\n            },\n        }\n    }\n}\n\nimpl\u003cN: Node + Display, E: Edge\u003cNode = N\u003e + Display, C: Configuration\u003e\n    From\u003cGenericDiagramBuilder\u003cN, E, C\u003e\u003e for GenericDiagram\u003cN, E, C\u003e\n{\n    fn from(builder: GenericDiagramBuilder\u003cN, E, C\u003e) -\u003e Self {\n        builder.generic_diagram\n    }\n}\n\nimpl\u003cN: Node + Display, E: Edge\u003cNode = N\u003e + Display, C: Configuration\u003e DiagramBuilder\n    for GenericDiagramBuilder\u003cN, E, C\u003e\nwhere\n    crate::errors::Error: From\u003c\u003cN::Builder as NodeBuilder\u003e::Error\u003e\n        + From\u003c\u003cE::Builder as EdgeBuilder\u003e::Error\u003e\n        + From\u003c\u003cC::Builder as ConfigurationBuilder\u003e::Error\u003e,\n    GenericDiagram\u003cN, E, C\u003e: Diagram\u003cNode = N, Edge = E, Configuration = C, Builder = Self\u003e,\n{\n    type Diagram = GenericDiagram\u003cN, E, C\u003e;\n    type Node = N;\n    type NodeBuilder = N::Builder;\n    type Edge = E;\n    type EdgeBuilder = E::Builder;\n    type Configuration = C;\n    type ConfigurationBuilder = C::Builder;\n    type Error = crate::errors::Error;\n\n    fn configuration(\n        mut self,\n        configuration: Self::ConfigurationBuilder,\n    ) -\u003e Result\u003cSelf, Self::Error\u003e {\n        self.generic_diagram.configuration =\n            configuration.build().map_err(crate::errors::Error::from)?;\n        Ok(self)\n    }\n\n    fn edge(\u0026mut self, edge: Self::EdgeBuilder) -\u003e Result\u003cRc\u003cSelf::Edge\u003e, Self::Error\u003e {\n        let edge = edge.build().map_err(crate::errors::Error::from)?;\n\n        if !self.generic_diagram.nodes.contains(edge.source()) {\n            return Err(crate::errors::EdgeError::SourceNodeNotFound(\n                edge.source().label().to_owned(),\n            )\n            .into());\n        }\n\n        if !self.generic_diagram.nodes.contains(edge.destination()) {\n            return Err(crate::errors::EdgeError::DestinationNodeNotFound(\n                edge.destination().label().to_owned(),\n            )\n            .into());\n        }\n\n        let rc = Rc::new(edge);\n        self.generic_diagram.edges.push(rc.clone());\n        Ok(rc)\n    }\n\n    fn node(\u0026mut self, mut node: Self::NodeBuilder) -\u003e Result\u003cRc\u003cSelf::Node\u003e, Self::Error\u003e {\n        let number_of_nodes = self.generic_diagram.nodes.len();\n        {\n            use crate::traits::node_builder::NodeBuilder;\n            if node.get_id().is_none() {\n                node = node.id(number_of_nodes as u64);\n            }\n        }\n        let node = node.build().map_err(crate::errors::Error::from)?;\n\n        for class in node.classes() {\n            if !self.generic_diagram.style_classes.iter().any(|sc| sc.name() == class.name()) {\n                return Err(StyleClassError::UnknownClass(class.clone()).into());\n            }\n        }\n\n        let rc = Rc::new(node);\n        self.generic_diagram.nodes.push(rc.clone());\n        Ok(rc)\n    }\n\n    fn nodes(\u0026self) -\u003e impl Iterator\u003cItem = \u0026Rc\u003cSelf::Node\u003e\u003e + '_ {\n        self.generic_diagram.nodes.iter()\n    }\n\n    fn get_node_by_id(\u0026self, id: u64) -\u003e Option\u003cRc\u003cSelf::Node\u003e\u003e {\n        self.generic_diagram.get_node_by_id(id)\n    }\n\n    fn get_style_class_by_name(\u0026self, name: \u0026str) -\u003e Option\u003cRc\u003cStyleClass\u003e\u003e {\n        self.generic_diagram.get_style_class_by_name(name)\n    }\n\n    fn number_of_nodes(\u0026self) -\u003e usize {\n        self.generic_diagram.nodes.len()\n    }\n\n    fn number_of_edges(\u0026self) -\u003e usize {\n        self.generic_diagram.edges.len()\n    }\n\n    fn style_class(\n        \u0026mut self,\n        style_class: super::StyleClassBuilder,\n    ) -\u003e Result\u003cRc\u003cStyleClass\u003e, Self::Error\u003e {\n        let style_class = style_class.build().map_err(crate::errors::Error::from)?;\n\n        if self.generic_diagram.style_classes.iter().any(|sc| sc.name() == style_class.name()) {\n            return Err(StyleClassError::DuplicateClass(style_class.name().to_owned()).into());\n        }\n\n        let rc = Rc::new(style_class);\n        self.generic_diagram.style_classes.push(rc.clone());\n        Ok(rc)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::diagrams::flowchart::{\n        FlowchartConfiguration, FlowchartConfigurationBuilder, FlowchartEdge, FlowchartEdgeBuilder,\n        FlowchartNode, FlowchartNodeBuilder,\n    };\n    use crate::shared::{style_class::Unit, StyleClassBuilder, StyleProperty};\n    use crate::traits::{ConfigurationBuilder, EdgeBuilder, NodeBuilder};\n    use std::rc::Rc;\n\n    #[test]\n    fn test_generic_diagram_builder() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n        let mut builder = GenericDiagramBuilder::\u003c\n            FlowchartNode,\n            FlowchartEdge,\n            FlowchartConfiguration,\n        \u003e::default();\n\n        // Test Node\n        let node_builder = FlowchartNodeBuilder::default().label(\"Node 1\")?.id(1);\n        let node1 = builder.node(node_builder)?;\n        assert_eq!(node1.id(), 1);\n\n        let node_builder2 = FlowchartNodeBuilder::default().label(\"Node 2\")?.id(2);\n        let node2 = builder.node(node_builder2)?;\n        assert_eq!(node2.id(), 2);\n\n        // Test Edge\n        let edge_builder = FlowchartEdgeBuilder::default()\n            .source(node1.clone())?\n            .destination(node2.clone())?\n            .id(1);\n        let edge = builder.edge(edge_builder)?;\n        assert_eq!(edge.source().id(), 1);\n        assert_eq!(edge.destination().id(), 2);\n\n        // Test Config\n        let config_builder = FlowchartConfigurationBuilder::default().title(\"My Diagram\")?;\n        builder = builder.configuration(config_builder)?;\n\n        let diagram: GenericDiagram\u003cFlowchartNode, FlowchartEdge, FlowchartConfiguration\u003e =\n            builder.into();\n\n        assert_eq!(diagram.nodes().count(), 2);\n        assert_eq!(diagram.edges().count(), 1);\n        assert_eq!(diagram.configuration().title(), Some(\"My Diagram\"));\n\n        Ok(())\n    }\n\n    #[test]\n    fn test_generic_diagram_methods() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n        let mut builder = GenericDiagramBuilder::\u003c\n            FlowchartNode,\n            FlowchartEdge,\n            FlowchartConfiguration,\n        \u003e::default();\n\n        let node_builder = FlowchartNodeBuilder::default().label(\"Node 1\")?.id(1);\n        builder.node(node_builder)?;\n\n        // Test Builder methods\n        assert_eq!(builder.number_of_nodes(), 1);\n        assert_eq!(builder.number_of_edges(), 0);\n        assert!(builder.get_node_by_id(1).is_some());\n        assert!(builder.get_node_by_id(2).is_none());\n        assert_eq!(builder.nodes().count(), 1);\n\n        let diagram: GenericDiagram\u003cFlowchartNode, FlowchartEdge, FlowchartConfiguration\u003e =\n            builder.into();\n\n        assert_eq!(diagram.nodes().count(), 1);\n        assert_eq!(diagram.edges().count(), 0);\n        assert!(diagram.get_node_by_id(1).is_some());\n        assert!(diagram.get_node_by_id(2).is_none());\n\n        Ok(())\n    }\n\n    #[test]\n    fn test_style_class_management() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n        let mut builder = GenericDiagramBuilder::\u003c\n            FlowchartNode,\n            FlowchartEdge,\n            FlowchartConfiguration,\n        \u003e::default();\n\n        let style_class_builder = StyleClassBuilder::default()\n            .name(\"test_class\")?\n            .property(StyleProperty::StrokeWidth(Unit::Pixel(1)))?;\n        let style_class = builder.style_class(style_class_builder)?;\n\n        assert_eq!(style_class.name(), \"test_class\");\n\n        // Test Builder methods\n        assert!(builder.get_style_class_by_name(\"test_class\").is_some());\n        assert!(builder.get_style_class_by_name(\"unknown\").is_none());\n\n        // Test duplicate class\n        let style_class_builder_dup = StyleClassBuilder::default()\n            .name(\"test_class\")?\n            .property(StyleProperty::StrokeWidth(Unit::Pixel(1)))?;\n        let result = builder.style_class(style_class_builder_dup);\n        assert!(result.is_err());\n\n        let diagram: GenericDiagram\u003cFlowchartNode, FlowchartEdge, FlowchartConfiguration\u003e =\n            builder.into();\n        assert!(diagram.get_style_class_by_name(\"test_class\").is_some());\n        assert!(diagram.get_style_class_by_name(\"unknown\").is_none());\n        assert_eq!(diagram.style_classes().count(), 1);\n\n        Ok(())\n    }\n\n    #[test]\n    fn test_node_with_unknown_class() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n        let mut builder = GenericDiagramBuilder::\u003c\n            FlowchartNode,\n            FlowchartEdge,\n            FlowchartConfiguration,\n        \u003e::default();\n\n        let class = StyleClassBuilder::default()\n            .name(\"unknown\")?\n            .property(StyleProperty::StrokeWidth(Unit::Pixel(2)))?\n            .build()?;\n\n        let node_builder = FlowchartNodeBuilder::default()\n            .label(\"Node 1\")?\n            .id(1)\n            .style_class(Rc::new(class))?;\n\n        let result = builder.node(node_builder);\n        assert!(result.is_err());\n        Ok(())\n    }\n\n    #[test]\n    fn test_edge_with_unknown_nodes() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n        let mut builder = GenericDiagramBuilder::\u003c\n            FlowchartNode,\n            FlowchartEdge,\n            FlowchartConfiguration,\n        \u003e::default();\n\n        let node1 = Rc::new(\n            FlowchartNodeBuilder::default()\n                .label(\"Node 1\")?\n                .id(1)\n                .build()?,\n        );\n        let node2 = Rc::new(\n            FlowchartNodeBuilder::default()\n                .label(\"Node 2\")?\n                .id(2)\n                .build()?,\n        );\n\n        let edge_builder = FlowchartEdgeBuilder::default()\n            .source(node1)?\n            .destination(node2)?\n            .id(1);\n\n        let result = builder.edge(edge_builder);\n        assert!(result.is_err());\n        Ok(())\n    }\n\n    #[test]\n    fn test_edge_destination_node_not_found() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n        let mut builder = GenericDiagramBuilder::\u003c\n            FlowchartNode,\n            FlowchartEdge,\n            FlowchartConfiguration,\n        \u003e::default();\n\n        let node1_builder = FlowchartNodeBuilder::default().label(\"Node 1\")?.id(1);\n        let node1 = builder.node(node1_builder)?;\n\n        let node2 = Rc::new(\n            FlowchartNodeBuilder::default()\n                .label(\"Node 2\")?\n                .id(2)\n                .build()?,\n        );\n\n        let edge_builder = FlowchartEdgeBuilder::default()\n            .source(node1)?\n            .destination(node2)?\n            .id(1);\n\n        let result = builder.edge(edge_builder);\n        assert!(result.is_err());\n        Ok(())\n    }\n\n    #[test]\n    fn test_node_auto_id() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n        let mut builder = GenericDiagramBuilder::\u003c\n            FlowchartNode,\n            FlowchartEdge,\n            FlowchartConfiguration,\n        \u003e::default();\n\n        let node_builder = FlowchartNodeBuilder::default().label(\"Node 1\")?;\n        let node = builder.node(node_builder)?;\n        assert_eq!(node.id(), 0);\n        \n        let node_builder2 = FlowchartNodeBuilder::default().label(\"Node 2\")?;\n        let node2 = builder.node(node_builder2)?;\n        assert_eq!(node2.id(), 1);\n\n        Ok(())\n    }\n}\n","traces":[{"line":40,"address":[513936,513776,513616],"length":1,"stats":{"Line":1}},{"line":41,"address":[513624,513784,513944],"length":1,"stats":{"Line":1}},{"line":44,"address":[513888,513728,514208],"length":1,"stats":{"Line":1}},{"line":45,"address":[513893,513733,514213],"length":1,"stats":{"Line":1}},{"line":48,"address":[514160,513680,513840],"length":1,"stats":{"Line":1}},{"line":49,"address":[513845,514165,513685],"length":1,"stats":{"Line":1}},{"line":52,"address":[513632,513792,513952],"length":1,"stats":{"Line":1}},{"line":53,"address":[513797,513637,513957],"length":1,"stats":{"Line":1}},{"line":56,"address":[514000],"length":1,"stats":{"Line":1}},{"line":57,"address":[513266,514014,513248],"length":1,"stats":{"Line":4}},{"line":60,"address":[514080],"length":1,"stats":{"Line":1}},{"line":61,"address":[513312,514098,513330],"length":1,"stats":{"Line":3}},{"line":74,"address":[520660,520288,520654],"length":1,"stats":{"Line":8}},{"line":76,"address":[520477],"length":1,"stats":{"Line":8}},{"line":89,"address":[514256],"length":1,"stats":{"Line":1}},{"line":90,"address":[514264],"length":1,"stats":{"Line":1}},{"line":111,"address":[515232,515731],"length":1,"stats":{"Line":1}},{"line":115,"address":[515572,515640],"length":1,"stats":{"Line":2}},{"line":116,"address":[515354,515253,515609],"length":1,"stats":{"Line":2}},{"line":117,"address":[515666],"length":1,"stats":{"Line":1}},{"line":120,"address":[515856,517369,517375],"length":1,"stats":{"Line":3}},{"line":121,"address":[515914],"length":1,"stats":{"Line":3}},{"line":123,"address":[516369,516477],"length":1,"stats":{"Line":8}},{"line":124,"address":[516746,516668],"length":1,"stats":{"Line":2}},{"line":125,"address":[516551,516609],"length":1,"stats":{"Line":2}},{"line":127,"address":[516708],"length":1,"stats":{"Line":1}},{"line":130,"address":[516574,516813],"length":1,"stats":{"Line":6}},{"line":131,"address":[517169,517091],"length":1,"stats":{"Line":2}},{"line":132,"address":[516869,517032],"length":1,"stats":{"Line":2}},{"line":134,"address":[517131],"length":1,"stats":{"Line":1}},{"line":137,"address":[516884,517218],"length":1,"stats":{"Line":2}},{"line":138,"address":[517226,517305],"length":1,"stats":{"Line":2}},{"line":139,"address":[517320],"length":1,"stats":{"Line":1}},{"line":142,"address":[518651,518920,517408],"length":1,"stats":{"Line":1}},{"line":143,"address":[517466,517566],"length":1,"stats":{"Line":2}},{"line":146,"address":[517574,517844],"length":1,"stats":{"Line":2}},{"line":147,"address":[517741],"length":1,"stats":{"Line":1}},{"line":150,"address":[517865,518918,517672],"length":1,"stats":{"Line":8}},{"line":152,"address":[518245,518337,518165],"length":1,"stats":{"Line":15}},{"line":153,"address":[518667,513536,513504,518405],"length":1,"stats":{"Line":2}},{"line":154,"address":[518761],"length":1,"stats":{"Line":1}},{"line":158,"address":[518427],"length":1,"stats":{"Line":4}},{"line":159,"address":[518587,518508],"length":1,"stats":{"Line":8}},{"line":160,"address":[518602],"length":1,"stats":{"Line":4}},{"line":163,"address":[518960],"length":1,"stats":{"Line":1}},{"line":164,"address":[518965],"length":1,"stats":{"Line":1}},{"line":167,"address":[515760],"length":1,"stats":{"Line":1}},{"line":168,"address":[515774],"length":1,"stats":{"Line":1}},{"line":171,"address":[515824],"length":1,"stats":{"Line":1}},{"line":172,"address":[515842],"length":1,"stats":{"Line":1}},{"line":175,"address":[515808],"length":1,"stats":{"Line":1}},{"line":176,"address":[515813],"length":1,"stats":{"Line":1}},{"line":179,"address":[515792],"length":1,"stats":{"Line":1}},{"line":180,"address":[515797],"length":1,"stats":{"Line":1}},{"line":183,"address":[515042,514320,515199],"length":1,"stats":{"Line":1}},{"line":187,"address":[514363],"length":1,"stats":{"Line":1}},{"line":189,"address":[514726,513392,513424,514658],"length":1,"stats":{"Line":4}},{"line":190,"address":[514881,515066],"length":1,"stats":{"Line":2}},{"line":193,"address":[514803,514906],"length":1,"stats":{"Line":2}},{"line":194,"address":[514922,514984],"length":1,"stats":{"Line":2}},{"line":195,"address":[514996],"length":1,"stats":{"Line":1}}],"covered":61,"coverable":61},{"path":["/","home","lucac","github","mermaid-builder","src","shared","generic_edge.rs"],"content":"//! Submodule providing a generic node struct which may be reused across\n//! different diagrams.\n\nuse std::{iter::empty, rc::Rc};\n\nuse crate::{\n    errors::EdgeError,\n    shared::{ArrowShape, LineStyle, StyleClass},\n    traits::{Edge, EdgeBuilder, Node},\n};\n\n#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// Struct representing a generic node in Mermaid diagrams.\npub struct GenericEdge\u003cNode\u003e {\n    /// Label for the node.\n    label: Option\u003cString\u003e,\n    /// The source node of the edge.\n    source: Rc\u003cNode\u003e,\n    /// The destination node of the edge.\n    destination: Rc\u003cNode\u003e,\n    /// The line style of the link.\n    line_style: LineStyle,\n    /// The left arrow shape of the link, if any.\n    left_arrow_shape: Option\u003cArrowShape\u003e,\n    /// The right arrow shape of the link, if any.\n    right_arrow_shape: Option\u003cArrowShape\u003e,\n}\n\nimpl\u003cN: Node\u003e Edge for GenericEdge\u003cN\u003e {\n    type Builder = GenericEdgeBuilder\u003cN\u003e;\n    type Node = N;\n\n    fn label(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n        self.label.as_deref()\n    }\n\n    fn source(\u0026self) -\u003e \u0026Rc\u003cSelf::Node\u003e {\n        \u0026self.source\n    }\n\n    fn destination(\u0026self) -\u003e \u0026Rc\u003cSelf::Node\u003e {\n        \u0026self.destination\n    }\n\n    fn line_style(\u0026self) -\u003e LineStyle {\n        self.line_style\n    }\n\n    fn classes(\u0026self) -\u003e impl Iterator\u003cItem = \u0026StyleClass\u003e {\n        empty()\n    }\n\n    fn left_arrow_shape(\u0026self) -\u003e Option\u003cArrowShape\u003e {\n        self.left_arrow_shape\n    }\n\n    fn right_arrow_shape(\u0026self) -\u003e Option\u003cArrowShape\u003e {\n        self.right_arrow_shape\n    }\n}\n\n#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// Builder for creating a `GenericEdge`.\npub struct GenericEdgeBuilder\u003cNode\u003e {\n    /// Label for the edge.\n    label: Option\u003cString\u003e,\n    /// Source node for the edge.\n    source: Option\u003cRc\u003cNode\u003e\u003e,\n    /// Destination node for the edge.\n    destination: Option\u003cRc\u003cNode\u003e\u003e,\n    /// Line style of the edge.\n    line_style: LineStyle,\n    /// Left arrow shape of the edge, if any.\n    left_arrow_shape: Option\u003cArrowShape\u003e,\n    /// Right arrow shape of the edge, if any.\n    right_arrow_shape: Option\u003cArrowShape\u003e,\n}\n\nimpl\u003cNode\u003e Default for GenericEdgeBuilder\u003cNode\u003e {\n    fn default() -\u003e Self {\n        Self {\n            label: None,\n            source: None,\n            destination: None,\n            line_style: LineStyle::default(),\n            left_arrow_shape: None,\n            right_arrow_shape: None,\n        }\n    }\n}\n\nimpl\u003cN\u003e TryFrom\u003cGenericEdgeBuilder\u003cN\u003e\u003e for GenericEdge\u003cN\u003e {\n    type Error = EdgeError;\n\n    fn try_from(builder: GenericEdgeBuilder\u003cN\u003e) -\u003e Result\u003cSelf, Self::Error\u003e {\n        Ok(GenericEdge {\n            label: builder.label,\n            source: builder.source.ok_or(EdgeError::MissingSource)?,\n            destination: builder.destination.ok_or(EdgeError::MissingDestination)?,\n            line_style: builder.line_style,\n            left_arrow_shape: builder.left_arrow_shape,\n            right_arrow_shape: builder.right_arrow_shape,\n        })\n    }\n}\n\nimpl\u003cN: Node\u003e EdgeBuilder for GenericEdgeBuilder\u003cN\u003e {\n    type Node = N;\n    type Edge = GenericEdge\u003cN\u003e;\n    type Error = EdgeError;\n\n    fn build(self) -\u003e Result\u003cSelf::Edge, Self::Error\u003e {\n        self.try_into()\n    }\n\n    fn label\u003cS: ToString\u003e(mut self, label: S) -\u003e Result\u003cSelf, Self::Error\u003e {\n        let label = label.to_string();\n        if label.is_empty() {\n            return Err(EdgeError::EmptyLabel);\n        }\n        self.label = Some(label);\n        Ok(self)\n    }\n\n    fn source(mut self, source: Rc\u003cSelf::Node\u003e) -\u003e Result\u003cSelf, Self::Error\u003e {\n        self.source = Some(source);\n        Ok(self)\n    }\n\n    fn destination(mut self, destination: Rc\u003cSelf::Node\u003e) -\u003e Result\u003cSelf, Self::Error\u003e {\n        self.destination = Some(destination);\n        Ok(self)\n    }\n\n    fn line_style(mut self, style: LineStyle) -\u003e Self {\n        self.line_style = style;\n        self\n    }\n    fn left_arrow_shape(mut self, shape: ArrowShape) -\u003e Result\u003cSelf, Self::Error\u003e {\n        if !Self::Node::is_compatible_arrow_shape(shape) {\n            return Err(EdgeError::IncompatibleLeftArrowShape(shape));\n        }\n        self.left_arrow_shape = Some(shape);\n        Ok(self)\n    }\n    fn right_arrow_shape(mut self, shape: ArrowShape) -\u003e Result\u003cSelf, Self::Error\u003e {\n        if !Self::Node::is_compatible_arrow_shape(shape) {\n            return Err(EdgeError::IncompatibleRightArrowShape(shape));\n        }\n        self.right_arrow_shape = Some(shape);\n        Ok(self)\n    }\n}\n","traces":[{"line":34,"address":[225248,225344,225152],"length":1,"stats":{"Line":3}},{"line":35,"address":[225157,225253,225349],"length":1,"stats":{"Line":3}},{"line":38,"address":[225168,225360,225264],"length":1,"stats":{"Line":6}},{"line":39,"address":[225176,225272,225368],"length":1,"stats":{"Line":6}},{"line":42,"address":[225296,225104,225200],"length":1,"stats":{"Line":5}},{"line":43,"address":[225112,225208,225304],"length":1,"stats":{"Line":5}},{"line":46,"address":[225280,225088,225184],"length":1,"stats":{"Line":4}},{"line":47,"address":[225189,225093,225285],"length":1,"stats":{"Line":4}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[225120,225312,225216],"length":1,"stats":{"Line":3}},{"line":55,"address":[225125,225221,225317],"length":1,"stats":{"Line":3}},{"line":58,"address":[225136,225232,225328],"length":1,"stats":{"Line":3}},{"line":59,"address":[225237,225141,225333],"length":1,"stats":{"Line":3}},{"line":82,"address":[233888,234078,234256,234304,234048,234464,234286,234096,234494],"length":1,"stats":{"Line":4}},{"line":87,"address":[234351,234143,233935],"length":1,"stats":{"Line":7}},{"line":97,"address":[226146,227136,226256,227026,227906,227097,226217,225376,227977],"length":1,"stats":{"Line":6}},{"line":98,"address":[227158,227680,226278,226800,225920,225398],"length":1,"stats":{"Line":15}},{"line":99,"address":[227174,225414,226294],"length":1,"stats":{"Line":7}},{"line":100,"address":[225431,225516,227276,226396,227191,226311],"length":1,"stats":{"Line":14}},{"line":101,"address":[226541,225757,227421,227517,225661,226637],"length":1,"stats":{"Line":16}},{"line":102,"address":[226791,227671,225911],"length":1,"stats":{"Line":8}},{"line":103,"address":[226794,225914,227674],"length":1,"stats":{"Line":8}},{"line":104,"address":[225917,226797,227677],"length":1,"stats":{"Line":8}},{"line":114,"address":[229616],"length":1,"stats":{"Line":1}},{"line":115,"address":[229630],"length":1,"stats":{"Line":1}},{"line":118,"address":[224986,223120,225054,223776,224330,223742,223674,224398,224432],"length":1,"stats":{"Line":4}},{"line":119,"address":[223808,224548,223892,223236,223152,224464],"length":1,"stats":{"Line":8}},{"line":120,"address":[224614,223905,223302,223958,224561,223249],"length":1,"stats":{"Line":8}},{"line":121,"address":[223391,224047,224703],"length":1,"stats":{"Line":0}},{"line":123,"address":[223313,223969,224625,224107,224763,223451],"length":1,"stats":{"Line":4}},{"line":124,"address":[223557,224213,224869],"length":1,"stats":{"Line":4}},{"line":127,"address":[229821,228877,228736,229680,230560,230701],"length":1,"stats":{"Line":4}},{"line":128,"address":[230596,230652,228828,229772,229716,228772],"length":1,"stats":{"Line":14}},{"line":129,"address":[229776,230656,228832],"length":1,"stats":{"Line":9}},{"line":132,"address":[230029,229888,228064,228205,229085,228944],"length":1,"stats":{"Line":9}},{"line":133,"address":[228100,229036,229980,228156,228980,229924],"length":1,"stats":{"Line":15}},{"line":134,"address":[228160,229040,229984],"length":1,"stats":{"Line":9}},{"line":137,"address":[228896,229840,228016],"length":1,"stats":{"Line":5}},{"line":138,"address":[228034,228914,229858],"length":1,"stats":{"Line":5}},{"line":139,"address":[228917,229861,228037],"length":1,"stats":{"Line":5}},{"line":141,"address":[228224,229339,229104,230048,230283,228459],"length":1,"stats":{"Line":5}},{"line":142,"address":[228259,229194,230138,230083,228314,229139],"length":1,"stats":{"Line":10}},{"line":143,"address":[230158,228334,229214],"length":1,"stats":{"Line":0}},{"line":145,"address":[228408,229288,230232],"length":1,"stats":{"Line":5}},{"line":146,"address":[228411,229291,230235],"length":1,"stats":{"Line":5}},{"line":148,"address":[228480,229360,228715,229595,230304,230539],"length":1,"stats":{"Line":5}},{"line":149,"address":[230394,228570,228515,229450,229395,230339],"length":1,"stats":{"Line":10}},{"line":150,"address":[230414,228590,229470],"length":1,"stats":{"Line":0}},{"line":152,"address":[228664,229544,230488],"length":1,"stats":{"Line":5}},{"line":153,"address":[228667,229547,230491],"length":1,"stats":{"Line":5}}],"covered":46,"coverable":51},{"path":["/","home","lucac","github","mermaid-builder","src","shared","generic_node.rs"],"content":"//! Submodule providing a generic node struct which may be reused across\n//! different diagrams.\n\nuse std::rc::Rc;\n\nuse crate::{\n    errors::NodeError,\n    shared::{StyleClass, StyleClassError, StyleProperty},\n    traits::{Node, NodeBuilder},\n};\n\n#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// Struct representing a generic node in Mermaid diagrams.\npub(crate) struct GenericNode {\n    /// Unique identifier for the node.\n    id: u64,\n    /// Label for the node.\n    label: String,\n    /// Classes associated with the node, used for styling.\n    classes: Vec\u003cRc\u003cStyleClass\u003e\u003e,\n    /// Style properties for the node.\n    style: Vec\u003cStyleProperty\u003e,\n}\n\nimpl Node for GenericNode {\n    type Builder = GenericNodeBuilder;\n\n    fn id(\u0026self) -\u003e u64 {\n        self.id\n    }\n\n    fn label(\u0026self) -\u003e \u0026str {\n        \u0026self.label\n    }\n\n    fn classes(\u0026self) -\u003e impl Iterator\u003cItem = \u0026StyleClass\u003e {\n        self.classes.iter().map(AsRef::as_ref)\n    }\n\n    fn styles(\u0026self) -\u003e impl Iterator\u003cItem = \u0026StyleProperty\u003e {\n        self.style.iter()\n    }\n\n    fn is_compatible_arrow_shape(_shape: super::ArrowShape) -\u003e bool {\n        true\n    }\n}\n\n#[derive(Debug, Default, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// Builder for creating a `GenericNode`.\npub(crate) struct GenericNodeBuilder {\n    /// Unique identifier for the node.\n    id: Option\u003cu64\u003e,\n    /// Label for the node.\n    label: Option\u003cString\u003e,\n    /// Classes associated with the node, used for styling.\n    classes: Vec\u003cRc\u003cStyleClass\u003e\u003e,\n    /// Style properties for the node.\n    style: Vec\u003cStyleProperty\u003e,\n}\n\nimpl TryFrom\u003cGenericNodeBuilder\u003e for GenericNode {\n    type Error = NodeError;\n\n    fn try_from(builder: GenericNodeBuilder) -\u003e Result\u003cSelf, Self::Error\u003e {\n        let id = builder.id.ok_or(NodeError::MissingId)?;\n        let label = builder.label.ok_or(NodeError::MissingLabel)?;\n\n        Ok(GenericNode { id, label, classes: builder.classes, style: builder.style })\n    }\n}\n\nimpl NodeBuilder for GenericNodeBuilder {\n    type Node = GenericNode;\n    type Error = NodeError;\n\n    fn build(self) -\u003e Result\u003cSelf::Node, Self::Error\u003e {\n        self.try_into()\n    }\n\n    fn id(mut self, id: u64) -\u003e Self {\n        self.id = Some(id);\n        self\n    }\n\n    fn get_id(\u0026self) -\u003e Option\u003cu64\u003e {\n        self.id\n    }\n\n    fn label\u003cS: ToString\u003e(mut self, label: S) -\u003e Result\u003cSelf, Self::Error\u003e {\n        let label = label.to_string();\n        if label.is_empty() {\n            return Err(crate::errors::NodeError::EmptyLabel);\n        }\n\n        self.label = Some(label);\n        Ok(self)\n    }\n\n    fn get_label(\u0026self) -\u003e Option\u003c\u0026String\u003e {\n        self.label.as_ref()\n    }\n\n    fn style_class(mut self, style_class: Rc\u003cStyleClass\u003e) -\u003e Result\u003cSelf, StyleClassError\u003e {\n        if self.classes.iter().any(|c| c.name() == style_class.name()) {\n            return Err(StyleClassError::DuplicateClass(style_class.name().to_owned()));\n        }\n\n        self.classes.push(style_class);\n        Ok(self)\n    }\n\n    fn style_property(mut self, property: StyleProperty) -\u003e Result\u003cSelf, StyleClassError\u003e {\n        if self.style.iter().any(|p| p.is_same_type(property)) {\n            return Err(StyleClassError::DuplicateProperty(property));\n        }\n\n        self.style.push(property);\n        Ok(self)\n    }\n\n    fn style_properties(\u0026self) -\u003e impl Iterator\u003cItem = \u0026StyleProperty\u003e {\n        self.style.iter()\n    }\n}\n","traces":[{"line":29,"address":[191984],"length":1,"stats":{"Line":1}},{"line":30,"address":[191989],"length":1,"stats":{"Line":1}},{"line":33,"address":[192000],"length":1,"stats":{"Line":1}},{"line":34,"address":[192005],"length":1,"stats":{"Line":1}},{"line":37,"address":[192048],"length":1,"stats":{"Line":5}},{"line":38,"address":[192053],"length":1,"stats":{"Line":5}},{"line":41,"address":[192016],"length":1,"stats":{"Line":2}},{"line":42,"address":[192021],"length":1,"stats":{"Line":1}},{"line":45,"address":[191968],"length":1,"stats":{"Line":0}},{"line":67,"address":[194976,195923],"length":1,"stats":{"Line":12}},{"line":68,"address":[195101,195001,195794],"length":1,"stats":{"Line":26}},{"line":69,"address":[195243,195780],"length":1,"stats":{"Line":15}},{"line":71,"address":[195525],"length":1,"stats":{"Line":15}},{"line":79,"address":[193296],"length":1,"stats":{"Line":0}},{"line":80,"address":[193309],"length":1,"stats":{"Line":0}},{"line":83,"address":[193248],"length":1,"stats":{"Line":4}},{"line":84,"address":[193265],"length":1,"stats":{"Line":4}},{"line":85,"address":[193276],"length":1,"stats":{"Line":10}},{"line":88,"address":[193360],"length":1,"stats":{"Line":1}},{"line":89,"address":[193365],"length":1,"stats":{"Line":4}},{"line":92,"address":[274832,275390,275462],"length":1,"stats":{"Line":14}},{"line":93,"address":[274864,274948],"length":1,"stats":{"Line":27}},{"line":94,"address":[274961,275014],"length":1,"stats":{"Line":18}},{"line":95,"address":[275107],"length":1,"stats":{"Line":0}},{"line":98,"address":[275025,275165],"length":1,"stats":{"Line":5}},{"line":99,"address":[275273],"length":1,"stats":{"Line":14}},{"line":102,"address":[193376],"length":1,"stats":{"Line":0}},{"line":103,"address":[193381],"length":1,"stats":{"Line":0}},{"line":106,"address":[192727,192224],"length":1,"stats":{"Line":1}},{"line":107,"address":[192259,192347],"length":1,"stats":{"Line":3}},{"line":108,"address":[192525,192449],"length":1,"stats":{"Line":0}},{"line":111,"address":[192420],"length":1,"stats":{"Line":1}},{"line":112,"address":[192466],"length":1,"stats":{"Line":2}},{"line":115,"address":[192752,193187],"length":1,"stats":{"Line":1}},{"line":116,"address":[192886,192818],"length":1,"stats":{"Line":2}},{"line":117,"address":[193052],"length":1,"stats":{"Line":0}},{"line":120,"address":[192959],"length":1,"stats":{"Line":1}},{"line":121,"address":[193133],"length":1,"stats":{"Line":1}},{"line":124,"address":[193216],"length":1,"stats":{"Line":0}},{"line":125,"address":[193221],"length":1,"stats":{"Line":0}}],"covered":30,"coverable":40},{"path":["/","home","lucac","github","mermaid-builder","src","shared","javascript_function_signature.rs"],"content":"//! Submodule defining a JavaScript function signature.\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","lucac","github","mermaid-builder","src","shared","javascript_types.rs"],"content":"//! Submodule defining an enumeration for JavaScript types which may be employed\n//! as the signature of a JavaScript function call in Mermaid diagrams.\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","lucac","github","mermaid-builder","src","shared","line_style.rs"],"content":"//! Submodule providing an enumeration for the possible link line styles in\n//! Mermaid diagrams.\n\n#[derive(Default, Copy, Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// Represents the line style of links in Mermaid diagrams.\npub enum LineStyle {\n    /// A normal line style.\n    #[default]\n    Solid,\n    /// A Thick line style.\n    Thick,\n    /// A Dashed line style.\n    Dashed,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","lucac","github","mermaid-builder","src","shared","style_class","builder.rs"],"content":"//! Submodule providing a builder struct for style classes in Mermaid diagrams.\n\nuse crate::shared::{\n    StyleClass,\n    style_class::{StyleClassError, StyleProperty},\n};\n\n#[derive(Default, Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// Builder struct for creating style classes in Mermaid diagrams.\n///\n/// # Example\n///\n/// ```\n/// use mermaid_builder::prelude::*;\n///\n/// let style_class = StyleClassBuilder::default()\n///     .name(\"myClass\")\n///     .unwrap()\n///     .property(StyleProperty::Fill(Color::from((255, 0, 0))))\n///     .unwrap()\n///     .build()\n///     .unwrap();\n/// ```\npub struct StyleClassBuilder {\n    /// The name of the style class.\n    name: Option\u003cString\u003e,\n    /// The properties associated with the style class.\n    properties: Vec\u003cStyleProperty\u003e,\n}\n\nimpl TryFrom\u003cStyleClassBuilder\u003e for StyleClass {\n    type Error = StyleClassError;\n\n    fn try_from(builder: StyleClassBuilder) -\u003e Result\u003cSelf, Self::Error\u003e {\n        if builder.properties.is_empty() {\n            return Err(StyleClassError::MissingProperties);\n        }\n\n        Ok(StyleClass {\n            name: builder.name.ok_or(StyleClassError::MissingName)?,\n            properties: builder.properties,\n        })\n    }\n}\n\nimpl StyleClassBuilder {\n    /// Sets the name of the style class.\n    ///\n    /// # Arguments\n    ///\n    /// * `name` - A string slice that holds the name of the style class.\n    ///\n    /// # Errors\n    ///\n    /// * Returns `StyleClassError::EmptyName` if the provided name is empty.\n    pub fn name(mut self, name: impl Into\u003cString\u003e) -\u003e Result\u003cSelf, StyleClassError\u003e {\n        let name = name.into();\n\n        if name.is_empty() {\n            return Err(StyleClassError::EmptyName);\n        }\n\n        self.name = Some(name);\n\n        Ok(self)\n    }\n\n    /// Adds a property to the style class.\n    ///\n    /// # Arguments\n    ///\n    /// * `property` - A `StyleProperty` that will be added to the style class.\n    ///\n    /// # Errors\n    ///\n    /// * Returns `StyleClassError::DuplicateProperty` if the property is\n    ///   already present.\n    pub fn property(mut self, property: StyleProperty) -\u003e Result\u003cSelf, StyleClassError\u003e {\n        if self.properties.contains(\u0026property) {\n            return Err(StyleClassError::DuplicateProperty(property));\n        }\n\n        self.properties.push(property);\n        Ok(self)\n    }\n\n    /// Builds the style class.\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if the style class cannot be built.\n    pub fn build(self) -\u003e Result\u003cStyleClass, StyleClassError\u003e {\n        self.try_into()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::shared::style_class::color::Color;\n\n    #[test]\n    fn test_style_class_builder() -\u003e Result\u003c(), StyleClassError\u003e {\n        let style_class = StyleClassBuilder::default()\n            .name(\"myClass\")?\n            .property(StyleProperty::Fill(Color::from((255, 0, 0))))?\n            .property(StyleProperty::Stroke(Color::from((0, 0, 255))))?\n            .build()?;\n\n        assert_eq!(style_class.name, \"myClass\");\n        assert_eq!(style_class.properties.len(), 2);\n        assert!(style_class.properties.contains(\u0026StyleProperty::Fill(Color::from((255, 0, 0)))));\n        assert!(style_class.properties.contains(\u0026StyleProperty::Stroke(Color::from((0, 0, 255)))));\n        Ok(())\n    }\n\n    #[test]\n    fn test_style_class_builder_errors() {\n        let builder = StyleClassBuilder::default();\n        assert!(matches!(builder.name(\"\"), Err(StyleClassError::EmptyName)));\n\n        let builder = StyleClassBuilder::default().name(\"myClass\").unwrap();\n        assert!(matches!(builder.build(), Err(StyleClassError::MissingProperties)));\n\n        let builder = StyleClassBuilder::default()\n            .name(\"myClass\")\n            .unwrap()\n            .property(StyleProperty::Fill(Color::from((255, 0, 0))))\n            .unwrap();\n        assert!(matches!(\n            builder.property(StyleProperty::Fill(Color::from((255, 0, 0)))),\n            Err(StyleClassError::DuplicateProperty(_))\n        ));\n    }\n}\n","traces":[{"line":35,"address":[527456,528198],"length":1,"stats":{"Line":1}},{"line":36,"address":[527572,527484],"length":1,"stats":{"Line":2}},{"line":37,"address":[527668],"length":1,"stats":{"Line":1}},{"line":40,"address":[528005],"length":1,"stats":{"Line":6}},{"line":41,"address":[527582,527735,528127],"length":1,"stats":{"Line":4}},{"line":42,"address":[527962],"length":1,"stats":{"Line":3}},{"line":57,"address":[377832,377248],"length":1,"stats":{"Line":6}},{"line":58,"address":[377312,377376],"length":1,"stats":{"Line":14}},{"line":60,"address":[377442,377389],"length":1,"stats":{"Line":15}},{"line":61,"address":[377548],"length":1,"stats":{"Line":1}},{"line":64,"address":[377453,377611],"length":1,"stats":{"Line":3}},{"line":66,"address":[377715],"length":1,"stats":{"Line":7}},{"line":79,"address":[379552,379947],"length":1,"stats":{"Line":3}},{"line":80,"address":[379618,379687],"length":1,"stats":{"Line":10}},{"line":81,"address":[379802],"length":1,"stats":{"Line":1}},{"line":84,"address":[379713],"length":1,"stats":{"Line":3}},{"line":85,"address":[379883],"length":1,"stats":{"Line":3}},{"line":93,"address":[379488],"length":1,"stats":{"Line":1}},{"line":94,"address":[379502],"length":1,"stats":{"Line":1}}],"covered":19,"coverable":19},{"path":["/","home","lucac","github","mermaid-builder","src","shared","style_class","color.rs"],"content":"//! Submodule defining the `Color` struct for Mermaid diagrams.\n\nuse colorsys::{Hsl, Rgb};\n\n/// Represents a color in the Mermaid diagram style class.\n#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\npub struct Color {\n    /// Red component of the color (0-255).\n    red: u8,\n    /// Green component of the color (0-255).\n    green: u8,\n    /// Blue component of the color (0-255).\n    blue: u8,\n}\n\nimpl From\u003c(u8, u8, u8)\u003e for Color {\n    fn from(rgb: (u8, u8, u8)) -\u003e Self {\n        Color { red: rgb.0, green: rgb.1, blue: rgb.2 }\n    }\n}\n\nimpl From\u003cRgb\u003e for Color {\n    #[allow(clippy::cast_possible_truncation)]\n    #[allow(clippy::cast_sign_loss)]\n    fn from(rgb: Rgb) -\u003e Self {\n        Color { red: rgb.red() as u8, green: rgb.green() as u8, blue: rgb.blue() as u8 }\n    }\n}\n\nimpl From\u003cHsl\u003e for Color {\n    fn from(hsl: Hsl) -\u003e Self {\n        let rgb = Rgb::from(hsl);\n        Color::from(rgb)\n    }\n}\n\nimpl From\u003cColor\u003e for Rgb {\n    fn from(color: Color) -\u003e Self {\n        Rgb::new(f64::from(color.red), f64::from(color.green), f64::from(color.blue), None)\n    }\n}\n\nimpl From\u003cColor\u003e for Hsl {\n    fn from(color: Color) -\u003e Self {\n        let rgb: Rgb = color.into();\n        Hsl::from(rgb)\n    }\n}\n\nimpl Color {\n    #[must_use]\n    /// Returns a new pastel red color.\n    pub fn pastel_red() -\u003e Self {\n        Color { red: 240, green: 116, blue: 108 }\n    }\n\n    #[must_use]\n    /// Returns a new pastel blue color.\n    pub fn pastel_blue() -\u003e Self {\n        Color { red: 108, green: 116, blue: 240 }\n    }\n\n    #[must_use]\n    /// Returns a new pastel cyan color.\n    pub fn pastel_cyan() -\u003e Self {\n        Color { red: 167, green: 239, blue: 240 }\n    }\n\n    #[must_use]\n    /// Returns the color as a hexadecimal string.\n    pub fn to_hex(self) -\u003e String {\n        format!(\"#{:02x}{:02x}{:02x}\", self.red, self.green, self.blue)\n    }\n\n    #[must_use]\n    /// Returns `n` maximally distinct colors.\n    ///\n    /// # Arguments\n    ///\n    /// * `n` - The number of distinct colors to generate.\n    /// * `saturation` - The saturation of the colors (0-100).\n    /// * `lightness` - The lightness of the colors (0-100).\n    pub fn maximally_distinct(n: u16, saturation: u8, lightness: u8) -\u003e Vec\u003cColor\u003e {\n        let mut colors = Vec::with_capacity(usize::from(n));\n        let saturation = f64::from(saturation);\n        let lightness = f64::from(lightness);\n        for i in 0..n {\n            let hue = f64::from(i) * 360.0 / f64::from(n);\n            let hsl = Hsl::new(hue, saturation, lightness, None);\n            colors.push(hsl.into());\n        }\n        colors\n    }\n\n    #[must_use]\n    /// Returns the color darkened by the provided amount (0-100).\n    pub fn darken(self, amount: u8) -\u003e Color {\n        let hsl: Hsl = self.into();\n        let new_lightness = (hsl.lightness() - f64::from(amount)).max(0.0);\n        let new_hsl = Hsl::new(hsl.hue(), hsl.saturation(), new_lightness, None);\n        new_hsl.into()\n    }\n\n    #[must_use]\n    /// Returns the color lightened by the provided amount (0-100).\n    pub fn lighten(self, amount: u8) -\u003e Color {\n        let hsl: Hsl = self.into();\n        let new_lightness = (hsl.lightness() + f64::from(amount)).min(100.0);\n        let new_hsl = Hsl::new(hsl.hue(), hsl.saturation(), new_lightness, None);\n        new_hsl.into()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_color_from_tuple() {\n        let color = Color::from((255, 0, 0));\n        assert_eq!(color.red, 255);\n        assert_eq!(color.green, 0);\n        assert_eq!(color.blue, 0);\n    }\n\n    #[test]\n    fn test_color_to_hex() {\n        let color = Color::from((255, 0, 0));\n        assert_eq!(color.to_hex(), \"#ff0000\");\n    }\n\n    #[test]\n    fn test_pastel_colors() {\n        let red = Color::pastel_red();\n        assert_eq!(red.to_hex(), \"#f0746c\");\n\n        let blue = Color::pastel_blue();\n        assert_eq!(blue.to_hex(), \"#6c74f0\");\n\n        let cyan = Color::pastel_cyan();\n        assert_eq!(cyan.to_hex(), \"#a7eff0\");\n    }\n\n    #[test]\n    fn test_maximally_distinct() {\n        let colors = Color::maximally_distinct(3, 100, 50);\n        assert_eq!(colors.len(), 3);\n        // Check if colors are distinct enough (basic check)\n        assert_ne!(colors[0], colors[1]);\n        assert_ne!(colors[1], colors[2]);\n        assert_ne!(colors[0], colors[2]);\n    }\n\n    #[test]\n    fn test_darken_lighten() {\n        let color = Color::from((100, 100, 100));\n        let darkened = color.darken(10);\n        let lightened = color.lighten(10);\n\n        // Converting to HSL to check lightness would be ideal, but checking inequality\n        // is a start\n        assert_ne!(color, darkened);\n        assert_ne!(color, lightened);\n    }\n}\n","traces":[{"line":18,"address":[608704],"length":1,"stats":{"Line":7}},{"line":19,"address":[608740],"length":1,"stats":{"Line":7}},{"line":26,"address":[609504],"length":1,"stats":{"Line":2}},{"line":27,"address":[609512],"length":1,"stats":{"Line":2}},{"line":32,"address":[608848],"length":1,"stats":{"Line":2}},{"line":33,"address":[608855],"length":1,"stats":{"Line":2}},{"line":34,"address":[608939],"length":1,"stats":{"Line":2}},{"line":39,"address":[216336],"length":1,"stats":{"Line":1}},{"line":40,"address":[216385],"length":1,"stats":{"Line":1}},{"line":45,"address":[365696],"length":1,"stats":{"Line":1}},{"line":46,"address":[365749],"length":1,"stats":{"Line":1}},{"line":47,"address":[365817],"length":1,"stats":{"Line":1}},{"line":72,"address":[607920],"length":1,"stats":{"Line":1}},{"line":73,"address":[607972],"length":1,"stats":{"Line":1}},{"line":84,"address":[606704,607418,607412],"length":1,"stats":{"Line":1}},{"line":85,"address":[606759],"length":1,"stats":{"Line":1}},{"line":86,"address":[606784,606847],"length":1,"stats":{"Line":2}},{"line":87,"address":[606856],"length":1,"stats":{"Line":1}},{"line":88,"address":[606994,606892],"length":1,"stats":{"Line":2}},{"line":89,"address":[607081,607005,606989],"length":1,"stats":{"Line":3}},{"line":90,"address":[607144],"length":1,"stats":{"Line":1}},{"line":91,"address":[607167],"length":1,"stats":{"Line":1}},{"line":93,"address":[607028],"length":1,"stats":{"Line":1}},{"line":98,"address":[607440],"length":1,"stats":{"Line":1}},{"line":99,"address":[607497],"length":1,"stats":{"Line":1}},{"line":100,"address":[607599],"length":1,"stats":{"Line":1}},{"line":101,"address":[607667],"length":1,"stats":{"Line":1}},{"line":102,"address":[607732],"length":1,"stats":{"Line":1}},{"line":107,"address":[608208],"length":1,"stats":{"Line":1}},{"line":108,"address":[608265],"length":1,"stats":{"Line":1}},{"line":109,"address":[608367],"length":1,"stats":{"Line":1}},{"line":110,"address":[608440],"length":1,"stats":{"Line":1}},{"line":111,"address":[608505],"length":1,"stats":{"Line":1}}],"covered":33,"coverable":33},{"path":["/","home","lucac","github","mermaid-builder","src","shared","style_class","error.rs"],"content":"//! Submodule defining the error enumeration which describes errors\n//! which may happen while creating style classes in Mermaid diagrams.\n\nuse thiserror::Error;\n\nuse crate::shared::{StyleClass, style_class::StyleProperty};\n\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Error)]\n/// Enum representing the different types of errors that can occur when\n/// creating or using style classes in Mermaid diagrams.\npub enum StyleClassError {\n    /// The name of the style class is empty.\n    #[error(\"Style class name cannot be empty.\")]\n    EmptyName,\n    /// The style class was duplicated.\n    #[error(\"Duplicate style class: `{0}`\")]\n    DuplicateClass(String),\n    /// The property was duplicated.\n    #[error(\"Duplicate property found: `{0}`\")]\n    DuplicateProperty(StyleProperty),\n    /// The style class is unknown in the context of the diagram.\n    #[error(\"Unknown style class: `{}`\", .0.name())]\n    UnknownClass(StyleClass),\n    /// The name of the style class is missing.\n    #[error(\"Style class name is missing.\")]\n    MissingName,\n    /// The properties of the style class are missing.\n    #[error(\"Style class properties are missing.\")]\n    MissingProperties,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","lucac","github","mermaid-builder","src","shared","style_class","font_style.rs"],"content":"//! Submodule providing the enumeration `FontStyle` which defines\n//! different font styles that can be applied to text in Mermaid diagrams.\n\nuse std::fmt::Display;\n\n#[derive(Default, Copy, Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// Represents different font styles that can be applied to text in Mermaid\n/// diagrams.\npub enum FontStyle {\n    /// Normal font style.\n    #[default]\n    Normal,\n    /// Italic font style.\n    Italic,\n    /// Oblique font style.\n    Oblique,\n}\n\nimpl Display for FontStyle {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            FontStyle::Normal =\u003e write!(f, \"normal\"),\n            FontStyle::Italic =\u003e write!(f, \"italic\"),\n            FontStyle::Oblique =\u003e write!(f, \"oblique\"),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_font_style_display() {\n        assert_eq!(format!(\"{}\", FontStyle::Normal), \"normal\");\n        assert_eq!(format!(\"{}\", FontStyle::Italic), \"italic\");\n        assert_eq!(format!(\"{}\", FontStyle::Oblique), \"oblique\");\n    }\n}\n","traces":[{"line":21,"address":[274112],"length":1,"stats":{"Line":1}},{"line":22,"address":[274130],"length":1,"stats":{"Line":1}},{"line":23,"address":[274162],"length":1,"stats":{"Line":1}},{"line":24,"address":[274199],"length":1,"stats":{"Line":1}},{"line":25,"address":[274236],"length":1,"stats":{"Line":1}}],"covered":5,"coverable":5},{"path":["/","home","lucac","github","mermaid-builder","src","shared","style_class","font_weight.rs"],"content":"//! Submodule providing the `FontWeight` enum used in Mermaid diagrams.\n\nuse std::fmt::Display;\n\n#[derive(Default, Copy, Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// Represents different font weights that can be applied to text in Mermaid\n/// diagrams.\npub enum FontWeight {\n    /// Normal font weight.\n    #[default]\n    Normal,\n    /// Bold font weight.\n    Bold,\n    /// Bolder font weight.\n    Bolder,\n    /// Lighter font weight.\n    Lighter,\n    /// A specific numeric font weight (e.g., 100, 200, ..., 900).\n    Number(u16),\n}\n\nimpl Display for FontWeight {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            FontWeight::Normal =\u003e write!(f, \"normal\"),\n            FontWeight::Bold =\u003e write!(f, \"bold\"),\n            FontWeight::Bolder =\u003e write!(f, \"bolder\"),\n            FontWeight::Lighter =\u003e write!(f, \"lighter\"),\n            FontWeight::Number(value) =\u003e write!(f, \"{value}\"),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_font_weight_display() {\n        assert_eq!(format!(\"{}\", FontWeight::Normal), \"normal\");\n        assert_eq!(format!(\"{}\", FontWeight::Bold), \"bold\");\n        assert_eq!(format!(\"{}\", FontWeight::Bolder), \"bolder\");\n        assert_eq!(format!(\"{}\", FontWeight::Lighter), \"lighter\");\n        assert_eq!(format!(\"{}\", FontWeight::Number(400)), \"400\");\n    }\n}\n","traces":[{"line":24,"address":[568096],"length":1,"stats":{"Line":1}},{"line":25,"address":[568120],"length":1,"stats":{"Line":1}},{"line":26,"address":[568151],"length":1,"stats":{"Line":1}},{"line":27,"address":[568192],"length":1,"stats":{"Line":1}},{"line":28,"address":[568233],"length":1,"stats":{"Line":1}},{"line":29,"address":[568274],"length":1,"stats":{"Line":1}},{"line":30,"address":[568317],"length":1,"stats":{"Line":1}}],"covered":7,"coverable":7},{"path":["/","home","lucac","github","mermaid-builder","src","shared","style_class","style_properties.rs"],"content":"//! Enumeration of style properties which may be applied to nodes in a Mermaid\n//! diagram.\n\nuse std::fmt::Display;\n\nuse crate::shared::style_class::{\n    color::Color, font_style::FontStyle, font_weight::FontWeight, units::Unit,\n};\n\n#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// `StyleProperty` enumerates all supported style properties for Mermaid class\n/// definitions.\npub enum StyleProperty {\n    /// Sets the fill color of the node (e.g., `fill: #ff0000`)\n    Fill(Color),\n    /// Sets the stroke (border) color of the node (e.g., `stroke: #000`)\n    Stroke(Color),\n    /// Sets the text color inside the node (e.g., `color: #333`)\n    Color(Color),\n    /// Sets the width of the node border (e.g., `stroke-width: 2px`)\n    StrokeWidth(Unit),\n    /// Sets the font size for node text (e.g., `font-size: 16px`)\n    FontSize(Unit),\n    /// Sets the font weight for node text (e.g., `font-weight: bold`)\n    FontWeight(FontWeight),\n    /// Sets the font style for node text (e.g., `font-style: italic`)\n    FontStyle(FontStyle),\n    /// Sets the dash pattern for the border (e.g., `stroke-dasharray: 5, 2`)\n    StrokeDasharray(u8, u8),\n    /// Sets the dash offset for the border (e.g., `stroke-dashoffset: 4`)\n    StrokeDashoffset(u16),\n    /// Sets the opacity of the node, with a value between 0 and 100,\n    /// which is then normalized to a float between 0.0 and 1.0.\n    Opacity(u8),\n    /// Border radius for rounded corners (e.g., `border-radius: 5px`)\n    BorderRadius(Unit),\n}\n\nimpl StyleProperty {\n    #[must_use]\n    /// Returns whether the provided style property is of the same type as\n    /// `self`.\n    pub fn is_same_type(self, other: StyleProperty) -\u003e bool {\n        matches!(\n            (self, other),\n            (StyleProperty::Fill(_), StyleProperty::Fill(_))\n                | (StyleProperty::Stroke(_), StyleProperty::Stroke(_))\n                | (StyleProperty::Color(_), StyleProperty::Color(_))\n                | (StyleProperty::StrokeWidth(_), StyleProperty::StrokeWidth(_))\n                | (StyleProperty::FontSize(_), StyleProperty::FontSize(_))\n                | (StyleProperty::FontWeight(_), StyleProperty::FontWeight(_))\n                | (StyleProperty::FontStyle(_), StyleProperty::FontStyle(_))\n                | (StyleProperty::StrokeDasharray(_, _), StyleProperty::StrokeDasharray(_, _))\n                | (StyleProperty::StrokeDashoffset(_), StyleProperty::StrokeDashoffset(_))\n                | (StyleProperty::Opacity(_), StyleProperty::Opacity(_))\n                | (StyleProperty::BorderRadius(_), StyleProperty::BorderRadius(_))\n        )\n    }\n}\n\nimpl Display for StyleProperty {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            StyleProperty::Fill(color) =\u003e write!(f, \"fill: {}\", color.to_hex()),\n            StyleProperty::Stroke(color) =\u003e write!(f, \"stroke: {}\", color.to_hex()),\n            StyleProperty::Color(color) =\u003e write!(f, \"color: {}\", color.to_hex()),\n            StyleProperty::StrokeWidth(unit) =\u003e write!(f, \"stroke-width: {unit}\"),\n            StyleProperty::FontSize(unit) =\u003e write!(f, \"font-size: {unit}\"),\n            StyleProperty::FontWeight(weight) =\u003e write!(f, \"font-weight: {weight}\"),\n            StyleProperty::FontStyle(style) =\u003e write!(f, \"font-style: {style}\"),\n            StyleProperty::StrokeDasharray(length, gap) =\u003e {\n                write!(f, \"stroke-dasharray: {length}, {gap}\")\n            }\n            StyleProperty::StrokeDashoffset(offset) =\u003e write!(f, \"stroke-dashoffset: {offset}\",),\n            StyleProperty::Opacity(value) =\u003e write!(f, \"opacity: {:.2}\", f32::from(*value) / 100.0),\n            StyleProperty::BorderRadius(radius) =\u003e write!(f, \"rx: {radius}, ry: {radius}\"),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_style_property_display() {\n        let color = Color::from((255, 0, 0));\n        assert_eq!(format!(\"{}\", StyleProperty::Fill(color)), \"fill: #ff0000\");\n        assert_eq!(format!(\"{}\", StyleProperty::Stroke(color)), \"stroke: #ff0000\");\n        assert_eq!(format!(\"{}\", StyleProperty::Color(color)), \"color: #ff0000\");\n        assert_eq!(format!(\"{}\", StyleProperty::StrokeWidth(Unit::Pixel(2))), \"stroke-width: 2px\");\n        assert_eq!(format!(\"{}\", StyleProperty::FontSize(Unit::Point(12))), \"font-size: 12pt\");\n        assert_eq!(format!(\"{}\", StyleProperty::FontWeight(FontWeight::Bold)), \"font-weight: bold\");\n        assert_eq!(\n            format!(\"{}\", StyleProperty::FontStyle(FontStyle::Italic)),\n            \"font-style: italic\"\n        );\n        assert_eq!(format!(\"{}\", StyleProperty::StrokeDasharray(5, 2)), \"stroke-dasharray: 5, 2\");\n        assert_eq!(format!(\"{}\", StyleProperty::StrokeDashoffset(4)), \"stroke-dashoffset: 4\");\n        assert_eq!(format!(\"{}\", StyleProperty::Opacity(50)), \"opacity: 0.50\");\n        assert_eq!(format!(\"{}\", StyleProperty::BorderRadius(Unit::Pixel(5))), \"rx: 5px, ry: 5px\");\n    }\n\n    #[test]\n    fn test_style_property_is_same_type() {\n        assert!(\n            StyleProperty::Fill(Color::from((255, 0, 0)))\n                .is_same_type(StyleProperty::Fill(Color::from((0, 0, 255))))\n        );\n        assert!(\n            !StyleProperty::Fill(Color::from((255, 0, 0)))\n                .is_same_type(StyleProperty::Stroke(Color::from((255, 0, 0))))\n        );\n    }\n}\n","traces":[{"line":44,"address":[805936,806075],"length":1,"stats":{"Line":1}},{"line":45,"address":[806174,806274,806105,806194,806082,806128,806151,806234,806294,806214,806254,806066],"length":1,"stats":{"Line":2}},{"line":46,"address":[806169,806077,806189,806209,806269,806229,806146,806100,806249,806008,806123,806289],"length":1,"stats":{"Line":2}},{"line":63,"address":[812173,810352,812167],"length":1,"stats":{"Line":1}},{"line":64,"address":[810385],"length":1,"stats":{"Line":1}},{"line":65,"address":[810421,812011],"length":1,"stats":{"Line":1}},{"line":66,"address":[812186,810566],"length":1,"stats":{"Line":1}},{"line":67,"address":[810711,812330],"length":1,"stats":{"Line":1}},{"line":68,"address":[810856],"length":1,"stats":{"Line":1}},{"line":69,"address":[810986],"length":1,"stats":{"Line":1}},{"line":70,"address":[811117],"length":1,"stats":{"Line":1}},{"line":71,"address":[811248],"length":1,"stats":{"Line":1}},{"line":72,"address":[811378],"length":1,"stats":{"Line":1}},{"line":73,"address":[811405],"length":1,"stats":{"Line":1}},{"line":75,"address":[811592],"length":1,"stats":{"Line":1}},{"line":76,"address":[811723],"length":1,"stats":{"Line":1}},{"line":77,"address":[811886],"length":1,"stats":{"Line":1}}],"covered":17,"coverable":17},{"path":["/","home","lucac","github","mermaid-builder","src","shared","style_class","units.rs"],"content":"//! Submodule providing an enumeration of units which may be used in\n//! style class definitions in Mermaid diagrams, including pixel and\n//! point units.\n\nuse std::fmt::Display;\n\n#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// Represents the unit of measurement used in style class definitions.\npub enum Unit {\n    /// Pixel unit, denoted by `px`.\n    Pixel(u8),\n    /// Point unit, denoted by `pt`.\n    Point(u8),\n}\n\nimpl Display for Unit {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Unit::Pixel(value) =\u003e write!(f, \"{value}px\"),\n            Unit::Point(value) =\u003e write!(f, \"{value}pt\"),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_unit_display() {\n        assert_eq!(format!(\"{}\", Unit::Pixel(10)), \"10px\");\n        assert_eq!(format!(\"{}\", Unit::Point(12)), \"12pt\");\n    }\n}\n","traces":[{"line":18,"address":[448960],"length":1,"stats":{"Line":1}},{"line":19,"address":[448986],"length":1,"stats":{"Line":1}},{"line":20,"address":[449104],"length":1,"stats":{"Line":1}},{"line":21,"address":[449005],"length":1,"stats":{"Line":1}}],"covered":4,"coverable":4},{"path":["/","home","lucac","github","mermaid-builder","src","shared","style_class.rs"],"content":"//! Submodule providing structs for style class definitions in Mermaid diagrams.\n\nmod builder;\nmod color;\nmod error;\nmod font_style;\nmod font_weight;\nmod style_properties;\nmod units;\nuse std::fmt::Display;\n\npub use builder::StyleClassBuilder;\npub use color::Color;\npub use error::StyleClassError;\npub use font_weight::FontWeight;\npub use style_properties::StyleProperty;\npub use units::Unit;\n\n#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// Represents a style class in Mermaid diagrams, which can be used to define\n/// styles for nodes, edges, and other elements. It includes a name and a set of\n/// properties that define the style.\npub struct StyleClass {\n    /// The name of the style class.\n    name: String,\n    /// The properties associated with the style class.\n    properties: Vec\u003cStyleProperty\u003e,\n}\n\nimpl StyleClass {\n    #[must_use]\n    /// Returns the name of the style class.\n    pub fn name(\u0026self) -\u003e \u0026str {\n        \u0026self.name\n    }\n    #[must_use]\n    /// Returns the properties of the style class.\n    pub fn properties(\u0026self) -\u003e \u0026[StyleProperty] {\n        \u0026self.properties\n    }\n}\n\nimpl Display for StyleClass {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        use crate::traits::TabbedDisplay;\n        self.fmt_tabbed(f, 0)\n    }\n}\n\nimpl crate::traits::TabbedDisplay for StyleClass {\n    fn fmt_tabbed(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e, tab_count: usize) -\u003e std::fmt::Result {\n        write!(f, \"{:indent$}classDef {} \", \"\", self.name, indent = tab_count * 2)?;\n        for (property_number, property) in self.properties.iter().enumerate() {\n            if property_number \u003e 0 {\n                write!(f, \",\")?;\n            }\n            write!(f, \"{property}\")?;\n        }\n        writeln!(f)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::shared::style_class::color::Color;\n\n    #[test]\n    fn test_style_class_display() {\n        let style_class = StyleClass {\n            name: \"myClass\".to_string(),\n            properties: vec![\n                StyleProperty::Fill(Color::from((255, 0, 0))),\n                StyleProperty::Stroke(Color::from((0, 0, 255))),\n            ],\n        };\n\n        assert_eq!(format!(\"{style_class}\"), \"classDef myClass fill: #ff0000,stroke: #0000ff\\n\");\n    }\n\n    #[test]\n    fn test_style_class_getters() {\n        let style_class = StyleClass {\n            name: \"myClass\".to_string(),\n            properties: vec![StyleProperty::Fill(Color::from((255, 0, 0)))],\n        };\n\n        assert_eq!(style_class.name(), \"myClass\");\n        assert_eq!(style_class.properties().len(), 1);\n    }\n}\n","traces":[{"line":34,"address":[527440],"length":1,"stats":{"Line":1}},{"line":35,"address":[527445],"length":1,"stats":{"Line":1}},{"line":39,"address":[527424],"length":1,"stats":{"Line":1}},{"line":40,"address":[527429],"length":1,"stats":{"Line":1}},{"line":45,"address":[529856],"length":1,"stats":{"Line":1}},{"line":47,"address":[529870],"length":1,"stats":{"Line":1}},{"line":52,"address":[528320],"length":1,"stats":{"Line":1}},{"line":53,"address":[528364],"length":1,"stats":{"Line":1}},{"line":54,"address":[528765,528660],"length":1,"stats":{"Line":2}},{"line":55,"address":[528857],"length":1,"stats":{"Line":1}},{"line":56,"address":[529051],"length":1,"stats":{"Line":1}},{"line":58,"address":[528919,529132],"length":1,"stats":{"Line":1}},{"line":60,"address":[528869],"length":1,"stats":{"Line":1}}],"covered":13,"coverable":13},{"path":["/","home","lucac","github","mermaid-builder","src","shared.rs"],"content":"//! Submodule providing structs used across different type of Mermaid diagrams.\n\npub mod generic_configuration;\npub use generic_configuration::{Direction, Renderer};\npub(crate) mod generic_diagram;\npub mod javascript_function_signature;\npub mod javascript_types;\npub mod style_class;\npub use style_class::{\n    Color, FontWeight, StyleClass, StyleClassBuilder, StyleClassError, StyleProperty, Unit,\n};\npub mod arrow_shape;\npub mod click_event;\npub mod line_style;\npub use arrow_shape::ArrowShape;\npub use click_event::ClickEvent;\npub use line_style::LineStyle;\nmod constants;\npub(crate) use constants::{EDGE_LETTER, NODE_LETTER};\npub(crate) mod generic_node;\npub(crate) use generic_node::GenericNode;\npub(crate) mod generic_edge;\npub(crate) use generic_edge::GenericEdge;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","lucac","github","mermaid-builder","src","traits","configuration.rs"],"content":"//! Submodule defining the `Configuration` trait for Mermaid diagrams.\n\nuse std::fmt::Display;\n\nuse crate::{\n    shared::generic_configuration::{Direction, Look, Renderer, Theme},\n    traits::ConfigurationBuilder,\n};\n\n/// Trait defining the configuration for Mermaid diagrams.\npub trait Configuration: Default + Display {\n    /// The builder type for this configuration.\n    type Builder: ConfigurationBuilder\u003cConfiguration = Self\u003e;\n\n    /// Returns the title of the diagram, if any.\n    fn title(\u0026self) -\u003e Option\u003c\u0026str\u003e;\n\n    /// Returns the renderer to use for the diagram.\n    fn renderer(\u0026self) -\u003e Renderer;\n\n    /// Returns the direction of the flowchart.\n    fn direction(\u0026self) -\u003e Direction;\n\n    /// Returns the theme to use for the diagram.\n    fn theme(\u0026self) -\u003e Theme;\n\n    /// Returns the look to use for the diagram.\n    fn look(\u0026self) -\u003e Look;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","lucac","github","mermaid-builder","src","traits","configuration_builder.rs"],"content":"//! Submodule defining the `ConfigurationBuilder` trait for Mermaid diagrams.\n\nuse crate::shared::generic_configuration::{Direction, Renderer};\n\n/// Trait defining a configuration builder for Mermaid diagrams.\npub trait ConfigurationBuilder: Sized {\n    /// Type of the configuration that this builder constructs.\n    type Configuration;\n\n    /// The error type returned when building the configuration fails.\n    type Error;\n\n    /// Builds the configuration.\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if the configuration cannot be built.\n    fn build(self) -\u003e Result\u003cSelf::Configuration, Self::Error\u003e;\n\n    /// Returns the current title of the configuration, if any.\n    ///\n    /// # Arguments\n    ///\n    /// * `title` - The title to set for the configuration.\n    ///\n    /// # Errors\n    ///\n    /// * If the provided title is empty.\n    fn title\u003cS: ToString\u003e(self, title: S) -\u003e Result\u003cSelf, Self::Error\u003e;\n\n    #[must_use]\n    /// Sets the renderer to use for the diagram.\n    fn renderer(self, renderer: Renderer) -\u003e Self;\n\n    #[must_use]\n    /// Sets the direction of the flowchart.\n    fn direction(self, direction: Direction) -\u003e Self;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","lucac","github","mermaid-builder","src","traits","diagram.rs"],"content":"//! Submodule defining the `Diagram` trait for Mermaid diagrams.\n\nuse std::{fmt::Display, rc::Rc};\n\nuse crate::{\n    shared::StyleClass,\n    traits::{Configuration, DiagramBuilder, Edge, Node},\n};\n\n/// Trait representing a Mermaid diagram.\npub trait Diagram {\n    /// Type of the associated builder for this diagram.\n    type Builder: DiagramBuilder\u003cDiagram = Self, Node = Self::Node, Edge = Self::Edge\u003e;\n    /// Type of the node used in the diagram.\n    type Node: Node + Display;\n    /// Type of edge used in the diagram.\n    type Edge: Edge\u003cNode = Self::Node\u003e + Display;\n    /// The configuration options for the diagram.\n    type Configuration: Configuration + Display;\n\n    /// Returns the configuration of the diagram.\n    fn configuration(\u0026self) -\u003e \u0026Self::Configuration;\n\n    /// Returns an iterator over the nodes in the diagram.\n    fn nodes(\u0026self) -\u003e impl Iterator\u003cItem = \u0026Self::Node\u003e;\n\n    /// Returns an iterator over the edges in the diagram.\n    fn edges(\u0026self) -\u003e impl Iterator\u003cItem = \u0026Self::Edge\u003e;\n\n    /// Returns an iterator over the style classes associated with the diagram.\n    fn style_classes(\u0026self) -\u003e impl Iterator\u003cItem = \u0026StyleClass\u003e;\n\n    /// Returns the reference to the requested node by ID if it exists.\n    fn get_node_by_id(\u0026self, id: u64) -\u003e Option\u003cRc\u003cSelf::Node\u003e\u003e;\n\n    /// Returns the reference to the requested style class by name if it exists.\n    fn get_style_class_by_name(\u0026self, name: \u0026str) -\u003e Option\u003cRc\u003cStyleClass\u003e\u003e;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","lucac","github","mermaid-builder","src","traits","diagram_builder.rs"],"content":"//! Submodule defining the `DiagramBuilder` trait for Mermaid diagrams.\n\nuse std::{fmt::Display, rc::Rc};\n\nuse crate::{\n    shared::{StyleClass, StyleClassBuilder},\n    traits::{Configuration, ConfigurationBuilder, Diagram, Edge, EdgeBuilder, Node, NodeBuilder},\n};\n\n/// Trait defining the builder for Mermaid diagrams.\npub trait DiagramBuilder: Default\nwhere\n    Self::Diagram: From\u003cSelf\u003e,\n{\n    /// Type of the diagram that this builder constructs.\n    type Diagram: Diagram\u003c\n            Builder = Self,\n            Node = Self::Node,\n            Edge = Self::Edge,\n            Configuration = Self::Configuration,\n        \u003e;\n    /// Type of the node used in the diagram.\n    type Node: Node\u003cBuilder = Self::NodeBuilder\u003e + Display;\n    /// The type of node builder used to create nodes in the diagram.\n    type NodeBuilder: NodeBuilder\u003cNode = Self::Node\u003e;\n    /// Type of edge used in the diagram.\n    type Edge: Edge\u003cNode = Self::Node\u003e + Display;\n    /// The type of edge builder used to create edges in the diagram.\n    type EdgeBuilder: EdgeBuilder\u003cEdge = Self::Edge\u003e;\n    /// The configuration type for the diagram.\n    type Configuration: Configuration + Display;\n    /// The configuration builder type for the diagram.\n    type ConfigurationBuilder: ConfigurationBuilder\u003cConfiguration = Self::Configuration\u003e;\n    /// The error type for the diagram builder.\n    type Error: std::error::Error + Display;\n\n    /// Sets the configuration for the diagram being built.\n    ///\n    /// # Arguments\n    ///\n    /// * `configuration` - The configuration builder to use for constructing\n    ///   the diagram's configuration.\n    ///\n    /// # Errors\n    ///\n    /// * If the configuration builder is incomplete or invalid.\n    fn configuration(self, configuration: Self::ConfigurationBuilder) -\u003e Result\u003cSelf, Self::Error\u003e;\n\n    /// Adds a style class to the diagram being built.\n    ///\n    /// # Arguments\n    ///\n    /// * `style_class` - The style class to add to the diagram.\n    ///\n    /// # Errors\n    ///\n    /// * If there are conflicting style class names.\n    /// * If the style class builder is incomplete or invalid.\n    fn style_class(\n        \u0026mut self,\n        style_class: StyleClassBuilder,\n    ) -\u003e Result\u003cRc\u003cStyleClass\u003e, Self::Error\u003e;\n\n    #[must_use]\n    /// Returns the number of nodes currently in the diagram.\n    fn number_of_nodes(\u0026self) -\u003e usize;\n\n    #[must_use]\n    /// Returns the number of edges currently in the diagram.\n    fn number_of_edges(\u0026self) -\u003e usize;\n\n    /// Builds and adds a node to the diagram being built.\n    ///\n    /// # Arguments\n    ///\n    /// * `node` - The node builder to use for constructing the node.\n    ///\n    /// # Errors\n    ///\n    /// * If the node already exists in the diagram.\n    /// * If the node cannot be built due to missing attributes or other issues.\n    fn node(\u0026mut self, node: Self::NodeBuilder) -\u003e Result\u003cRc\u003cSelf::Node\u003e, Self::Error\u003e;\n\n    /// Iterates over the nodes in the diagram being built.\n    fn nodes(\u0026self) -\u003e impl Iterator\u003cItem = \u0026Rc\u003cSelf::Node\u003e\u003e + '_;\n\n    /// Returns a reference to the requested node by ID if it exists.\n    fn get_node_by_id(\u0026self, id: u64) -\u003e Option\u003cRc\u003cSelf::Node\u003e\u003e;\n\n    /// Returns a reference to the request style class by name if it exists.\n    fn get_style_class_by_name(\u0026self, name: \u0026str) -\u003e Option\u003cRc\u003cStyleClass\u003e\u003e;\n\n    /// Builds and adds an edge to the diagram being built.\n    ///\n    /// # Arguments\n    ///\n    /// * `edge` - The edge builder to use for constructing the edge.\n    ///\n    /// # Errors\n    ///\n    /// * If the source or destination nodes cannot be found in the diagram.\n    /// * If the edge cannot be built due to missing attributes or other issues.\n    fn edge(\u0026mut self, edge: Self::EdgeBuilder) -\u003e Result\u003cRc\u003cSelf::Edge\u003e, Self::Error\u003e;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","lucac","github","mermaid-builder","src","traits","edge.rs"],"content":"//! Submodule defining the trait for representing edges in Mermaid diagrams.\n\nuse std::rc::Rc;\n\nuse crate::{\n    shared::{ArrowShape, LineStyle},\n    traits::{EdgeBuilder, Node},\n};\n\n/// Trait representing an edge in a Mermaid diagram.\npub trait Edge: Ord {\n    /// Type of the builder used to construct this edge.\n    type Builder: EdgeBuilder\u003cEdge = Self\u003e;\n    /// Type of the node this edge connects to.\n    type Node: Node;\n\n    /// Returns a reference to the label of the edge.\n    fn label(\u0026self) -\u003e Option\u003c\u0026str\u003e;\n\n    /// Returns a reference to the source node of the edge.\n    fn source(\u0026self) -\u003e \u0026Rc\u003cSelf::Node\u003e;\n\n    /// Returns a reference to the destination node of the edge.\n    fn destination(\u0026self) -\u003e \u0026Rc\u003cSelf::Node\u003e;\n\n    /// Returns the line style of the edge.\n    fn line_style(\u0026self) -\u003e LineStyle;\n\n    /// Returns an iterator over the style classes associated with the edge.\n    fn classes(\u0026self) -\u003e impl Iterator\u003cItem = \u0026crate::shared::StyleClass\u003e;\n\n    /// Returns the left arrow shape of the edge, if any.\n    fn left_arrow_shape(\u0026self) -\u003e Option\u003cArrowShape\u003e;\n\n    /// Returns the right arrow shape of the edge, if any.\n    fn right_arrow_shape(\u0026self) -\u003e Option\u003cArrowShape\u003e;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","lucac","github","mermaid-builder","src","traits","edge_builder.rs"],"content":"//! Submodule defining the trait for structs constructing edges in Mermaid\n//! diagrams.\n\nuse std::rc::Rc;\n\nuse crate::shared::{ArrowShape, LineStyle};\n\n/// Trait representing an edge builder in a Mermaid diagram.\npub trait EdgeBuilder: Sized {\n    /// The type of edge this builder constructs.\n    type Edge;\n    /// Type of the node this edge connects to.\n    type Node;\n\n    /// The error type returned when building the edge fails.\n    type Error;\n\n    /// Builds the edge.\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if the edge cannot be built.\n    fn build(self) -\u003e Result\u003cSelf::Edge, Self::Error\u003e;\n\n    /// Set the label for this edge.\n    ///\n    /// # Arguments\n    ///\n    /// * `label` - The label to set for this edge.\n    ///\n    /// # Errors\n    ///\n    /// * If the label is empty.\n    fn label\u003cS: ToString\u003e(self, label: S) -\u003e Result\u003cSelf, Self::Error\u003e;\n\n    /// Set the source node for this edge.\n    ///\n    /// # Arguments\n    ///\n    /// * `node` - The source node for this edge.\n    ///\n    /// # Errors\n    ///\n    /// * If the node is not compatible with any of the other set parameters.\n    fn source(self, node: Rc\u003cSelf::Node\u003e) -\u003e Result\u003cSelf, Self::Error\u003e;\n\n    /// Set the destination node for this edge.\n    ///\n    /// # Arguments\n    ///\n    /// * `node` - The destination node for this edge.\n    ///\n    /// # Errors\n    ///\n    /// * If the node is not compatible with any of the other set parameters.\n    fn destination(self, node: Rc\u003cSelf::Node\u003e) -\u003e Result\u003cSelf, Self::Error\u003e;\n\n    #[must_use]\n    /// Set the style class for this edge.\n    ///\n    /// # Arguments\n    ///\n    /// * `class` - The style class to set for this edge.\n    fn line_style(self, style: LineStyle) -\u003e Self;\n\n    /// Set the left arrow shape for this edge.\n    ///\n    /// # Arguments\n    ///\n    /// * `shape` - The shape of the left arrow.\n    ///\n    /// # Errors\n    ///\n    /// * If the shape is not compatible with the associated node type.\n    fn left_arrow_shape(self, shape: ArrowShape) -\u003e Result\u003cSelf, Self::Error\u003e;\n\n    /// Set the right arrow shape for this edge.\n    ///\n    /// # Arguments\n    ///\n    /// * `shape` - The shape of the right arrow.\n    ///\n    /// # Errors\n    ///\n    /// * If the shape is not compatible with the associated node type.\n    fn right_arrow_shape(self, shape: ArrowShape) -\u003e Result\u003cSelf, Self::Error\u003e;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","lucac","github","mermaid-builder","src","traits","node.rs"],"content":"//! Submodule defining the node trait used in Mermaid diagrams.\n\nuse crate::{\n    shared::{ArrowShape, StyleClass, StyleProperty},\n    traits::NodeBuilder,\n};\n\n/// Trait representing a node in a Mermaid diagram.\npub trait Node: PartialOrd + Ord + Eq + PartialEq {\n    /// Type of the builder used to construct this node.\n    type Builder: NodeBuilder\u003cNode = Self\u003e;\n\n    /// Returns the identifier of the node.\n    fn id(\u0026self) -\u003e u64;\n\n    /// Returns the label of the node.\n    fn label(\u0026self) -\u003e \u0026str;\n\n    /// Returns an iterator over the CSS classes associated with the node.\n    fn classes(\u0026self) -\u003e impl Iterator\u003cItem = \u0026StyleClass\u003e;\n\n    /// Returns an iterator over the style properties associated with the node.\n    fn styles(\u0026self) -\u003e impl Iterator\u003cItem = \u0026StyleProperty\u003e;\n\n    /// Returns whether the node is stylized.\n    fn has_styles(\u0026self) -\u003e bool {\n        self.styles().next().is_some()\n    }\n\n    /// Returns whether the provided arrow shape is compatible with the node.\n    fn is_compatible_arrow_shape(shape: ArrowShape) -\u003e bool;\n}\n","traces":[{"line":26,"address":[277497,277456],"length":1,"stats":{"Line":1}},{"line":27,"address":[277465,277528],"length":1,"stats":{"Line":4}}],"covered":2,"coverable":2},{"path":["/","home","lucac","github","mermaid-builder","src","traits","node_builder.rs"],"content":"//! Submodule defining the traits for building a node in Mermaid diagrams.\n\nuse std::rc::Rc;\n\nuse crate::shared::{StyleClass, StyleClassError, StyleProperty};\n\n/// Trait for building nodes in Mermaid diagrams.\npub trait NodeBuilder: Sized {\n    /// Type of the node that this builder constructs.\n    type Node;\n\n    /// The error type returned when building the node fails.\n    type Error;\n\n    /// Builds the node.\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if the node cannot be built.\n    fn build(self) -\u003e Result\u003cSelf::Node, Self::Error\u003e;\n\n    /// Adds the provided style class to the node being built.\n    ///\n    /// # Arguments\n    ///\n    /// * `style_class` - The style class to add to the node.\n    ///\n    /// # Errors\n    ///\n    /// * If the style class name clashes with a previously applied class.\n    fn style_class(self, style_class: Rc\u003cStyleClass\u003e) -\u003e Result\u003cSelf, StyleClassError\u003e;\n\n    /// Adds a style property to the node being built.\n    ///\n    /// # Arguments\n    ///\n    /// * `property` - The style property to add to the node.\n    ///\n    /// # Errors\n    ///\n    /// * If the style property has already been set for the node.\n    fn style_property(self, property: StyleProperty) -\u003e Result\u003cSelf, StyleClassError\u003e;\n\n    /// Iterates across the style properties of the node being built.\n    fn style_properties(\u0026self) -\u003e impl Iterator\u003cItem = \u0026StyleProperty\u003e;\n\n    /// Sets the label for the node being built.\n    ///\n    /// # Arguments\n    ///\n    /// * `label` - The label to set for the node.\n    ///\n    /// # Errors\n    ///\n    /// * If the label is empty.\n    fn label\u003cS: ToString\u003e(self, label: S) -\u003e Result\u003cSelf, Self::Error\u003e;\n\n    /// Returns a reference to the label of the node being built, if set.\n    fn get_label(\u0026self) -\u003e Option\u003c\u0026String\u003e;\n\n    #[must_use]\n    /// Sets the ID for the node being built.\n    fn id(self, id: u64) -\u003e Self;\n\n    /// Returns the ID of the node being built, if set.\n    fn get_id(\u0026self) -\u003e Option\u003cu64\u003e;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","lucac","github","mermaid-builder","src","traits","tabbed_display.rs"],"content":"//! Module defining the `TabbedDisplay` trait for formatted output with\n//! indentation.\nuse std::fmt;\n\n/// Trait for displaying objects with indentation.\npub trait TabbedDisplay {\n    /// Formats the object with the given indentation level.\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if formatting fails.\n    fn fmt_tabbed(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e, tab_count: usize) -\u003e fmt::Result;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","lucac","github","mermaid-builder","src","traits.rs"],"content":"//! Submodule defining traits for Mermaid diagrams and annexed objects.\n\npub mod diagram;\npub mod diagram_builder;\npub use diagram::Diagram;\npub use diagram_builder::DiagramBuilder;\npub mod node;\npub use node::Node;\npub mod node_builder;\npub use node_builder::NodeBuilder;\npub mod edge;\npub use edge::Edge;\npub mod edge_builder;\npub use edge_builder::EdgeBuilder;\npub mod configuration;\npub use configuration::Configuration;\npub mod configuration_builder;\npub use configuration_builder::ConfigurationBuilder;\npub mod tabbed_display;\npub use tabbed_display::TabbedDisplay;\n","traces":[],"covered":0,"coverable":0}]};
        var previousData = {"files":[{"path":["/","home","lucac","github","mermaid-builder","src","diagrams","class_diagram","class_edge","builder.rs"],"content":"//! Submodule defining a builder for class edges in class diagrams\n//! in Mermaid syntax.\n\nuse crate::{\n    diagrams::class_diagram::{\n        class_edge::{ClassEdge, multiplicity::Multiplicity},\n        class_node::ClassNode,\n    },\n    errors::EdgeError,\n    shared::generic_edge::GenericEdgeBuilder,\n    traits::EdgeBuilder,\n};\n\n#[derive(Default, Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// Builder for creating a `ClassEdge`.\n///\n/// # Example\n///\n/// ```\n/// use std::rc::Rc;\n///\n/// use mermaid_builder::prelude::*;\n///\n/// let node1 = Rc::new(ClassNodeBuilder::default().label(\"A\").unwrap().id(0).build().unwrap());\n/// let node2 = Rc::new(ClassNodeBuilder::default().label(\"B\").unwrap().id(1).build().unwrap());\n///\n/// let edge = ClassEdgeBuilder::default()\n///     .source(node1)\n///     .unwrap()\n///     .destination(node2)\n///     .unwrap()\n///     .right_arrow_shape(ArrowShape::Triangle)\n///     .unwrap()\n///     .build()\n///     .unwrap();\n/// ```\npub struct ClassEdgeBuilder {\n    /// Underlying generic edge builder.\n    edge_builder: GenericEdgeBuilder\u003cClassNode\u003e,\n    /// Left Multiplicity of the edge.\n    left_multiplicity: Option\u003cMultiplicity\u003e,\n    /// Right Multiplicity of the edge.\n    right_multiplicity: Option\u003cMultiplicity\u003e,\n}\n\nimpl ClassEdgeBuilder {\n    /// Sets the left multiplicity of the edge.\n    #[must_use]\n    pub fn left_multiplicity(mut self, multiplicity: Multiplicity) -\u003e Self {\n        self.left_multiplicity = Some(multiplicity);\n        self\n    }\n\n    /// Sets the right multiplicity of the edge.\n    #[must_use]\n    pub fn right_multiplicity(mut self, multiplicity: Multiplicity) -\u003e Self {\n        self.right_multiplicity = Some(multiplicity);\n        self\n    }\n}\n\nimpl TryFrom\u003cClassEdgeBuilder\u003e for ClassEdge {\n    type Error = EdgeError;\n\n    fn try_from(builder: ClassEdgeBuilder) -\u003e Result\u003cSelf, Self::Error\u003e {\n        Ok(ClassEdge {\n            edge: builder.edge_builder.try_into()?,\n            left_multiplicity: builder.left_multiplicity,\n            right_multiplicity: builder.right_multiplicity,\n        })\n    }\n}\n\nimpl EdgeBuilder for ClassEdgeBuilder {\n    type Edge = ClassEdge;\n    type Node = ClassNode;\n    type Error = EdgeError;\n\n    fn build(self) -\u003e Result\u003cSelf::Edge, Self::Error\u003e {\n        self.try_into()\n    }\n\n    fn source(mut self, node: std::rc::Rc\u003cSelf::Node\u003e) -\u003e Result\u003cSelf, Self::Error\u003e {\n        self.edge_builder = self.edge_builder.source(node)?;\n        Ok(self)\n    }\n\n    fn destination(mut self, node: std::rc::Rc\u003cSelf::Node\u003e) -\u003e Result\u003cSelf, Self::Error\u003e {\n        self.edge_builder = self.edge_builder.destination(node)?;\n        Ok(self)\n    }\n\n    fn label\u003cS: ToString\u003e(mut self, label: S) -\u003e Result\u003cSelf, Self::Error\u003e {\n        self.edge_builder = self.edge_builder.label(label)?;\n        Ok(self)\n    }\n\n    fn line_style(mut self, style: crate::shared::LineStyle) -\u003e Self {\n        self.edge_builder = self.edge_builder.line_style(style);\n        self\n    }\n\n    fn left_arrow_shape(mut self, shape: crate::shared::ArrowShape) -\u003e Result\u003cSelf, Self::Error\u003e {\n        self.edge_builder = self.edge_builder.left_arrow_shape(shape)?;\n        Ok(self)\n    }\n\n    fn right_arrow_shape(mut self, shape: crate::shared::ArrowShape) -\u003e Result\u003cSelf, Self::Error\u003e {\n        self.edge_builder = self.edge_builder.right_arrow_shape(shape)?;\n        Ok(self)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use std::rc::Rc;\n\n    use super::*;\n    use crate::{\n        diagrams::class_diagram::class_node::ClassNodeBuilder,\n        shared::{ArrowShape, LineStyle},\n        traits::{NodeBuilder, edge::Edge, node::Node},\n    };\n\n    #[test]\n    fn test_class_edge_builder() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n        let node1 = Rc::new(ClassNodeBuilder::default().label(\"A\")?.id(0).build()?);\n        let node2 = Rc::new(ClassNodeBuilder::default().label(\"B\")?.id(1).build()?);\n\n        let edge = ClassEdgeBuilder::default()\n            .source(node1.clone())?\n            .destination(node2.clone())?\n            .label(\"Edge Label\")?\n            .line_style(LineStyle::Dashed)\n            .left_multiplicity(Multiplicity::One)\n            .right_multiplicity(Multiplicity::Many)\n            .left_arrow_shape(ArrowShape::Circle)?\n            .right_arrow_shape(ArrowShape::Triangle)?\n            .build()?;\n\n        assert_eq!(edge.source().id(), 0);\n        assert_eq!(edge.destination().id(), 1);\n        assert_eq!(edge.label(), Some(\"Edge Label\"));\n        assert_eq!(edge.line_style(), LineStyle::Dashed);\n        assert_eq!(edge.left_multiplicity, Some(Multiplicity::One));\n        assert_eq!(edge.right_multiplicity, Some(Multiplicity::Many));\n        assert_eq!(edge.left_arrow_shape(), Some(ArrowShape::Circle));\n        assert_eq!(edge.right_arrow_shape(), Some(ArrowShape::Triangle));\n        Ok(())\n    }\n}\n","traces":[{"line":50,"address":[559312],"length":1,"stats":{"Line":1}},{"line":51,"address":[559330],"length":1,"stats":{"Line":1}},{"line":52,"address":[559333],"length":1,"stats":{"Line":1}},{"line":57,"address":[559360],"length":1,"stats":{"Line":1}},{"line":58,"address":[559378],"length":1,"stats":{"Line":1}},{"line":59,"address":[559381],"length":1,"stats":{"Line":1}},{"line":66,"address":[627824],"length":1,"stats":{"Line":1}},{"line":67,"address":[628126],"length":1,"stats":{"Line":1}},{"line":68,"address":[627846],"length":1,"stats":{"Line":1}},{"line":69,"address":[628112],"length":1,"stats":{"Line":1}},{"line":70,"address":[628119],"length":1,"stats":{"Line":1}},{"line":80,"address":[560944],"length":1,"stats":{"Line":1}},{"line":81,"address":[560957],"length":1,"stats":{"Line":1}},{"line":84,"address":[561442,561417,561008],"length":1,"stats":{"Line":1}},{"line":85,"address":[561038,561415,561168],"length":1,"stats":{"Line":2}},{"line":86,"address":[561353],"length":1,"stats":{"Line":1}},{"line":89,"address":[560009,559600,560034],"length":1,"stats":{"Line":1}},{"line":90,"address":[559760,560007,559630],"length":1,"stats":{"Line":2}},{"line":91,"address":[559945],"length":1,"stats":{"Line":1}},{"line":94,"address":[564688,565105,565130],"length":1,"stats":{"Line":1}},{"line":95,"address":[564726,565103,564856],"length":1,"stats":{"Line":2}},{"line":96,"address":[565041],"length":1,"stats":{"Line":1}},{"line":99,"address":[559472],"length":1,"stats":{"Line":1}},{"line":100,"address":[559507],"length":1,"stats":{"Line":1}},{"line":101,"address":[559574],"length":1,"stats":{"Line":1}},{"line":104,"address":[560048,560486,560461],"length":1,"stats":{"Line":1}},{"line":105,"address":[560212,560459,560079],"length":1,"stats":{"Line":2}},{"line":106,"address":[560397],"length":1,"stats":{"Line":1}},{"line":109,"address":[560909,560934,560496],"length":1,"stats":{"Line":1}},{"line":110,"address":[560660,560527,560907],"length":1,"stats":{"Line":2}},{"line":111,"address":[560845],"length":1,"stats":{"Line":1}}],"covered":31,"coverable":31},{"path":["/","home","lucac","github","mermaid-builder","src","diagrams","class_diagram","class_edge","multiplicity.rs"],"content":"//! Submodule defining the multiplicities which may be used to characterize\n//! a class edge in a class diagram in Mermaid syntax.\n//!\n//! The different cardinality options are :\n//!\n//! - `1` Only 1\n//! - `0..1` Zero or One\n//! - `1..*` One or more\n//! - `*` Many\n//! - `n` n (where n\u003e1)\n//! - `0..n` zero to n (where n\u003e1)\n//! - `1..n` one to n (where n\u003e1)\n\nuse std::fmt::Display;\n\n#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// An enumeration representing the multiplicity of a class edge in a Mermaid\n/// class diagram.\npub enum Multiplicity {\n    /// Only 1\n    One,\n    /// Zero or One\n    ZeroOrOne,\n    /// One or more\n    OneOrMore,\n    /// Many, which is analogous to `Zero or More`\n    Many,\n    /// n (where n\u003e1)\n    N,\n    /// Zero to n (where n\u003e1)\n    ZeroToN,\n    /// One to n (where n\u003e1)\n    OneToN,\n}\n\nimpl Display for Multiplicity {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Multiplicity::One =\u003e write!(f, \"1\"),\n            Multiplicity::ZeroOrOne =\u003e write!(f, \"0..1\"),\n            Multiplicity::OneOrMore =\u003e write!(f, \"1..*\"),\n            Multiplicity::Many =\u003e write!(f, \"*\"),\n            Multiplicity::N =\u003e write!(f, \"n\"),\n            Multiplicity::ZeroToN =\u003e write!(f, \"0..n\"),\n            Multiplicity::OneToN =\u003e write!(f, \"1..n\"),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_multiplicity_display() {\n        assert_eq!(Multiplicity::One.to_string(), \"1\");\n        assert_eq!(Multiplicity::ZeroOrOne.to_string(), \"0..1\");\n        assert_eq!(Multiplicity::OneOrMore.to_string(), \"1..*\");\n        assert_eq!(Multiplicity::Many.to_string(), \"*\");\n        assert_eq!(Multiplicity::N.to_string(), \"n\");\n        assert_eq!(Multiplicity::ZeroToN.to_string(), \"0..n\");\n        assert_eq!(Multiplicity::OneToN.to_string(), \"1..n\");\n    }\n}\n","traces":[{"line":38,"address":[523040],"length":1,"stats":{"Line":1}},{"line":39,"address":[523058],"length":1,"stats":{"Line":1}},{"line":40,"address":[523089],"length":1,"stats":{"Line":1}},{"line":41,"address":[523129],"length":1,"stats":{"Line":1}},{"line":42,"address":[523169],"length":1,"stats":{"Line":1}},{"line":43,"address":[523209],"length":1,"stats":{"Line":1}},{"line":44,"address":[523246],"length":1,"stats":{"Line":1}},{"line":45,"address":[523283],"length":1,"stats":{"Line":1}},{"line":46,"address":[523320],"length":1,"stats":{"Line":1}}],"covered":9,"coverable":9},{"path":["/","home","lucac","github","mermaid-builder","src","diagrams","class_diagram","class_edge.rs"],"content":"//! Submodule defining an edge which may be used in a flowchart diagram\n//! in Mermaid syntax.\n\nuse std::{fmt::Display, rc::Rc};\n\nuse crate::{\n    diagrams::class_diagram::{class_edge::multiplicity::Multiplicity, class_node::ClassNode},\n    shared::{ArrowShape, GenericEdge, LineStyle, NODE_LETTER},\n    traits::{Edge, node::Node},\n};\n\npub mod builder;\npub mod multiplicity;\npub use builder::ClassEdgeBuilder;\n\n#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// An edge in a Mermaid class diagram, connecting two class nodes with optional\n/// multiplicities.\n///\n/// # Examples\n///\n/// ```\n/// use std::rc::Rc;\n///\n/// use mermaid_builder::{\n///     diagrams::class_diagram::{ClassEdgeBuilder, ClassNodeBuilder},\n///     traits::{EdgeBuilder, NodeBuilder},\n/// };\n///\n/// fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n///     let node1 = Rc::new(ClassNodeBuilder::default().label(\"A\")?.id(1).build()?);\n///     let node2 = Rc::new(ClassNodeBuilder::default().label(\"B\")?.id(2).build()?);\n///\n///     let edge = ClassEdgeBuilder::default().source(node1)?.destination(node2)?.build()?;\n///     Ok(())\n/// }\n/// ```\npub struct ClassEdge {\n    /// Underlying generic edge.\n    edge: GenericEdge\u003cClassNode\u003e,\n    /// Left multiplicity of the edge.\n    left_multiplicity: Option\u003cMultiplicity\u003e,\n    /// Right multiplicity of the edge.\n    right_multiplicity: Option\u003cMultiplicity\u003e,\n}\n\nimpl Edge for ClassEdge {\n    type Builder = ClassEdgeBuilder;\n    type Node = ClassNode;\n\n    fn label(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n        self.edge.label()\n    }\n\n    fn source(\u0026self) -\u003e \u0026Rc\u003cSelf::Node\u003e {\n        self.edge.source()\n    }\n\n    fn destination(\u0026self) -\u003e \u0026Rc\u003cSelf::Node\u003e {\n        self.edge.destination()\n    }\n\n    fn line_style(\u0026self) -\u003e LineStyle {\n        self.edge.line_style()\n    }\n\n    fn classes(\u0026self) -\u003e impl Iterator\u003cItem = \u0026crate::shared::StyleClass\u003e {\n        std::iter::empty()\n    }\n\n    fn left_arrow_shape(\u0026self) -\u003e Option\u003cArrowShape\u003e {\n        self.edge.left_arrow_shape()\n    }\n\n    fn right_arrow_shape(\u0026self) -\u003e Option\u003cArrowShape\u003e {\n        self.edge.right_arrow_shape()\n    }\n}\n\nimpl Display for ClassEdge {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        use crate::traits::TabbedDisplay;\n        self.fmt_tabbed(f, 0)\n    }\n}\n\nimpl crate::traits::TabbedDisplay for ClassEdge {\n    fn fmt_tabbed(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e, tab_count: usize) -\u003e std::fmt::Result {\n        let indent = \" \".repeat(tab_count * 2);\n        writeln!(\n            f,\n            \"{indent}{NODE_LETTER}{} {left_multiplicity}{left_arrow}{segment}{right_arrow}{right_multiplicity} {NODE_LETTER}{}{}\",\n            self.source().id(),\n            self.destination().id(),\n            self.label().map_or_else(String::new, |label| format!(\" : \\\"`{label}`\\\"\")),\n            left_multiplicity =\n                self.left_multiplicity.as_ref().map_or_else(String::new, |lm| format!(\"{lm} \")),\n            left_arrow = self.left_arrow_shape().as_ref().map_or_else(|| \"\", |shape| shape.left()),\n            segment = match self.line_style() {\n                LineStyle::Solid =\u003e \"--\",\n                LineStyle::Thick =\u003e \"==\",\n                LineStyle::Dashed =\u003e \"..\",\n            },\n            right_arrow =\n                self.right_arrow_shape().as_ref().map_or_else(|| \"\", |shape| shape.right()),\n            right_multiplicity =\n                self.right_multiplicity.as_ref().map_or_else(String::new, |rm| format!(\" {rm}\")),\n        )\n    }\n}\n","traces":[{"line":52,"address":[625104],"length":1,"stats":{"Line":1}},{"line":53,"address":[625109],"length":1,"stats":{"Line":1}},{"line":56,"address":[625120],"length":1,"stats":{"Line":1}},{"line":57,"address":[625125],"length":1,"stats":{"Line":1}},{"line":60,"address":[625056],"length":1,"stats":{"Line":1}},{"line":61,"address":[625061],"length":1,"stats":{"Line":1}},{"line":64,"address":[625040],"length":1,"stats":{"Line":1}},{"line":65,"address":[625045],"length":1,"stats":{"Line":1}},{"line":68,"address":[625136],"length":1,"stats":{"Line":0}},{"line":69,"address":[625141],"length":1,"stats":{"Line":0}},{"line":72,"address":[625072],"length":1,"stats":{"Line":1}},{"line":73,"address":[625077],"length":1,"stats":{"Line":1}},{"line":76,"address":[625088],"length":1,"stats":{"Line":1}},{"line":77,"address":[625093],"length":1,"stats":{"Line":1}},{"line":82,"address":[627792],"length":1,"stats":{"Line":0}},{"line":84,"address":[627806],"length":1,"stats":{"Line":0}},{"line":89,"address":[625216,626896,626890],"length":1,"stats":{"Line":0}},{"line":90,"address":[625266,625343],"length":1,"stats":{"Line":0}},{"line":91,"address":[626119,625627,625710],"length":1,"stats":{"Line":0}},{"line":94,"address":[625408,625328],"length":1,"stats":{"Line":0}},{"line":95,"address":[625470],"length":1,"stats":{"Line":0}},{"line":96,"address":[625555],"length":1,"stats":{"Line":0}},{"line":98,"address":[625684,625611],"length":1,"stats":{"Line":0}},{"line":99,"address":[625699,625755],"length":1,"stats":{"Line":0}},{"line":100,"address":[625838],"length":1,"stats":{"Line":0}},{"line":101,"address":[625884],"length":1,"stats":{"Line":0}},{"line":102,"address":[625913],"length":1,"stats":{"Line":0}},{"line":103,"address":[625942],"length":1,"stats":{"Line":0}},{"line":106,"address":[625977],"length":1,"stats":{"Line":0}},{"line":108,"address":[626075],"length":1,"stats":{"Line":0}}],"covered":12,"coverable":30},{"path":["/","home","lucac","github","mermaid-builder","src","diagrams","class_diagram","class_node","builder.rs"],"content":"//! Submodule defining a builder struct for the class node in class diagrams.\n\nuse std::rc::Rc;\n\nuse crate::{\n    diagrams::class_diagram::class_node::{ClassAttribute, ClassMethod, ClassNode},\n    errors::NodeError,\n    shared::{ClickEvent, StyleClass, StyleClassError, generic_node::GenericNodeBuilder},\n    traits::NodeBuilder,\n};\n\n/// Builder for `ClassNode`.\n///\n/// # Example\n///\n/// ```\n/// use mermaid_builder::prelude::*;\n///\n/// let node = ClassNodeBuilder::default()\n///     .label(\"MyClass\")\n///     .unwrap()\n///     .annotation(\"interface\")\n///     .id(0)\n///     .build()\n///     .unwrap();\n/// ```\n#[derive(Default, Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\npub struct ClassNodeBuilder {\n    /// Underlying generic node builder.\n    builder: GenericNodeBuilder,\n    /// The click event associated with the node, if any.\n    click_event: Option\u003cClickEvent\u003e,\n    /// The annotation of the class node, which usually\n    /// contains functional information such as `trait`, `interface`, etc.\n    annotation: Option\u003cString\u003e,\n    /// Attributes of the class node.\n    attributes: Vec\u003cClassAttribute\u003e,\n    /// Methods of the class node.\n    methods: Vec\u003cClassMethod\u003e,\n}\n\nimpl ClassNodeBuilder {\n    /// Sets the click event for the class node.\n    #[must_use]\n    pub fn click_event(mut self, click_event: ClickEvent) -\u003e Self {\n        self.click_event = Some(click_event);\n        self\n    }\n\n    /// Sets the annotation for the class node.\n    #[must_use]\n    pub fn annotation\u003cS: ToString + ?Sized\u003e(mut self, annotation: \u0026S) -\u003e Self {\n        self.annotation = Some(annotation.to_string());\n        self\n    }\n\n    /// Adds an attribute to the class node.\n    #[must_use]\n    pub fn attribute(mut self, attribute: ClassAttribute) -\u003e Self {\n        self.attributes.push(attribute);\n        self\n    }\n\n    /// Adds a method to the class node.\n    #[must_use]\n    pub fn method(mut self, method: ClassMethod) -\u003e Self {\n        self.methods.push(method);\n        self\n    }\n}\n\nimpl TryFrom\u003cClassNodeBuilder\u003e for ClassNode {\n    type Error = NodeError;\n\n    fn try_from(builder: ClassNodeBuilder) -\u003e Result\u003cSelf, Self::Error\u003e {\n        Ok(ClassNode {\n            node: builder.builder.try_into()?,\n            click_event: builder.click_event,\n            annotation: builder.annotation,\n            attributes: builder.attributes,\n            methods: builder.methods,\n        })\n    }\n}\n\nimpl NodeBuilder for ClassNodeBuilder {\n    type Node = ClassNode;\n    type Error = NodeError;\n\n    fn build(self) -\u003e Result\u003cSelf::Node, Self::Error\u003e {\n        self.try_into()\n    }\n\n    fn id(mut self, id: u64) -\u003e Self {\n        self.builder = self.builder.id(id);\n        self\n    }\n\n    fn get_id(\u0026self) -\u003e Option\u003cu64\u003e {\n        self.builder.get_id()\n    }\n\n    fn label\u003cS: ToString\u003e(mut self, label: S) -\u003e Result\u003cSelf, Self::Error\u003e {\n        self.builder = self.builder.label(label)?;\n        Ok(self)\n    }\n\n    fn get_label(\u0026self) -\u003e Option\u003c\u0026String\u003e {\n        self.builder.get_label()\n    }\n\n    fn style_class(mut self, style_class: Rc\u003cStyleClass\u003e) -\u003e Result\u003cSelf, StyleClassError\u003e {\n        self.builder = self.builder.style_class(style_class)?;\n        Ok(self)\n    }\n\n    fn style_property(\n        mut self,\n        property: crate::shared::StyleProperty,\n    ) -\u003e Result\u003cSelf, StyleClassError\u003e {\n        self.builder = self.builder.style_property(property)?;\n        Ok(self)\n    }\n\n    fn style_properties(\u0026self) -\u003e impl Iterator\u003cItem = \u0026crate::prelude::StyleProperty\u003e {\n        self.builder.style_properties()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::{\n        diagrams::class_diagram::class_node::{ClassAttribute, ClassMethod},\n        shared::{\n            ClickEvent, StyleClassBuilder, StyleProperty,\n            click_event::Navigation,\n            style_class::Unit,\n        },\n        traits::node::Node,\n    };\n\n    #[test]\n    fn test_class_node_builder() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n        let style_class = Rc::new(\n            StyleClassBuilder::default()\n                .name(\"test\")?\n                .property(StyleProperty::StrokeWidth(Unit::Pixel(2)))?\n                .build()?,\n        );\n        \n        let node = ClassNodeBuilder::default()\n            .id(1)\n            .label(\"MyClass\")?\n            .annotation(\"interface\")\n            .attribute(ClassAttribute::new(\"int\", \"id\"))\n            .method(ClassMethod::new(\"void\", \"method\", vec![]))\n            .click_event(ClickEvent::Navigation(Navigation::new(\"https://example.com\")))\n            .style_class(style_class.clone())?\n            .style_property(StyleProperty::StrokeWidth(Unit::Pixel(2)))?\n            .build()?;\n\n        assert_eq!(node.id(), 1);\n        assert_eq!(node.label(), \"MyClass\");\n        assert_eq!(node.annotation, Some(\"interface\".to_string()));\n        assert_eq!(node.attributes.len(), 1);\n        assert_eq!(node.methods.len(), 1);\n        assert!(matches!(node.click_event, Some(ClickEvent::Navigation(_))));\n        assert_eq!(node.classes().count(), 1);\n        assert_eq!(node.styles().count(), 1);\n        \n        Ok(())\n    }\n}\n","traces":[{"line":46,"address":[432000,432209],"length":1,"stats":{"Line":1}},{"line":47,"address":[432027,432157],"length":1,"stats":{"Line":2}},{"line":48,"address":[432189],"length":1,"stats":{"Line":1}},{"line":53,"address":[689984,690258],"length":1,"stats":{"Line":1}},{"line":54,"address":[690093,690047],"length":1,"stats":{"Line":2}},{"line":55,"address":[690235],"length":1,"stats":{"Line":1}},{"line":60,"address":[432416,432552],"length":1,"stats":{"Line":1}},{"line":61,"address":[432443],"length":1,"stats":{"Line":1}},{"line":62,"address":[432532],"length":1,"stats":{"Line":1}},{"line":67,"address":[432394,432240],"length":1,"stats":{"Line":1}},{"line":68,"address":[432270],"length":1,"stats":{"Line":1}},{"line":69,"address":[432371],"length":1,"stats":{"Line":1}},{"line":76,"address":[281226,280224],"length":1,"stats":{"Line":1}},{"line":77,"address":[280246,280812],"length":1,"stats":{"Line":2}},{"line":78,"address":[280310,280461],"length":1,"stats":{"Line":2}},{"line":79,"address":[280630],"length":1,"stats":{"Line":1}},{"line":80,"address":[280668],"length":1,"stats":{"Line":1}},{"line":81,"address":[280721],"length":1,"stats":{"Line":1}},{"line":82,"address":[280765],"length":1,"stats":{"Line":1}},{"line":91,"address":[434576],"length":1,"stats":{"Line":1}},{"line":92,"address":[434592],"length":1,"stats":{"Line":1}},{"line":95,"address":[434509,434304,434563],"length":1,"stats":{"Line":1}},{"line":96,"address":[434333,434462],"length":1,"stats":{"Line":3}},{"line":97,"address":[434486],"length":1,"stats":{"Line":2}},{"line":100,"address":[434640],"length":1,"stats":{"Line":0}},{"line":101,"address":[434645],"length":1,"stats":{"Line":0}},{"line":104,"address":[690288,690920],"length":1,"stats":{"Line":1}},{"line":105,"address":[690492,690326],"length":1,"stats":{"Line":2}},{"line":106,"address":[690668],"length":1,"stats":{"Line":1}},{"line":109,"address":[434656],"length":1,"stats":{"Line":0}},{"line":110,"address":[434661],"length":1,"stats":{"Line":0}},{"line":113,"address":[433293,432640],"length":1,"stats":{"Line":1}},{"line":114,"address":[432670,432836],"length":1,"stats":{"Line":2}},{"line":115,"address":[433041],"length":1,"stats":{"Line":1}},{"line":118,"address":[434172,433408],"length":1,"stats":{"Line":1}},{"line":122,"address":[433715,433466],"length":1,"stats":{"Line":2}},{"line":123,"address":[433920],"length":1,"stats":{"Line":1}},{"line":126,"address":[434288],"length":1,"stats":{"Line":0}},{"line":127,"address":[434293],"length":1,"stats":{"Line":0}}],"covered":33,"coverable":39},{"path":["/","home","lucac","github","mermaid-builder","src","diagrams","class_diagram","class_node","class_attribute.rs"],"content":"//! Submodule defining a class attribute struct for the class diagram in\n//! Mermaid syntax, including its visibility and type.\n\nuse std::fmt::Display;\n\nuse crate::diagrams::class_diagram::visibility::Visibility;\n\n#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// Struct representing a class attribute in a class diagram.\npub struct ClassAttribute {\n    /// The name of the class attribute.\n    name: String,\n    /// The type of the class attribute.\n    attribute_type: String,\n    /// The visibility of the class attribute (e.g., public, private).\n    visibility: Visibility,\n}\n\nimpl ClassAttribute {\n    /// Creates a new class attribute.\n    pub fn new(attribute_type: impl Into\u003cString\u003e, name: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            name: name.into(),\n            attribute_type: attribute_type.into(),\n            visibility: Visibility::Public,\n        }\n    }\n}\n\nimpl Display for ClassAttribute {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{} {}: {}\", self.visibility, self.name, self.attribute_type)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_class_attribute_display() {\n        let attr = ClassAttribute {\n            name: \"attr1\".to_string(),\n            attribute_type: \"int\".to_string(),\n            visibility: Visibility::Public,\n        };\n        assert_eq!(attr.to_string(), \"+ attr1: int\");\n    }\n}\n","traces":[{"line":22,"address":[302256,302262,301968],"length":1,"stats":{"Line":1}},{"line":24,"address":[302042],"length":1,"stats":{"Line":1}},{"line":25,"address":[302119],"length":1,"stats":{"Line":1}},{"line":32,"address":[546672],"length":1,"stats":{"Line":1}},{"line":33,"address":[546703],"length":1,"stats":{"Line":1}}],"covered":5,"coverable":5},{"path":["/","home","lucac","github","mermaid-builder","src","diagrams","class_diagram","class_node","class_method.rs"],"content":"//! Submodule defining a class method struct for the class diagram in\n//! Mermaid syntax, including its visibility and parameters signatures.\n\nuse std::fmt::Display;\n\nuse crate::diagrams::class_diagram::visibility::Visibility;\n\n#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// Represents a method argument in a Mermaid class diagram.\npub struct Argument {\n    /// The name of the argument (e.g., `x`).\n    name: String,\n    /// The type of the argument (e.g., `int`, `String`).\n    arg_type: String,\n}\n\nimpl Display for Argument {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{}: {}\", self.name, self.arg_type)\n    }\n}\n\n#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// Represents a class method for Mermaid class diagrams, including its name,\n/// arguments, and visibility.\npub struct ClassMethod {\n    /// The name of the class method (e.g., `doSomething`).\n    name: String,\n    /// The list of arguments for the method, each with a name and type.\n    arguments: Vec\u003cArgument\u003e,\n    /// The return type of the method (e.g., `void`, `int`).\n    return_type: Option\u003cString\u003e,\n    /// The visibility of the method (e.g., public, private, protected).\n    visibility: Visibility,\n}\n\nimpl ClassMethod {\n    /// Creates a new class method.\n    pub fn new(\n        return_type: impl Into\u003cString\u003e,\n        name: impl Into\u003cString\u003e,\n        arguments: Vec\u003cArgument\u003e,\n    ) -\u003e Self {\n        Self {\n            name: name.into(),\n            arguments,\n            return_type: Some(return_type.into()),\n            visibility: Visibility::Public,\n        }\n    }\n}\n\nimpl Display for ClassMethod {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{}\", self.visibility)?;\n        write!(f, \"{}\", self.name)?;\n\n        if self.arguments.is_empty() {\n            write!(f, \"()\")?;\n        } else {\n            write!(f, \"(\")?;\n            for (i, arg) in self.arguments.iter().enumerate() {\n                if i \u003e 0 {\n                    write!(f, \", \")?;\n                }\n                write!(f, \"{arg}\")?;\n            }\n            write!(f, \")\")?;\n        }\n\n        if let Some(return_type) = \u0026self.return_type {\n            write!(f, \": {return_type}\")?;\n        } else {\n            write!(f, \": void\")?;\n        }\n\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_argument_display() {\n        let arg = Argument { name: \"arg1\".to_string(), arg_type: \"int\".to_string() };\n        assert_eq!(arg.to_string(), \"arg1: int\");\n    }\n\n    #[test]\n    fn test_class_method_display() {\n        let method = ClassMethod {\n            name: \"method1\".to_string(),\n            arguments: vec![\n                Argument { name: \"arg1\".to_string(), arg_type: \"int\".to_string() },\n                Argument { name: \"arg2\".to_string(), arg_type: \"String\".to_string() },\n            ],\n            return_type: Some(\"bool\".to_string()),\n            visibility: Visibility::Public,\n        };\n        assert_eq!(method.to_string(), \"+method1(arg1: int, arg2: String): bool\");\n\n        let method_void = ClassMethod {\n            name: \"method2\".to_string(),\n            arguments: vec![],\n            return_type: None,\n            visibility: Visibility::Private,\n        };\n        assert_eq!(method_void.to_string(), \"-method2(): void\");\n    }\n}\n","traces":[{"line":19,"address":[510960],"length":1,"stats":{"Line":1}},{"line":20,"address":[510985],"length":1,"stats":{"Line":1}},{"line":41,"address":[242562,242128,242610],"length":1,"stats":{"Line":1}},{"line":47,"address":[242217],"length":1,"stats":{"Line":1}},{"line":49,"address":[242348,242425],"length":1,"stats":{"Line":2}},{"line":56,"address":[511248],"length":1,"stats":{"Line":1}},{"line":57,"address":[511287],"length":1,"stats":{"Line":1}},{"line":58,"address":[511412],"length":1,"stats":{"Line":1}},{"line":60,"address":[511534],"length":1,"stats":{"Line":1}},{"line":61,"address":[512270,511603],"length":1,"stats":{"Line":1}},{"line":63,"address":[511666,511547],"length":1,"stats":{"Line":1}},{"line":64,"address":[511781,511694],"length":1,"stats":{"Line":2}},{"line":65,"address":[511873],"length":1,"stats":{"Line":1}},{"line":66,"address":[512166],"length":1,"stats":{"Line":1}},{"line":68,"address":[512034,512247],"length":1,"stats":{"Line":1}},{"line":70,"address":[511888],"length":1,"stats":{"Line":1}},{"line":73,"address":[512297,511967],"length":1,"stats":{"Line":2}},{"line":74,"address":[512489,512305],"length":1,"stats":{"Line":1}},{"line":76,"address":[512522,512433],"length":1,"stats":{"Line":1}},{"line":79,"address":[512512],"length":1,"stats":{"Line":1}}],"covered":20,"coverable":20},{"path":["/","home","lucac","github","mermaid-builder","src","diagrams","class_diagram","class_node.rs"],"content":"//! Submodule defining a node struct for the class diagram in\n//! Mermaid syntax.\n\nmod builder;\nmod class_attribute;\nmod class_method;\nuse std::fmt::Display;\n\npub use builder::ClassNodeBuilder;\npub use class_attribute::ClassAttribute;\npub use class_method::ClassMethod;\n\nuse crate::{\n    shared::{ClickEvent, GenericNode, NODE_LETTER, StyleClass, StyleProperty},\n    traits::Node,\n};\n\n#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// Struct representing a class node in a class diagram.\n///\n/// # Examples\n///\n/// ```\n/// use mermaid_builder::{\n///     diagrams::class_diagram::ClassNodeBuilder,\n///     traits::{Node, NodeBuilder},\n/// };\n///\n/// fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n///     let node =\n///         ClassNodeBuilder::default().label(\"MyClass\")?.id(1).annotation(\"interface\").build()?;\n///\n///     assert_eq!(node.label(), \"MyClass\");\n///     Ok(())\n/// }\n/// ```\npub struct ClassNode {\n    /// Underlying generic node.\n    node: GenericNode,\n    /// The click event associated with the node, if any.\n    click_event: Option\u003cClickEvent\u003e,\n    /// The annotation of the class node, which usually\n    /// contains functional information such as `trait`, `interface`, etc.\n    annotation: Option\u003cString\u003e,\n    /// Attributes of the class node.\n    attributes: Vec\u003cClassAttribute\u003e,\n    /// Methods of the class node.\n    methods: Vec\u003cClassMethod\u003e,\n}\n\nimpl Node for ClassNode {\n    type Builder = ClassNodeBuilder;\n\n    fn label(\u0026self) -\u003e \u0026str {\n        self.node.label()\n    }\n\n    fn id(\u0026self) -\u003e u64 {\n        self.node.id()\n    }\n\n    fn styles(\u0026self) -\u003e impl Iterator\u003cItem = \u0026StyleProperty\u003e {\n        self.node.styles()\n    }\n\n    fn classes(\u0026self) -\u003e impl Iterator\u003cItem = \u0026StyleClass\u003e {\n        self.node.classes()\n    }\n\n    fn is_compatible_arrow_shape(shape: crate::shared::ArrowShape) -\u003e bool {\n        matches!(\n            shape,\n            crate::shared::ArrowShape::Triangle\n                | crate::shared::ArrowShape::Star\n                | crate::shared::ArrowShape::Circle\n                | crate::shared::ArrowShape::Normal\n        )\n    }\n}\n\nimpl Display for ClassNode {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        use crate::traits::TabbedDisplay;\n        self.fmt_tabbed(f, 0)\n    }\n}\n\nimpl crate::traits::TabbedDisplay for ClassNode {\n    fn fmt_tabbed(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e, tab_count: usize) -\u003e std::fmt::Result {\n        let indent = \" \".repeat(tab_count * 2);\n        writeln!(f, \"{indent}class {NODE_LETTER}{}[{}] {{\", self.id(), self.label())?;\n        if let Some(annotation) = \u0026self.annotation {\n            writeln!(f, \"{indent}    \u003c\u003c{annotation}\u003e\u003e\")?;\n        }\n\n        for attr in \u0026self.attributes {\n            writeln!(f, \"{indent}    {attr}\")?;\n        }\n        for method in \u0026self.methods {\n            writeln!(f, \"{indent}    {method}\")?;\n        }\n        writeln!(f, \"{indent}}}\")?;\n\n        if let Some(click_event) = \u0026self.click_event {\n            writeln!(f, \"{indent}click {NODE_LETTER}{} {}\", self.id(), click_event)?;\n        }\n\n        for class in self.classes() {\n            writeln!(f, \"{indent}cssClass {NODE_LETTER}{} {}\", self.id(), class.name())?;\n        }\n\n        Ok(())\n    }\n}\n","traces":[{"line":55,"address":[275056],"length":1,"stats":{"Line":1}},{"line":56,"address":[275061],"length":1,"stats":{"Line":1}},{"line":59,"address":[275040],"length":1,"stats":{"Line":1}},{"line":60,"address":[275045],"length":1,"stats":{"Line":1}},{"line":63,"address":[275072],"length":1,"stats":{"Line":1}},{"line":64,"address":[275077],"length":1,"stats":{"Line":1}},{"line":67,"address":[275088],"length":1,"stats":{"Line":1}},{"line":68,"address":[275093],"length":1,"stats":{"Line":1}},{"line":71,"address":[274976],"length":1,"stats":{"Line":1}},{"line":72,"address":[274991],"length":1,"stats":{"Line":1}},{"line":73,"address":[274983],"length":1,"stats":{"Line":1}},{"line":83,"address":[280192],"length":1,"stats":{"Line":0}},{"line":85,"address":[280206],"length":1,"stats":{"Line":0}},{"line":90,"address":[278422,275168,278416],"length":1,"stats":{"Line":0}},{"line":91,"address":[275218,275295],"length":1,"stats":{"Line":0}},{"line":92,"address":[275368,275280,278402],"length":1,"stats":{"Line":0}},{"line":93,"address":[275821],"length":1,"stats":{"Line":0}},{"line":94,"address":[275898,275995],"length":1,"stats":{"Line":0}},{"line":97,"address":[275949,276237],"length":1,"stats":{"Line":0}},{"line":98,"address":[278217,276347],"length":1,"stats":{"Line":0}},{"line":100,"address":[276401],"length":1,"stats":{"Line":0}},{"line":101,"address":[276554,278023],"length":1,"stats":{"Line":0}},{"line":103,"address":[276608,277993],"length":1,"stats":{"Line":0}},{"line":105,"address":[276806],"length":1,"stats":{"Line":0}},{"line":106,"address":[276883,276940],"length":1,"stats":{"Line":0}},{"line":109,"address":[277364,276906],"length":1,"stats":{"Line":0}},{"line":110,"address":[277500,277561],"length":1,"stats":{"Line":0}},{"line":113,"address":[277512],"length":1,"stats":{"Line":0}}],"covered":11,"coverable":28},{"path":["/","home","lucac","github","mermaid-builder","src","diagrams","class_diagram","configuration","builder.rs"],"content":"//! Submodule providing a builder struct for the configuration of class diagrams\n//! in Mermaid syntax.\n\nuse crate::{\n    diagrams::class_diagram::configuration::ClassDiagramConfiguration, errors::ConfigError,\n    shared::generic_configuration::GenericConfigurationBuilder, traits::ConfigurationBuilder,\n};\n\n#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\npub struct ClassDiagramConfigurationBuilder {\n    /// Generic configuration options which apply to all Mermaid diagrams.\n    generic: GenericConfigurationBuilder,\n    /// Whether to hide empty members in the class diagram.\n    hide_empty_members_box: bool,\n}\n\nimpl ClassDiagramConfigurationBuilder {\n    /// Sets whether to hide empty members in the class diagram.\n    pub fn hide_empty_members_box(mut self, hide: bool) -\u003e Self {\n        self.hide_empty_members_box = hide;\n        self\n    }\n\n    /// Sets the theme to use for the diagram.\n    pub fn theme(mut self, theme: crate::shared::generic_configuration::Theme) -\u003e Self {\n        self.generic = self.generic.theme(theme);\n        self\n    }\n\n    /// Sets the look to use for the diagram.\n    pub fn look(mut self, look: crate::shared::generic_configuration::Look) -\u003e Self {\n        self.generic = self.generic.look(look);\n        self\n    }\n}\n\nimpl TryFrom\u003cClassDiagramConfigurationBuilder\u003e for ClassDiagramConfiguration {\n    type Error = ConfigError;\n\n    fn try_from(builder: ClassDiagramConfigurationBuilder) -\u003e Result\u003cSelf, Self::Error\u003e {\n        Ok(ClassDiagramConfiguration {\n            generic: builder.generic.try_into()?,\n            hide_empty_members_box: builder.hide_empty_members_box,\n        })\n    }\n}\n\nimpl ConfigurationBuilder for ClassDiagramConfigurationBuilder {\n    type Configuration = ClassDiagramConfiguration;\n    type Error = ConfigError;\n\n    fn build(self) -\u003e Result\u003cSelf::Configuration, Self::Error\u003e {\n        self.try_into()\n    }\n\n    fn title\u003cS: ToString\u003e(mut self, title: S) -\u003e Result\u003cSelf, Self::Error\u003e {\n        self.generic = self.generic.title(title)?;\n        Ok(self)\n    }\n\n    fn direction(mut self, direction: crate::shared::generic_configuration::Direction) -\u003e Self {\n        self.generic = self.generic.direction(direction);\n        self\n    }\n\n    fn renderer(mut self, renderer: crate::shared::generic_configuration::Renderer) -\u003e Self {\n        self.generic = self.generic.renderer(renderer);\n        self\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::{\n        shared::generic_configuration::{Direction, Look, Renderer, Theme},\n        traits::Configuration,\n    };\n\n    #[test]\n    fn test_class_diagram_configuration_builder() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n        let config = ClassDiagramConfigurationBuilder::default()\n            .title(\"My Class Diagram\")?\n            .direction(Direction::LeftToRight)\n            .renderer(Renderer::Dagre)\n            .theme(Theme::Forest)\n            .look(Look::HandDrawn)\n            .hide_empty_members_box(true)\n            .build()?;\n\n        assert!(config.hide_empty_members_box);\n        assert_eq!(config.title(), Some(\"My Class Diagram\"));\n        assert_eq!(config.direction(), Direction::LeftToRight);\n        assert_eq!(config.renderer(), Renderer::Dagre);\n        assert_eq!(config.theme(), Theme::Forest);\n        assert_eq!(config.look(), Look::HandDrawn);\n        Ok(())\n    }\n}\n","traces":[{"line":20,"address":[800528],"length":1,"stats":{"Line":1}},{"line":21,"address":[800551],"length":1,"stats":{"Line":1}},{"line":22,"address":[800556],"length":1,"stats":{"Line":1}},{"line":26,"address":[800720],"length":1,"stats":{"Line":1}},{"line":27,"address":[800745],"length":1,"stats":{"Line":1}},{"line":28,"address":[800843],"length":1,"stats":{"Line":1}},{"line":32,"address":[800576],"length":1,"stats":{"Line":1}},{"line":33,"address":[800601],"length":1,"stats":{"Line":1}},{"line":34,"address":[800699],"length":1,"stats":{"Line":1}},{"line":41,"address":[344096],"length":1,"stats":{"Line":1}},{"line":42,"address":[344317],"length":1,"stats":{"Line":1}},{"line":43,"address":[344117],"length":1,"stats":{"Line":1}},{"line":44,"address":[344314],"length":1,"stats":{"Line":1}},{"line":53,"address":[800928],"length":1,"stats":{"Line":1}},{"line":54,"address":[800941],"length":1,"stats":{"Line":1}},{"line":57,"address":[803531,803120,803506],"length":1,"stats":{"Line":1}},{"line":58,"address":[803267,803504,803158],"length":1,"stats":{"Line":2}},{"line":59,"address":[803442],"length":1,"stats":{"Line":1}},{"line":62,"address":[801152],"length":1,"stats":{"Line":1}},{"line":63,"address":[801177],"length":1,"stats":{"Line":1}},{"line":64,"address":[801275],"length":1,"stats":{"Line":1}},{"line":67,"address":[800992],"length":1,"stats":{"Line":1}},{"line":68,"address":[801022],"length":1,"stats":{"Line":1}},{"line":69,"address":[801123],"length":1,"stats":{"Line":1}}],"covered":24,"coverable":24},{"path":["/","home","lucac","github","mermaid-builder","src","diagrams","class_diagram","configuration.rs"],"content":"//! Submodule defining configuration specifically for class diagrams in\n//! Mermaid.\n\nmod builder;\nuse std::fmt::Display;\n\npub use builder::ClassDiagramConfigurationBuilder;\n\nuse crate::{\n    shared::{\n        Direction, Renderer,\n        generic_configuration::{GenericConfiguration, Look, Theme},\n    },\n    traits::Configuration,\n};\n\n#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// Configuration for class diagrams in Mermaid syntax.\npub struct ClassDiagramConfiguration {\n    /// Generic configuration options which apply to all Mermaid diagrams.\n    generic: GenericConfiguration,\n    /// Whether to hide empty members in the class diagram.\n    hide_empty_members_box: bool,\n}\n\nimpl Display for ClassDiagramConfiguration {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        writeln!(f, \"---\")?;\n        if let Some(title) = \u0026self.title() {\n            writeln!(f, \"title: {title}\")?;\n        }\n        writeln!(f, \"config:\")?;\n        writeln!(f, \"  class:\")?;\n        writeln!(f, \"    hideEmptyMembersBox: \\\"{}\\\"\", self.hide_empty_members_box)?;\n        writeln!(f, \"---\")?;\n\n        Ok(())\n    }\n}\n\nimpl Configuration for ClassDiagramConfiguration {\n    type Builder = ClassDiagramConfigurationBuilder;\n\n    fn title(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n        self.generic.title()\n    }\n\n    fn direction(\u0026self) -\u003e Direction {\n        self.generic.direction()\n    }\n\n    fn renderer(\u0026self) -\u003e Renderer {\n        self.generic.renderer()\n    }\n\n    fn theme(\u0026self) -\u003e Theme {\n        self.generic.theme()\n    }\n\n    fn look(\u0026self) -\u003e Look {\n        self.generic.look()\n    }\n}\n","traces":[{"line":28,"address":[342512],"length":1,"stats":{"Line":0}},{"line":29,"address":[342542],"length":1,"stats":{"Line":0}},{"line":30,"address":[342624],"length":1,"stats":{"Line":0}},{"line":31,"address":[342677,342836],"length":1,"stats":{"Line":0}},{"line":33,"address":[342780,342868],"length":1,"stats":{"Line":0}},{"line":34,"address":[342888],"length":1,"stats":{"Line":0}},{"line":35,"address":[342967],"length":1,"stats":{"Line":0}},{"line":36,"address":[343087],"length":1,"stats":{"Line":0}},{"line":38,"address":[343164],"length":1,"stats":{"Line":0}},{"line":45,"address":[344048],"length":1,"stats":{"Line":1}},{"line":46,"address":[344053],"length":1,"stats":{"Line":1}},{"line":49,"address":[344080],"length":1,"stats":{"Line":1}},{"line":50,"address":[344085],"length":1,"stats":{"Line":1}},{"line":53,"address":[344064],"length":1,"stats":{"Line":1}},{"line":54,"address":[344069],"length":1,"stats":{"Line":1}},{"line":57,"address":[344032],"length":1,"stats":{"Line":1}},{"line":58,"address":[344037],"length":1,"stats":{"Line":1}},{"line":61,"address":[344016],"length":1,"stats":{"Line":1}},{"line":62,"address":[344021],"length":1,"stats":{"Line":1}}],"covered":10,"coverable":19},{"path":["/","home","lucac","github","mermaid-builder","src","diagrams","class_diagram","visibility.rs"],"content":"//! Submodule providing an enumeration for visibility modifiers employable\n//! in class entries of Mermaid class diagrams.\n//!\n//! These include: Public (`+`), Private (`-`), Protected (`#`), and\n//! Package/Internal (`~`).\n\nuse std::fmt::Display;\n\n#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// An enumeration representing the visibility of class members in Mermaid class\n/// diagrams.\npub enum Visibility {\n    /// Public visibility, denoted by `+`.\n    Public,\n    /// Private visibility, denoted by `-`.\n    Private,\n    /// Protected visibility, denoted by `#`.\n    Protected,\n    /// Package/Internal visibility, denoted by `~`.\n    Package,\n}\n\nimpl Display for Visibility {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Visibility::Public =\u003e write!(f, \"+\"),\n            Visibility::Private =\u003e write!(f, \"-\"),\n            Visibility::Protected =\u003e write!(f, \"#\"),\n            Visibility::Package =\u003e write!(f, \"~\"),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_visibility_display() {\n        assert_eq!(Visibility::Public.to_string(), \"+\");\n        assert_eq!(Visibility::Private.to_string(), \"-\");\n        assert_eq!(Visibility::Protected.to_string(), \"#\");\n        assert_eq!(Visibility::Package.to_string(), \"~\");\n    }\n}\n","traces":[{"line":25,"address":[389632],"length":1,"stats":{"Line":1}},{"line":26,"address":[389650],"length":1,"stats":{"Line":1}},{"line":27,"address":[389681],"length":1,"stats":{"Line":3}},{"line":28,"address":[389718],"length":1,"stats":{"Line":1}},{"line":29,"address":[389755],"length":1,"stats":{"Line":1}},{"line":30,"address":[389792],"length":1,"stats":{"Line":1}}],"covered":6,"coverable":6},{"path":["/","home","lucac","github","mermaid-builder","src","diagrams","class_diagram.rs"],"content":"//! Submodule defining a class diagram in Mermaid syntax.\n\npub mod class_edge;\npub mod class_node;\nmod configuration;\npub mod visibility;\nuse std::fmt::Display;\n\nuse class_edge::ClassEdge;\npub use class_edge::ClassEdgeBuilder;\nuse class_node::ClassNode;\npub use class_node::ClassNodeBuilder;\npub use configuration::ClassDiagramConfiguration;\n\nuse crate::{\n    shared::generic_diagram::{GenericDiagram, GenericDiagramBuilder},\n    traits::{configuration::Configuration, diagram::Diagram},\n};\n\n/// Represents a class diagram in Mermaid syntax.\npub type ClassDiagram = GenericDiagram\u003cClassNode, ClassEdge, ClassDiagramConfiguration\u003e;\n/// Represents a builder for a class diagram in Mermaid syntax.\npub type ClassDiagramBuilder =\n    GenericDiagramBuilder\u003cClassNode, ClassEdge, ClassDiagramConfiguration\u003e;\n\nimpl Display for ClassDiagram {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        use crate::traits::TabbedDisplay;\n        self.fmt_tabbed(f, 0)\n    }\n}\n\nimpl crate::traits::TabbedDisplay for ClassDiagram {\n    fn fmt_tabbed(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e, tab_count: usize) -\u003e std::fmt::Result {\n        let indent = \" \".repeat(tab_count * 2);\n        write!(f, \"{}\", self.configuration())?; // Configuration might need tabbed display too? Usually it's frontmatter or directives.\n        writeln!(f, \"{indent}classDiagram\")?;\n        writeln!(f, \"{indent}  direction {}\", self.configuration().direction())?;\n        for style_class in self.style_classes() {\n            style_class.fmt_tabbed(f, tab_count + 1)?;\n        }\n        for node in self.nodes() {\n            node.fmt_tabbed(f, tab_count + 1)?;\n        }\n        for edge in self.edges() {\n            edge.fmt_tabbed(f, tab_count + 1)?;\n        }\n        Ok(())\n    }\n}\n","traces":[{"line":27,"address":[566784],"length":1,"stats":{"Line":0}},{"line":29,"address":[566798],"length":1,"stats":{"Line":0}},{"line":34,"address":[566976,569021,569027],"length":1,"stats":{"Line":0}},{"line":35,"address":[567111,567034],"length":1,"stats":{"Line":0}},{"line":36,"address":[567096,567176,569007],"length":1,"stats":{"Line":0}},{"line":37,"address":[568986,567390],"length":1,"stats":{"Line":0}},{"line":38,"address":[567592,568965],"length":1,"stats":{"Line":0}},{"line":39,"address":[567904],"length":1,"stats":{"Line":0}},{"line":40,"address":[568100,568848],"length":1,"stats":{"Line":0}},{"line":42,"address":[568137],"length":1,"stats":{"Line":0}},{"line":43,"address":[568300,568714],"length":1,"stats":{"Line":0}},{"line":45,"address":[568334],"length":1,"stats":{"Line":0}},{"line":46,"address":[568497,568573],"length":1,"stats":{"Line":0}},{"line":48,"address":[568516],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":14},{"path":["/","home","lucac","github","mermaid-builder","src","diagrams","entity_relationship","entity_relationship_edge.rs"],"content":"//! Submodule defining an edge struct for entity-relationship diagrams in\n//! Mermaid syntax.\n\nuse std::{fmt::Display, rc::Rc};\n\nuse crate::{\n    diagrams::entity_relationship::entity_relationship_node::ERNode,\n    shared::{ArrowShape, GenericEdge, LineStyle, NODE_LETTER, generic_edge::GenericEdgeBuilder},\n    traits::{edge::Edge, edge_builder::EdgeBuilder, node::Node},\n};\n/// Type alias for an entity-relationship edge builder.\npub type EREdgeBuilder = GenericEdgeBuilder\u003cERNode\u003e;\n/// Type alias for an entity-relationship edge.\npub type EREdge = GenericEdge\u003cERNode\u003e;\n\nimpl EREdgeBuilder {\n    /// Creates a new entity-relationship edge builder.\n    ///\n    /// # Arguments\n    ///\n    /// * `source` - The source node of the edge.\n    /// * `destination` - The destination node of the edge.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use std::rc::Rc;\n    ///\n    /// use mermaid_builder::prelude::*;\n    ///\n    /// fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    ///     let node1 = Rc::new(ERNodeBuilder::default().label(\"A\")?.id(0).build()?);\n    ///     let node2 = Rc::new(ERNodeBuilder::default().label(\"B\")?.id(1).build()?);\n    ///\n    ///     let builder = EREdgeBuilder::zero_or_one(node1, node2);\n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn zero_or_one(source: Rc\u003cERNode\u003e, destination: Rc\u003cERNode\u003e) -\u003e Self {\n        Self::default()\n            .source(source)\n            .unwrap()\n            .destination(destination)\n            .unwrap()\n            .left_arrow_shape(ArrowShape::ZeroOrOne)\n            .unwrap()\n            .right_arrow_shape(ArrowShape::ZeroOrOne)\n            .unwrap()\n            .line_style(LineStyle::Solid)\n    }\n\n    /// Creates a new entity-relationship edge builder with a one-to-one\n    /// relationship.\n    ///\n    /// # Arguments\n    ///\n    /// * `source` - The source node of the edge.\n    /// * `destination` - The destination node of the edge.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use std::rc::Rc;\n    ///\n    /// use mermaid_builder::prelude::*;\n    ///\n    /// fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    ///     let node1 = Rc::new(ERNodeBuilder::default().label(\"A\")?.id(0).build()?);\n    ///     let node2 = Rc::new(ERNodeBuilder::default().label(\"B\")?.id(1).build()?);\n    ///\n    ///     let builder = EREdgeBuilder::one_to_one(node1, node2);\n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn one_to_one(source: Rc\u003cERNode\u003e, destination: Rc\u003cERNode\u003e) -\u003e Self {\n        Self::default()\n            .source(source)\n            .unwrap()\n            .destination(destination)\n            .unwrap()\n            .left_arrow_shape(ArrowShape::ExactlyOne)\n            .unwrap()\n            .right_arrow_shape(ArrowShape::ExactlyOne)\n            .unwrap()\n            .line_style(LineStyle::Solid)\n    }\n\n    /// Creates a new entity-relationship edge builder with a zero-or-one\n    /// relationship.\n    ///\n    /// # Arguments\n    ///\n    /// * `source` - The source node of the edge.\n    /// * `destination` - The destination node of the edge.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use std::rc::Rc;\n    ///\n    /// use mermaid_builder::prelude::*;\n    ///\n    /// fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    ///     let node1 = Rc::new(ERNodeBuilder::default().label(\"A\")?.id(0).build()?);\n    ///     let node2 = Rc::new(ERNodeBuilder::default().label(\"B\")?.id(1).build()?);\n    ///\n    ///     let builder = EREdgeBuilder::zero_or_more(node1, node2);\n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn zero_or_more(source: Rc\u003cERNode\u003e, destination: Rc\u003cERNode\u003e) -\u003e Self {\n        Self::default()\n            .source(source)\n            .unwrap()\n            .destination(destination)\n            .unwrap()\n            .left_arrow_shape(ArrowShape::ZeroOrMore)\n            .unwrap()\n            .right_arrow_shape(ArrowShape::ZeroOrMore)\n            .unwrap()\n            .line_style(LineStyle::Solid)\n    }\n\n    /// Creates a new entity-relationship edge builder with a one-or-more\n    /// relationship.\n    ///\n    /// # Arguments\n    ///\n    /// * `source` - The source node of the edge.\n    /// * `destination` - The destination node of the edge.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use std::rc::Rc;\n    ///\n    /// use mermaid_builder::prelude::*;\n    ///\n    /// fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    ///     let node1 = Rc::new(ERNodeBuilder::default().label(\"A\")?.id(0).build()?);\n    ///     let node2 = Rc::new(ERNodeBuilder::default().label(\"B\")?.id(1).build()?);\n    ///\n    ///     let builder = EREdgeBuilder::one_or_more(node1, node2);\n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn one_or_more(source: Rc\u003cERNode\u003e, destination: Rc\u003cERNode\u003e) -\u003e Self {\n        Self::default()\n            .source(source)\n            .unwrap()\n            .destination(destination)\n            .unwrap()\n            .left_arrow_shape(ArrowShape::OneOrMore)\n            .unwrap()\n            .right_arrow_shape(ArrowShape::OneOrMore)\n            .unwrap()\n            .line_style(LineStyle::Solid)\n    }\n}\n\nimpl Display for EREdge {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        use crate::traits::TabbedDisplay;\n        self.fmt_tabbed(f, 0)\n    }\n}\n\nimpl crate::traits::TabbedDisplay for EREdge {\n    fn fmt_tabbed(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e, tab_count: usize) -\u003e std::fmt::Result {\n        let indent = \" \".repeat(tab_count * 2);\n        writeln!(\n            f,\n            \"{indent}{NODE_LETTER}{} {left_arrow}{segment}{right_arrow} {NODE_LETTER}{} : \\\"{label}\\\"\",\n            self.source().id(),\n            self.destination().id(),\n            label = self.label().unwrap_or(\"\"),\n            left_arrow = self.left_arrow_shape().as_ref().map_or_else(|| \"\", |shape| shape.left()),\n            segment = match self.line_style() {\n                LineStyle::Solid =\u003e \"--\",\n                LineStyle::Thick =\u003e \"==\",\n                LineStyle::Dashed =\u003e \"..\",\n            },\n            right_arrow =\n                self.right_arrow_shape().as_ref().map_or_else(|| \"\", |shape| shape.right()),\n        )\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::diagrams::entity_relationship::entity_relationship_node::ERNodeBuilder;\n    use crate::traits::node_builder::NodeBuilder;\n\n    #[test]\n    fn test_er_edge_builder_methods() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n        let node1 = Rc::new(ERNodeBuilder::default().label(\"A\")?.id(0).build()?);\n        let node2 = Rc::new(ERNodeBuilder::default().label(\"B\")?.id(1).build()?);\n\n        let edge_zero_one = EREdgeBuilder::zero_or_one(node1.clone(), node2.clone()).build()?;\n        assert_eq!(edge_zero_one.left_arrow_shape(), Some(ArrowShape::ZeroOrOne));\n        assert_eq!(edge_zero_one.right_arrow_shape(), Some(ArrowShape::ZeroOrOne));\n\n        let edge_one_one = EREdgeBuilder::one_to_one(node1.clone(), node2.clone()).build()?;\n        assert_eq!(edge_one_one.left_arrow_shape(), Some(ArrowShape::ExactlyOne));\n        assert_eq!(edge_one_one.right_arrow_shape(), Some(ArrowShape::ExactlyOne));\n\n        let edge_zero_more = EREdgeBuilder::zero_or_more(node1.clone(), node2.clone()).build()?;\n        assert_eq!(edge_zero_more.left_arrow_shape(), Some(ArrowShape::ZeroOrMore));\n        assert_eq!(edge_zero_more.right_arrow_shape(), Some(ArrowShape::ZeroOrMore));\n\n        let edge_one_more = EREdgeBuilder::one_or_more(node1.clone(), node2.clone()).build()?;\n        assert_eq!(edge_one_more.left_arrow_shape(), Some(ArrowShape::OneOrMore));\n        assert_eq!(edge_one_more.right_arrow_shape(), Some(ArrowShape::OneOrMore));\n\n        Ok(())\n    }\n\n    #[test]\n    fn test_er_edge_display() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n        let node1 = Rc::new(ERNodeBuilder::default().label(\"A\")?.id(0).build()?);\n        let node2 = Rc::new(ERNodeBuilder::default().label(\"B\")?.id(1).build()?);\n\n        let edge = EREdgeBuilder::zero_or_one(node1, node2)\n            .label(\"relates to\")?\n            .build()?;\n\n        let output = format!(\"{}\", edge);\n        // Expected format: v0 |o--o| v1 : \"relates to\"\n        assert!(output.contains(\"v0\"));\n        assert!(output.contains(\"v1\"));\n        assert!(output.contains(\"relates to\"));\n        assert!(output.contains(\"|o--o|\"));\n\n        Ok(())\n    }\n}\n","traces":[{"line":39,"address":[424584,424590,424176],"length":1,"stats":{"Line":2}},{"line":40,"address":[424202],"length":1,"stats":{"Line":2}},{"line":41,"address":[424290],"length":1,"stats":{"Line":2}},{"line":43,"address":[424356],"length":1,"stats":{"Line":2}},{"line":45,"address":[424443],"length":1,"stats":{"Line":2}},{"line":47,"address":[424498],"length":1,"stats":{"Line":2}},{"line":49,"address":[424540],"length":1,"stats":{"Line":2}},{"line":75,"address":[423280,423694,423688],"length":1,"stats":{"Line":1}},{"line":76,"address":[423306],"length":1,"stats":{"Line":1}},{"line":77,"address":[423394],"length":1,"stats":{"Line":1}},{"line":79,"address":[423460],"length":1,"stats":{"Line":1}},{"line":81,"address":[423547],"length":1,"stats":{"Line":1}},{"line":83,"address":[423602],"length":1,"stats":{"Line":1}},{"line":85,"address":[423644],"length":1,"stats":{"Line":1}},{"line":111,"address":[425038,425032,424624],"length":1,"stats":{"Line":1}},{"line":112,"address":[424650],"length":1,"stats":{"Line":1}},{"line":113,"address":[424738],"length":1,"stats":{"Line":1}},{"line":115,"address":[424804],"length":1,"stats":{"Line":1}},{"line":117,"address":[424891],"length":1,"stats":{"Line":1}},{"line":119,"address":[424946],"length":1,"stats":{"Line":1}},{"line":121,"address":[424988],"length":1,"stats":{"Line":1}},{"line":147,"address":[424136,423728,424142],"length":1,"stats":{"Line":1}},{"line":148,"address":[423754],"length":1,"stats":{"Line":1}},{"line":149,"address":[423842],"length":1,"stats":{"Line":1}},{"line":151,"address":[423908],"length":1,"stats":{"Line":1}},{"line":153,"address":[423995],"length":1,"stats":{"Line":1}},{"line":155,"address":[424050],"length":1,"stats":{"Line":1}},{"line":157,"address":[424092],"length":1,"stats":{"Line":1}},{"line":162,"address":[426544],"length":1,"stats":{"Line":1}},{"line":164,"address":[426558],"length":1,"stats":{"Line":1}},{"line":169,"address":[426525,426531,425200],"length":1,"stats":{"Line":1}},{"line":170,"address":[425250,425327],"length":1,"stats":{"Line":1}},{"line":171,"address":[425973],"length":1,"stats":{"Line":1}},{"line":174,"address":[425312,425392],"length":1,"stats":{"Line":2}},{"line":175,"address":[425454],"length":1,"stats":{"Line":1}},{"line":176,"address":[425539],"length":1,"stats":{"Line":1}},{"line":177,"address":[425638],"length":1,"stats":{"Line":3}},{"line":178,"address":[425736],"length":1,"stats":{"Line":1}},{"line":179,"address":[425782],"length":1,"stats":{"Line":1}},{"line":180,"address":[425811],"length":1,"stats":{"Line":0}},{"line":181,"address":[425840],"length":1,"stats":{"Line":0}},{"line":184,"address":[425875],"length":1,"stats":{"Line":3}}],"covered":40,"coverable":42},{"path":["/","home","lucac","github","mermaid-builder","src","diagrams","entity_relationship","entity_relationship_node","attribute.rs"],"content":"//! Submodule defining an attribute of an Entity-Relationship (ER) node\n//! for the entity-relationship diagram in Mermaid syntax.\n\nuse std::fmt::Display;\n\n#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// Struct representing an attribute of an entity-relationship node.\npub struct EntityRelationshipAttribute {\n    /// The name of the class attribute.\n    name: String,\n    /// The type of the class attribute.\n    attribute_type: String,\n}\n\nimpl EntityRelationshipAttribute {\n    /// Creates a new entity-relationship attribute.\n    pub fn new(attribute_type: String, name: String) -\u003e Self {\n        Self { name, attribute_type }\n    }\n\n    /// Returns the name of the attribute.\n    #[must_use]\n    pub fn name(\u0026self) -\u003e \u0026str {\n        \u0026self.name\n    }\n\n    /// Returns the type of the attribute.\n    #[must_use]\n    pub fn attribute_type(\u0026self) -\u003e \u0026str {\n        \u0026self.attribute_type\n    }\n}\n\nimpl Display for EntityRelationshipAttribute {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{} {}\", self.name, self.attribute_type)\n    }\n}\n","traces":[{"line":18,"address":[390464],"length":1,"stats":{"Line":1}},{"line":24,"address":[390528],"length":1,"stats":{"Line":1}},{"line":25,"address":[390533],"length":1,"stats":{"Line":1}},{"line":30,"address":[390448],"length":1,"stats":{"Line":1}},{"line":31,"address":[390453],"length":1,"stats":{"Line":1}},{"line":36,"address":[391312],"length":1,"stats":{"Line":0}},{"line":37,"address":[391337],"length":1,"stats":{"Line":0}}],"covered":5,"coverable":7},{"path":["/","home","lucac","github","mermaid-builder","src","diagrams","entity_relationship","entity_relationship_node","builder.rs"],"content":"//! Submodule defining a builder struct for the entity-relationship node in\n//! entity-relationship diagrams.\n\nuse std::rc::Rc;\n\nuse crate::{\n    diagrams::entity_relationship::entity_relationship_node::{\n        ERNode, attribute::EntityRelationshipAttribute,\n    },\n    errors::NodeError,\n    shared::{StyleClass, StyleClassError, generic_node::GenericNodeBuilder},\n    traits::NodeBuilder,\n};\n\n#[derive(Default, Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// Builder for the entity-relationship node in Mermaid syntax.\n///\n/// # Example\n///\n/// ```\n/// use mermaid_builder::prelude::*;\n///\n/// fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n///     let node = ERNodeBuilder::default().label(\"CUSTOMER\")?.id(0).build()?;\n///     Ok(())\n/// }\n/// ```\npub struct ERNodeBuilder {\n    /// Shared attributes builder for the node.\n    builder: GenericNodeBuilder,\n    /// The attributes of the entity-relationship node.\n    class_attributes: Vec\u003cEntityRelationshipAttribute\u003e,\n}\n\nimpl ERNodeBuilder {\n    /// Adds an attribute to the entity-relationship node.\n    #[must_use]\n    pub fn attribute\u003cS: ToString + ?Sized\u003e(mut self, attribute_type: \u0026S, name: \u0026S) -\u003e Self {\n        self.class_attributes\n            .push(EntityRelationshipAttribute::new(attribute_type.to_string(), name.to_string()));\n        self\n    }\n}\n\nimpl TryFrom\u003cERNodeBuilder\u003e for ERNode {\n    type Error = NodeError;\n\n    fn try_from(builder: ERNodeBuilder) -\u003e Result\u003cSelf, Self::Error\u003e {\n        Ok(ERNode { node: builder.builder.try_into()?, attributes: builder.class_attributes })\n    }\n}\n\nimpl NodeBuilder for ERNodeBuilder {\n    type Node = ERNode;\n    type Error = NodeError;\n\n    fn build(self) -\u003e Result\u003cSelf::Node, Self::Error\u003e {\n        self.try_into()\n    }\n\n    fn id(mut self, id: u64) -\u003e Self {\n        self.builder = self.builder.id(id);\n        self\n    }\n\n    fn get_id(\u0026self) -\u003e Option\u003cu64\u003e {\n        self.builder.get_id()\n    }\n\n    fn label\u003cS: ToString\u003e(mut self, label: S) -\u003e Result\u003cSelf, Self::Error\u003e {\n        self.builder = self.builder.label(label)?;\n        Ok(self)\n    }\n\n    fn get_label(\u0026self) -\u003e Option\u003c\u0026String\u003e {\n        self.builder.get_label()\n    }\n\n    fn style_class(mut self, style_class: Rc\u003cStyleClass\u003e) -\u003e Result\u003cSelf, StyleClassError\u003e {\n        self.builder = self.builder.style_class(style_class)?;\n        Ok(self)\n    }\n\n    fn style_property(\n        mut self,\n        property: crate::shared::StyleProperty,\n    ) -\u003e Result\u003cSelf, StyleClassError\u003e {\n        self.builder = self.builder.style_property(property)?;\n        Ok(self)\n    }\n\n    fn style_properties(\u0026self) -\u003e impl Iterator\u003cItem = \u0026crate::prelude::StyleProperty\u003e {\n        self.builder.style_properties()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::{\n        shared::{StyleClassBuilder, StyleProperty, style_class::Color},\n        traits::node::Node,\n    };\n\n    #[test]\n    fn test_er_node_builder() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n        let style = Rc::new(\n            StyleClassBuilder::default()\n                .name(\"myStyle\")?\n                .property(StyleProperty::Fill(Color::from((255, 0, 0))))?\n                .build()?,\n        );\n\n        let node = ERNodeBuilder::default()\n            .id(1)\n            .label(\"CUSTOMER\")?\n            .attribute(\"string\", \"name\")\n            .attribute(\"int\", \"age\")\n            .style_class(style)?\n            .style_property(StyleProperty::Fill(Color::from((255, 0, 0))))?\n            .build()?;\n\n        assert_eq!(node.node.id(), 1);\n        assert_eq!(node.node.label(), \"CUSTOMER\");\n        assert_eq!(node.attributes.len(), 2);\n        assert_eq!(node.attributes[0].attribute_type(), \"string\");\n        assert_eq!(node.attributes[0].name(), \"name\");\n        assert_eq!(node.attributes[1].attribute_type(), \"int\");\n        assert_eq!(node.attributes[1].name(), \"age\");\n        \n        // Check styles\n        let styles: Vec\u003c_\u003e = node.node.styles().collect();\n        assert!(styles.contains(\u0026\u0026StyleProperty::Fill(Color::from((255, 0, 0)))));\n\n        Ok(())\n    }\n}\n","traces":[{"line":39,"address":[233952,234283],"length":1,"stats":{"Line":1}},{"line":40,"address":[234041],"length":1,"stats":{"Line":1}},{"line":41,"address":[234063,234264,234116],"length":1,"stats":{"Line":2}},{"line":42,"address":[234241],"length":1,"stats":{"Line":1}},{"line":49,"address":[680062,680090,679552],"length":1,"stats":{"Line":2}},{"line":50,"address":[679740,679573],"length":1,"stats":{"Line":4}},{"line":58,"address":[345888],"length":1,"stats":{"Line":2}},{"line":59,"address":[345905],"length":1,"stats":{"Line":2}},{"line":62,"address":[345664,345866],"length":1,"stats":{"Line":1}},{"line":63,"address":[345693,345819],"length":1,"stats":{"Line":6}},{"line":64,"address":[345843],"length":1,"stats":{"Line":3}},{"line":67,"address":[345952],"length":1,"stats":{"Line":0}},{"line":68,"address":[345957],"length":1,"stats":{"Line":0}},{"line":71,"address":[234790,234304],"length":1,"stats":{"Line":2}},{"line":72,"address":[234508,234342],"length":1,"stats":{"Line":4}},{"line":73,"address":[234684],"length":1,"stats":{"Line":2}},{"line":76,"address":[345968],"length":1,"stats":{"Line":0}},{"line":77,"address":[345973],"length":1,"stats":{"Line":0}},{"line":80,"address":[344987,344480],"length":1,"stats":{"Line":1}},{"line":81,"address":[344510,344676],"length":1,"stats":{"Line":2}},{"line":82,"address":[344881],"length":1,"stats":{"Line":1}},{"line":85,"address":[345008,345626],"length":1,"stats":{"Line":1}},{"line":89,"address":[345066,345315],"length":1,"stats":{"Line":2}},{"line":90,"address":[345520],"length":1,"stats":{"Line":1}},{"line":93,"address":[345648],"length":1,"stats":{"Line":0}},{"line":94,"address":[345653],"length":1,"stats":{"Line":0}}],"covered":20,"coverable":26},{"path":["/","home","lucac","github","mermaid-builder","src","diagrams","entity_relationship","entity_relationship_node.rs"],"content":"//! Submodule defining the struct to represent an entity-relationship node\n//! for the entity-relationship diagram in Mermaid syntax.\n\nuse std::fmt::Display;\n\nmod attribute;\nmod builder;\nuse attribute::EntityRelationshipAttribute;\npub use builder::ERNodeBuilder;\n\nuse crate::{\n    shared::{GenericNode, NODE_LETTER, StyleClass, StyleProperty},\n    traits::Node,\n};\n\n#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// Struct representing an entity-relationship node in an ER diagram.\n///\n/// # Examples\n///\n/// ```\n/// use mermaid_builder::{\n///     diagrams::entity_relationship::ERNodeBuilder,\n///     traits::{Node, NodeBuilder},\n/// };\n///\n/// fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n///     let node = ERNodeBuilder::default()\n///         .label(\"USER\")?\n///         .id(1)\n///         .attribute(\"string\", \"username\")\n///         .build()?;\n///\n///     assert_eq!(node.label(), \"USER\");\n///     Ok(())\n/// }\n/// ```\npub struct ERNode {\n    /// Underlying node structure.\n    node: GenericNode,\n    /// Attributes of the entity-relationship node.\n    attributes: Vec\u003cEntityRelationshipAttribute\u003e,\n}\n\nimpl Node for ERNode {\n    type Builder = ERNodeBuilder;\n\n    fn label(\u0026self) -\u003e \u0026str {\n        self.node.label()\n    }\n\n    fn id(\u0026self) -\u003e u64 {\n        self.node.id()\n    }\n\n    fn styles(\u0026self) -\u003e impl Iterator\u003cItem = \u0026StyleProperty\u003e {\n        self.node.styles()\n    }\n\n    fn classes(\u0026self) -\u003e impl Iterator\u003cItem = \u0026StyleClass\u003e {\n        self.node.classes()\n    }\n\n    fn is_compatible_arrow_shape(shape: crate::shared::ArrowShape) -\u003e bool {\n        matches!(\n            shape,\n            crate::shared::ArrowShape::OneOrMore\n                | crate::shared::ArrowShape::ExactlyOne\n                | crate::shared::ArrowShape::ZeroOrOne\n                | crate::shared::ArrowShape::ZeroOrMore\n        )\n    }\n}\n\nimpl Display for ERNode {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        use crate::traits::TabbedDisplay;\n        self.fmt_tabbed(f, 0)\n    }\n}\n\nimpl crate::traits::TabbedDisplay for ERNode {\n    fn fmt_tabbed(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e, tab_count: usize) -\u003e std::fmt::Result {\n        let indent = \" \".repeat(tab_count * 2);\n        write!(f, \"{indent}{NODE_LETTER}{}[\\\"{}\\\"]\", self.id(), self.label())?;\n\n        if self.attributes.is_empty() {\n            writeln!(f)?;\n        } else {\n            writeln!(f, \" {{\")?;\n\n            for attr in \u0026self.attributes {\n                writeln!(f, \"{indent}    {attr}\")?;\n            }\n            writeln!(f, \"{indent}}}\")?;\n        }\n\n        for class in self.classes() {\n            writeln!(f, \"{indent}class {NODE_LETTER}{} {}\", self.id(), class.name())?;\n        }\n\n        Ok(())\n    }\n}\n","traces":[{"line":49,"address":[676400],"length":1,"stats":{"Line":0}},{"line":50,"address":[676405],"length":1,"stats":{"Line":0}},{"line":53,"address":[676384],"length":1,"stats":{"Line":1}},{"line":54,"address":[676389],"length":1,"stats":{"Line":1}},{"line":57,"address":[676416],"length":1,"stats":{"Line":0}},{"line":58,"address":[676421],"length":1,"stats":{"Line":0}},{"line":61,"address":[676432],"length":1,"stats":{"Line":0}},{"line":62,"address":[676437],"length":1,"stats":{"Line":0}},{"line":65,"address":[676336],"length":1,"stats":{"Line":2}},{"line":66,"address":[676346],"length":1,"stats":{"Line":2}},{"line":67,"address":[676343],"length":1,"stats":{"Line":2}},{"line":77,"address":[679520],"length":1,"stats":{"Line":0}},{"line":79,"address":[679534],"length":1,"stats":{"Line":0}},{"line":84,"address":[676512,678809,678815],"length":1,"stats":{"Line":0}},{"line":85,"address":[676639,676562],"length":1,"stats":{"Line":0}},{"line":86,"address":[676624,676712,678795],"length":1,"stats":{"Line":0}},{"line":88,"address":[677165],"length":1,"stats":{"Line":0}},{"line":89,"address":[678774,677231,678064],"length":1,"stats":{"Line":0}},{"line":91,"address":[677293,677196,678026],"length":1,"stats":{"Line":0}},{"line":93,"address":[677386],"length":1,"stats":{"Line":0}},{"line":94,"address":[677841,677539],"length":1,"stats":{"Line":0}},{"line":96,"address":[677593,677797],"length":1,"stats":{"Line":0}},{"line":99,"address":[678148,677773],"length":1,"stats":{"Line":0}},{"line":100,"address":[678345,678284],"length":1,"stats":{"Line":0}},{"line":103,"address":[678296],"length":1,"stats":{"Line":0}}],"covered":5,"coverable":25},{"path":["/","home","lucac","github","mermaid-builder","src","diagrams","entity_relationship.rs"],"content":"//! Submodule providing structs to characterize an ER (Entity-Relationship)\n//! Diagram in Mermaid syntax.\n\nmod entity_relationship_edge;\nmod entity_relationship_node;\nuse std::fmt::Display;\n\nuse entity_relationship_edge::EREdge;\npub use entity_relationship_edge::EREdgeBuilder;\nuse entity_relationship_node::ERNode;\npub use entity_relationship_node::ERNodeBuilder;\n\nuse crate::{\n    shared::{\n        generic_configuration::{GenericConfiguration, GenericConfigurationBuilder},\n        generic_diagram::{GenericDiagram, GenericDiagramBuilder},\n    },\n    traits::{configuration::Configuration, diagram::Diagram},\n};\n\n/// Represents the configuration for an entity-relationship diagram.\npub type ERDiagramConfiguration = GenericConfiguration;\n/// Represents the configuration builder for an entity-relationship diagram.\npub type ERDiagramConfigurationBuilder = GenericConfigurationBuilder;\n/// Represents an entity-relationship diagram in Mermaid syntax.\npub type ERDiagram = GenericDiagram\u003cERNode, EREdge, GenericConfiguration\u003e;\n/// Represents a builder for an entity-relationship diagram in Mermaid syntax.\npub type ERDiagramBuilder = GenericDiagramBuilder\u003cERNode, EREdge, GenericConfiguration\u003e;\n\nimpl Display for ERDiagram {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        use crate::traits::TabbedDisplay;\n        self.fmt_tabbed(f, 0)\n    }\n}\n\nimpl crate::traits::TabbedDisplay for ERDiagram {\n    fn fmt_tabbed(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e, tab_count: usize) -\u003e std::fmt::Result {\n        let indent = \" \".repeat(tab_count * 2);\n        write!(f, \"{}\", self.configuration())?;\n        writeln!(f, \"{indent}erDiagram\")?;\n        writeln!(f, \"{indent}  direction {}\", self.configuration().direction())?;\n        for style_class in self.style_classes() {\n            style_class.fmt_tabbed(f, tab_count + 1)?;\n        }\n        for node in self.nodes() {\n            node.fmt_tabbed(f, tab_count + 1)?;\n        }\n        for edge in self.edges() {\n            edge.fmt_tabbed(f, tab_count + 1)?;\n        }\n        Ok(())\n    }\n}\n","traces":[{"line":31,"address":[566816],"length":1,"stats":{"Line":0}},{"line":33,"address":[566830],"length":1,"stats":{"Line":0}},{"line":38,"address":[571081,571087,569040],"length":1,"stats":{"Line":0}},{"line":39,"address":[569175,569098],"length":1,"stats":{"Line":0}},{"line":40,"address":[571067,569160,569240],"length":1,"stats":{"Line":0}},{"line":41,"address":[569454,571046],"length":1,"stats":{"Line":0}},{"line":42,"address":[569652,571025],"length":1,"stats":{"Line":0}},{"line":43,"address":[569964],"length":1,"stats":{"Line":0}},{"line":44,"address":[570908,570160],"length":1,"stats":{"Line":0}},{"line":46,"address":[570197],"length":1,"stats":{"Line":0}},{"line":47,"address":[570360,570774],"length":1,"stats":{"Line":0}},{"line":49,"address":[570394],"length":1,"stats":{"Line":0}},{"line":50,"address":[570633,570557],"length":1,"stats":{"Line":0}},{"line":52,"address":[570576],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":14},{"path":["/","home","lucac","github","mermaid-builder","src","diagrams","flowchart","builder.rs"],"content":"//! Submodule providing a builder for flowchart diagrams in Mermaid syntax.\n\nuse crate::{\n    prelude::{\n        Flowchart, FlowchartConfiguration, FlowchartConfigurationBuilder, FlowchartEdge,\n        FlowchartEdgeBuilder, FlowchartNode, FlowchartNodeBuilder,\n    },\n    shared::{StyleClass, StyleClassBuilder, generic_diagram::GenericDiagramBuilder},\n    traits::DiagramBuilder,\n};\n\n#[derive(Default, Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// Represents a builder for a flowchart diagram in Mermaid syntax.\npub struct FlowchartBuilder {\n    /// The configuration of the flowchart.\n    generic: GenericDiagramBuilder\u003cFlowchartNode, FlowchartEdge, FlowchartConfiguration\u003e,\n}\n\nimpl From\u003cFlowchartBuilder\u003e for Flowchart {\n    fn from(builder: FlowchartBuilder) -\u003e Self {\n        let generic = builder.generic.into();\n        Flowchart { generic }\n    }\n}\n\nimpl DiagramBuilder for FlowchartBuilder {\n    type Configuration = FlowchartConfiguration;\n    type ConfigurationBuilder = FlowchartConfigurationBuilder;\n    type Diagram = Flowchart;\n    type Edge = FlowchartEdge;\n    type EdgeBuilder = FlowchartEdgeBuilder;\n    type Node = FlowchartNode;\n    type NodeBuilder = FlowchartNodeBuilder;\n    type Error = crate::errors::Error;\n\n    fn configuration(\n        mut self,\n        configuration: Self::ConfigurationBuilder,\n    ) -\u003e Result\u003cSelf, Self::Error\u003e {\n        self.generic = self.generic.configuration(configuration)?;\n        Ok(self)\n    }\n\n    fn edge(\n        \u0026mut self,\n        mut edge: Self::EdgeBuilder,\n    ) -\u003e Result\u003cstd::rc::Rc\u003cSelf::Edge\u003e, Self::Error\u003e {\n        edge = edge.id(self.number_of_edges());\n        self.generic.edge(edge)\n    }\n\n    fn get_node_by_id(\u0026self, id: u64) -\u003e Option\u003cstd::rc::Rc\u003cSelf::Node\u003e\u003e {\n        self.generic.get_node_by_id(id)\n    }\n\n    fn node(\u0026mut self, node: Self::NodeBuilder) -\u003e Result\u003cstd::rc::Rc\u003cSelf::Node\u003e, Self::Error\u003e {\n        self.generic.node(node)\n    }\n\n    fn nodes(\u0026self) -\u003e impl Iterator\u003cItem = \u0026std::rc::Rc\u003cSelf::Node\u003e\u003e + '_ {\n        self.generic.nodes()\n    }\n\n    fn number_of_edges(\u0026self) -\u003e usize {\n        self.generic.number_of_edges()\n    }\n\n    fn number_of_nodes(\u0026self) -\u003e usize {\n        self.generic.number_of_nodes()\n    }\n\n    fn style_class(\n        \u0026mut self,\n        style_class: StyleClassBuilder,\n    ) -\u003e Result\u003cstd::rc::Rc\u003cStyleClass\u003e, Self::Error\u003e {\n        self.generic.style_class(style_class)\n    }\n\n    fn get_style_class_by_name(\u0026self, name: \u0026str) -\u003e Option\u003cstd::rc::Rc\u003cStyleClass\u003e\u003e {\n        self.generic.get_style_class_by_name(name)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::{\n        prelude::{FlowchartConfigurationBuilder, FlowchartEdgeBuilder, FlowchartNodeBuilder},\n        shared::{StyleClassBuilder, StyleProperty, style_class::Color},\n        traits::{ConfigurationBuilder, DiagramBuilder, EdgeBuilder, NodeBuilder, edge::Edge, node::Node},\n    };\n\n    #[test]\n    fn test_flowchart_builder() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n        let mut builder = FlowchartBuilder::default();\n\n        // Test configuration\n        let config = FlowchartConfigurationBuilder::default().title(\"My Flowchart\")?;\n        builder = builder.configuration(config)?;\n\n        // Test style class\n        let style_class_builder = StyleClassBuilder::default()\n            .name(\"myStyle\")?\n            .property(StyleProperty::Fill(Color::from((255, 0, 0))))?;\n        let style_class = builder.style_class(style_class_builder)?;\n        assert_eq!(style_class.name(), \"myStyle\");\n        assert!(builder.get_style_class_by_name(\"myStyle\").is_some());\n\n        // Test node\n        let node_builder = FlowchartNodeBuilder::default().label(\"Node A\")?;\n        let node_a = builder.node(node_builder)?;\n        assert_eq!(builder.number_of_nodes(), 1);\n        assert!(builder.get_node_by_id(node_a.id()).is_some());\n\n        let node_builder_b = FlowchartNodeBuilder::default().label(\"Node B\")?;\n        let node_b = builder.node(node_builder_b)?;\n        assert_eq!(builder.number_of_nodes(), 2);\n\n        // Test nodes iterator\n        let nodes: Vec\u003c_\u003e = builder.nodes().collect();\n        assert_eq!(nodes.len(), 2);\n\n        // Test edge\n        let edge_builder = FlowchartEdgeBuilder::default()\n            .source(node_a.clone())?\n            .destination(node_b.clone())?;\n        let edge = builder.edge(edge_builder)?;\n        assert_eq!(builder.number_of_edges(), 1);\n        assert_eq!(edge.source().id(), node_a.id());\n        assert_eq!(edge.destination().id(), node_b.id());\n\n        // Test build (into Flowchart)\n        let flowchart: Flowchart = builder.into();\n        // We can't easily inspect the flowchart internals here without more accessors,\n        // but the conversion should succeed.\n\n        Ok(())\n    }\n}\n","traces":[{"line":21,"address":[550288],"length":1,"stats":{"Line":1}},{"line":22,"address":[550305],"length":1,"stats":{"Line":1}},{"line":37,"address":[776176,776703,776728],"length":1,"stats":{"Line":1}},{"line":41,"address":[776198,776701,776425],"length":1,"stats":{"Line":2}},{"line":42,"address":[776639],"length":1,"stats":{"Line":1}},{"line":45,"address":[777156,777184,776832],"length":1,"stats":{"Line":1}},{"line":49,"address":[776874,777177],"length":1,"stats":{"Line":1}},{"line":50,"address":[777102],"length":1,"stats":{"Line":1}},{"line":53,"address":[776736],"length":1,"stats":{"Line":1}},{"line":54,"address":[776750],"length":1,"stats":{"Line":1}},{"line":57,"address":[777200],"length":1,"stats":{"Line":1}},{"line":58,"address":[777238],"length":1,"stats":{"Line":1}},{"line":61,"address":[777296],"length":1,"stats":{"Line":1}},{"line":62,"address":[777301],"length":1,"stats":{"Line":1}},{"line":65,"address":[776768],"length":1,"stats":{"Line":1}},{"line":66,"address":[776773],"length":1,"stats":{"Line":1}},{"line":69,"address":[776784],"length":1,"stats":{"Line":1}},{"line":70,"address":[776789],"length":1,"stats":{"Line":1}},{"line":73,"address":[776096],"length":1,"stats":{"Line":1}},{"line":77,"address":[776131],"length":1,"stats":{"Line":1}},{"line":80,"address":[776800],"length":1,"stats":{"Line":1}},{"line":81,"address":[776818],"length":1,"stats":{"Line":1}}],"covered":22,"coverable":22},{"path":["/","home","lucac","github","mermaid-builder","src","diagrams","flowchart","configuration","builder.rs"],"content":"//! Submodule providing a builder struct for the configuration of flowchart\n//! diagrams in Mermaid syntax.\n\nuse crate::{\n    diagrams::flowchart::{configuration::FlowchartConfiguration, curve_styles::CurveStyle},\n    errors::ConfigError,\n    shared::generic_configuration::GenericConfigurationBuilder,\n    traits::ConfigurationBuilder,\n};\n\n#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// Builder for creating flowchart configurations with various properties.\npub struct FlowchartConfigurationBuilder {\n    /// Generic configuration options which apply to all Mermaid diagrams.\n    generic: GenericConfigurationBuilder,\n    /// Whether to enable html labels in the flowchart.\n    html_labels: bool,\n    /// Whether to automatically wrap markdown labels.\n    markdown_auto_wrap: bool,\n    /// The curve style used for edges in the flowchart.\n    curve_style: CurveStyle,\n}\n\nimpl FlowchartConfigurationBuilder {\n    #[must_use]\n    /// Sets whether to enable html labels in the flowchart.\n    pub fn html_labels(mut self, enable: bool) -\u003e Self {\n        self.html_labels = enable;\n        self\n    }\n\n    #[must_use]\n    /// Sets whether to automatically wrap markdown labels.\n    pub fn markdown_auto_wrap(mut self, auto_wrap: bool) -\u003e Self {\n        self.markdown_auto_wrap = auto_wrap;\n        self\n    }\n\n    #[must_use]\n    /// Sets the curve style for edges in the flowchart.\n    pub fn curve_style(mut self, style: CurveStyle) -\u003e Self {\n        self.curve_style = style;\n        self\n    }\n\n    /// Sets the theme to use for the diagram.\n    #[must_use]\n    pub fn theme(mut self, theme: crate::shared::generic_configuration::Theme) -\u003e Self {\n        self.generic = self.generic.theme(theme);\n        self\n    }\n\n    /// Sets the look to use for the diagram.\n    #[must_use]\n    pub fn look(mut self, look: crate::shared::generic_configuration::Look) -\u003e Self {\n        self.generic = self.generic.look(look);\n        self\n    }\n}\n\nimpl TryFrom\u003cFlowchartConfigurationBuilder\u003e for FlowchartConfiguration {\n    type Error = ConfigError;\n\n    fn try_from(builder: FlowchartConfigurationBuilder) -\u003e Result\u003cSelf, Self::Error\u003e {\n        Ok(FlowchartConfiguration {\n            generic: builder.generic.try_into()?,\n            markdown_auto_wrap: builder.markdown_auto_wrap,\n            html_labels: builder.html_labels,\n            curve_style: builder.curve_style,\n        })\n    }\n}\n\nimpl ConfigurationBuilder for FlowchartConfigurationBuilder {\n    type Configuration = FlowchartConfiguration;\n    type Error = ConfigError;\n\n    fn build(self) -\u003e Result\u003cSelf::Configuration, Self::Error\u003e {\n        self.try_into()\n    }\n\n    fn title\u003cS: ToString\u003e(mut self, title: S) -\u003e Result\u003cSelf, Self::Error\u003e {\n        self.generic = self.generic.title(title)?;\n        Ok(self)\n    }\n\n    fn direction(mut self, direction: crate::shared::generic_configuration::Direction) -\u003e Self {\n        self.generic = self.generic.direction(direction);\n        self\n    }\n\n    fn renderer(mut self, renderer: crate::shared::generic_configuration::Renderer) -\u003e Self {\n        self.generic = self.generic.renderer(renderer);\n        self\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::{\n        shared::generic_configuration::{Direction, Look, Renderer, Theme},\n        traits::Configuration,\n    };\n\n    #[test]\n    fn test_flowchart_configuration_builder() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n        let config = FlowchartConfigurationBuilder::default()\n            .title(\"My Flowchart\")?\n            .direction(Direction::TopToBottom)\n            .renderer(Renderer::EclipseLayoutKernel)\n            .theme(Theme::Forest)\n            .look(Look::HandDrawn)\n            .html_labels(true)\n            .markdown_auto_wrap(false)\n            .curve_style(CurveStyle::Basis)\n            .build()?;\n\n        assert!(config.html_labels);\n        assert!(!config.markdown_auto_wrap);\n        assert_eq!(config.curve_style, CurveStyle::Basis);\n        assert_eq!(config.title(), Some(\"My Flowchart\"));\n        assert_eq!(config.direction(), Direction::TopToBottom);\n        assert_eq!(config.renderer(), Renderer::EclipseLayoutKernel);\n        assert_eq!(config.theme(), Theme::Forest);\n        assert_eq!(config.look(), Look::HandDrawn);\n        Ok(())\n    }\n}\n","traces":[{"line":28,"address":[281408],"length":1,"stats":{"Line":1}},{"line":29,"address":[281431],"length":1,"stats":{"Line":1}},{"line":30,"address":[281436],"length":1,"stats":{"Line":1}},{"line":35,"address":[281456],"length":1,"stats":{"Line":1}},{"line":36,"address":[281479],"length":1,"stats":{"Line":1}},{"line":37,"address":[281484],"length":1,"stats":{"Line":1}},{"line":42,"address":[281360],"length":1,"stats":{"Line":1}},{"line":43,"address":[281378],"length":1,"stats":{"Line":1}},{"line":44,"address":[281381],"length":1,"stats":{"Line":1}},{"line":49,"address":[281648],"length":1,"stats":{"Line":2}},{"line":50,"address":[281673],"length":1,"stats":{"Line":3}},{"line":51,"address":[281771],"length":1,"stats":{"Line":3}},{"line":56,"address":[281504],"length":1,"stats":{"Line":3}},{"line":57,"address":[281529],"length":1,"stats":{"Line":3}},{"line":58,"address":[281627],"length":1,"stats":{"Line":3}},{"line":65,"address":[379648],"length":1,"stats":{"Line":1}},{"line":66,"address":[379875],"length":1,"stats":{"Line":3}},{"line":67,"address":[379669],"length":1,"stats":{"Line":1}},{"line":68,"address":[379866],"length":1,"stats":{"Line":3}},{"line":69,"address":[379869],"length":1,"stats":{"Line":3}},{"line":70,"address":[379872],"length":1,"stats":{"Line":3}},{"line":79,"address":[281856],"length":1,"stats":{"Line":1}},{"line":80,"address":[281869],"length":1,"stats":{"Line":1}},{"line":83,"address":[400107,399696,400082],"length":1,"stats":{"Line":3}},{"line":84,"address":[400080,399734,399843],"length":1,"stats":{"Line":7}},{"line":85,"address":[400018],"length":1,"stats":{"Line":4}},{"line":88,"address":[282080],"length":1,"stats":{"Line":2}},{"line":89,"address":[282105],"length":1,"stats":{"Line":2}},{"line":90,"address":[282203],"length":1,"stats":{"Line":2}},{"line":93,"address":[281920],"length":1,"stats":{"Line":1}},{"line":94,"address":[281950],"length":1,"stats":{"Line":1}},{"line":95,"address":[282051],"length":1,"stats":{"Line":1}}],"covered":32,"coverable":32},{"path":["/","home","lucac","github","mermaid-builder","src","diagrams","flowchart","configuration.rs"],"content":"//! Submodule defining configuration specifically for flowchart diagrams in\n//! Mermaid.\n\nmod builder;\n\nuse std::fmt::Display;\n\npub use builder::FlowchartConfigurationBuilder;\n\nuse crate::{\n    diagrams::flowchart::curve_styles::CurveStyle,\n    shared::{\n        Direction, Renderer,\n        generic_configuration::{GenericConfiguration, Look, Theme},\n    },\n    traits::Configuration,\n};\n\n#[derive(Default, Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// Represents the configuration for a flowchart diagram in Mermaid syntax.\npub struct FlowchartConfiguration {\n    /// Generic configuration options which apply to all Mermaid diagrams.\n    generic: GenericConfiguration,\n    /// Whether to automatically wrap markdown labels.\n    markdown_auto_wrap: bool,\n    /// Whether to enable html labels in the flowchart.\n    html_labels: bool,\n    /// The curve style used for edges in the flowchart.\n    curve_style: CurveStyle,\n}\n\nimpl Display for FlowchartConfiguration {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        if self.generic.title().is_none() \u0026\u0026 self.renderer() == Renderer::default() {\n            return Ok(());\n        }\n        writeln!(f, \"---\")?;\n        writeln!(f, \"config:\")?;\n        writeln!(f, \"  theme: {}\", self.theme())?;\n        writeln!(f, \"  look: {}\", self.look())?;\n        writeln!(f, \"  flowchart:\")?;\n        writeln!(f, \"    defaultRenderer: \\\"{}\\\"\", self.renderer())?;\n        if let Some(title) = \u0026self.generic.title() {\n            writeln!(f, \"title: {title}\")?;\n        }\n        writeln!(f, \"---\")?;\n\n        Ok(())\n    }\n}\n\nimpl Configuration for FlowchartConfiguration {\n    type Builder = FlowchartConfigurationBuilder;\n\n    fn title(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n        self.generic.title()\n    }\n\n    fn direction(\u0026self) -\u003e Direction {\n        self.generic.direction()\n    }\n\n    fn renderer(\u0026self) -\u003e Renderer {\n        self.generic.renderer()\n    }\n\n    fn theme(\u0026self) -\u003e Theme {\n        self.generic.theme()\n    }\n\n    fn look(\u0026self) -\u003e Look {\n        self.generic.look()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::traits::ConfigurationBuilder;\n\n    #[test]\n    fn test_flowchart_configuration_display_default() {\n        let config = FlowchartConfiguration::default();\n        assert_eq!(format!(\"{config}\"), \"\");\n    }\n\n    #[test]\n    fn test_flowchart_configuration_display_full() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n        let config = FlowchartConfigurationBuilder::default()\n            .title(\"My Flowchart\")?\n            .renderer(Renderer::EclipseLayoutKernel)\n            .theme(Theme::Forest)\n            .look(Look::HandDrawn)\n            .build()?;\n\n        let output = format!(\"{config}\");\n        assert!(output.contains(\"title: My Flowchart\"));\n        assert!(output.contains(\"defaultRenderer: \\\"elk\\\"\"));\n        assert!(output.contains(\"theme: forest\"));\n        assert!(output.contains(\"look: handDrawn\"));\n        Ok(())\n    }\n\n    #[test]\n    fn test_flowchart_configuration_traits() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n        let config = FlowchartConfigurationBuilder::default()\n            .title(\"My Flowchart\")?\n            .direction(Direction::TopToBottom)\n            .renderer(Renderer::EclipseLayoutKernel)\n            .theme(Theme::Forest)\n            .look(Look::HandDrawn)\n            .build()?;\n\n        assert_eq!(config.title(), Some(\"My Flowchart\"));\n        assert_eq!(config.direction(), Direction::TopToBottom);\n        assert_eq!(config.renderer(), Renderer::EclipseLayoutKernel);\n        assert_eq!(config.theme(), Theme::Forest);\n        assert_eq!(config.look(), Look::HandDrawn);\n        Ok(())\n    }\n}\n","traces":[{"line":34,"address":[377072],"length":1,"stats":{"Line":1}},{"line":35,"address":[377104,377193],"length":1,"stats":{"Line":2}},{"line":36,"address":[377236],"length":1,"stats":{"Line":1}},{"line":38,"address":[377246,377133],"length":1,"stats":{"Line":1}},{"line":39,"address":[377269],"length":1,"stats":{"Line":1}},{"line":40,"address":[377350],"length":1,"stats":{"Line":1}},{"line":41,"address":[377489],"length":1,"stats":{"Line":1}},{"line":42,"address":[377623],"length":1,"stats":{"Line":1}},{"line":43,"address":[377704],"length":1,"stats":{"Line":1}},{"line":44,"address":[377862],"length":1,"stats":{"Line":1}},{"line":45,"address":[377934,378117],"length":1,"stats":{"Line":1}},{"line":47,"address":[378061,378149],"length":1,"stats":{"Line":1}},{"line":49,"address":[378169],"length":1,"stats":{"Line":1}},{"line":56,"address":[379600],"length":1,"stats":{"Line":1}},{"line":57,"address":[379605],"length":1,"stats":{"Line":1}},{"line":60,"address":[379632],"length":1,"stats":{"Line":1}},{"line":61,"address":[379637],"length":1,"stats":{"Line":2}},{"line":64,"address":[379616],"length":1,"stats":{"Line":1}},{"line":65,"address":[379621],"length":1,"stats":{"Line":1}},{"line":68,"address":[379584],"length":1,"stats":{"Line":1}},{"line":69,"address":[379589],"length":1,"stats":{"Line":3}},{"line":72,"address":[379568],"length":1,"stats":{"Line":2}},{"line":73,"address":[379573],"length":1,"stats":{"Line":3}}],"covered":23,"coverable":23},{"path":["/","home","lucac","github","mermaid-builder","src","diagrams","flowchart","curve_styles.rs"],"content":"//! Submodule providing an enumeration of possible curve styles for flowchart\n//! edges in Mermaid diagrams.\n\n#[derive(Default, Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// Represents the curve styles available for flowchart edges in Mermaid syntax.\npub enum CurveStyle {\n    /// Basis curve style.\n    #[default]\n    Basis,\n    /// `BumpX` curve style.\n    BumpX,\n    /// `BumpY` curve style.\n    BumpY,\n    /// `Cardinal` curve style.\n    Cardinal,\n    /// `CatmullRom` curve style.\n    CatmullRom,\n    /// `Linear` curve style.\n    Linear,\n    /// `MonotoneX` curve style.\n    MonotoneX,\n    /// `MonotoneY` curve style.\n    MonotoneY,\n    /// `Natural` curve style.\n    Natural,\n    /// `Step` curve style.\n    Step,\n    /// `StepAfter` curve style.\n    StepAfter,\n    /// `StepBefore` curve style.\n    StepBefore,\n}\n\nimpl std::fmt::Display for CurveStyle {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            CurveStyle::Basis =\u003e write!(f, \"basis\"),\n            CurveStyle::BumpX =\u003e write!(f, \"bumpX\"),\n            CurveStyle::BumpY =\u003e write!(f, \"bumpY\"),\n            CurveStyle::Cardinal =\u003e write!(f, \"cardinal\"),\n            CurveStyle::CatmullRom =\u003e write!(f, \"catmullRom\"),\n            CurveStyle::Linear =\u003e write!(f, \"linear\"),\n            CurveStyle::MonotoneX =\u003e write!(f, \"monotoneX\"),\n            CurveStyle::MonotoneY =\u003e write!(f, \"monotoneY\"),\n            CurveStyle::Natural =\u003e write!(f, \"natural\"),\n            CurveStyle::Step =\u003e write!(f, \"step\"),\n            CurveStyle::StepAfter =\u003e write!(f, \"stepAfter\"),\n            CurveStyle::StepBefore =\u003e write!(f, \"stepBefore\"),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_curve_style_display() {\n        assert_eq!(CurveStyle::Basis.to_string(), \"basis\");\n        assert_eq!(CurveStyle::BumpX.to_string(), \"bumpX\");\n        assert_eq!(CurveStyle::BumpY.to_string(), \"bumpY\");\n        assert_eq!(CurveStyle::Cardinal.to_string(), \"cardinal\");\n        assert_eq!(CurveStyle::CatmullRom.to_string(), \"catmullRom\");\n        assert_eq!(CurveStyle::Linear.to_string(), \"linear\");\n        assert_eq!(CurveStyle::MonotoneX.to_string(), \"monotoneX\");\n        assert_eq!(CurveStyle::MonotoneY.to_string(), \"monotoneY\");\n        assert_eq!(CurveStyle::Natural.to_string(), \"natural\");\n        assert_eq!(CurveStyle::Step.to_string(), \"step\");\n        assert_eq!(CurveStyle::StepAfter.to_string(), \"stepAfter\");\n        assert_eq!(CurveStyle::StepBefore.to_string(), \"stepBefore\");\n    }\n}\n","traces":[{"line":36,"address":[379984],"length":1,"stats":{"Line":1}},{"line":37,"address":[380002],"length":1,"stats":{"Line":1}},{"line":38,"address":[380033],"length":1,"stats":{"Line":1}},{"line":39,"address":[380073],"length":1,"stats":{"Line":1}},{"line":40,"address":[380113],"length":1,"stats":{"Line":1}},{"line":41,"address":[380153],"length":1,"stats":{"Line":1}},{"line":42,"address":[380193],"length":1,"stats":{"Line":1}},{"line":43,"address":[380233],"length":1,"stats":{"Line":1}},{"line":44,"address":[380273],"length":1,"stats":{"Line":1}},{"line":45,"address":[380313],"length":1,"stats":{"Line":1}},{"line":46,"address":[380353],"length":1,"stats":{"Line":1}},{"line":47,"address":[380390],"length":1,"stats":{"Line":1}},{"line":48,"address":[380427],"length":1,"stats":{"Line":1}},{"line":49,"address":[380464],"length":1,"stats":{"Line":1}}],"covered":14,"coverable":14},{"path":["/","home","lucac","github","mermaid-builder","src","diagrams","flowchart","flowchart_edge","builder.rs"],"content":"//! Submodule defining the struct for building a flowchart edge.\n\nuse std::rc::Rc;\n\nuse crate::{\n    diagrams::flowchart::{\n        curve_styles::CurveStyle, flowchart_edge::FlowchartEdge, flowchart_node::FlowchartNode,\n    },\n    errors::EdgeError,\n    shared::{StyleClass, StyleClassError, StyleProperty, generic_edge::GenericEdgeBuilder},\n    traits::EdgeBuilder,\n};\n\n#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// Builder for creating a `FlowchartEdge`.\n///\n/// # Example\n///\n/// ```\n/// use std::rc::Rc;\n///\n/// use mermaid_builder::prelude::*;\n///\n/// let node1 = Rc::new(FlowchartNodeBuilder::default().label(\"A\").unwrap().id(0).build().unwrap());\n/// let node2 = Rc::new(FlowchartNodeBuilder::default().label(\"B\").unwrap().id(1).build().unwrap());\n///\n/// let edge = FlowchartEdgeBuilder::default()\n///     .source(node1)\n///     .unwrap()\n///     .destination(node2)\n///     .unwrap()\n///     .length(2)\n///     .id(0)\n///     .build()\n///     .unwrap();\n/// ```\npub struct FlowchartEdgeBuilder {\n    /// Unique identifier for the edge.\n    id: Option\u003cusize\u003e,\n    /// Underlying generic edge builder.\n    edge_builder: GenericEdgeBuilder\u003cFlowchartNode\u003e,\n    /// Classes associated with the edge.\n    style_classes: Vec\u003cRc\u003cStyleClass\u003e\u003e,\n    /// Style properties for the edge.\n    style_properties: Vec\u003cStyleProperty\u003e,\n    /// The curve style for the edge.\n    curve_style: CurveStyle,\n    /// Length of the edge.\n    length: u8,\n}\n\nimpl FlowchartEdgeBuilder {\n    #[must_use]\n    /// Creates a new `FlowchartEdgeBuilder`.\n    pub fn id(mut self, id: usize) -\u003e Self {\n        self.id = Some(id);\n        self\n    }\n\n    /// Adds a style class to the edge builder.\n    ///\n    /// # Arguments\n    ///\n    /// * `class`: The style class to be added\n    ///\n    /// # Errors\n    ///\n    /// * If the class is already present, an error is returned.\n    pub fn style_class(mut self, class: Rc\u003cStyleClass\u003e) -\u003e Result\u003cSelf, StyleClassError\u003e {\n        if self.style_classes.iter().any(|c| c.name() == class.name()) {\n            return Err(StyleClassError::DuplicateClass(class.name().to_string()));\n        }\n        self.style_classes.push(class);\n        Ok(self)\n    }\n\n    /// Adds a style property to the edge builder.\n    ///\n    /// # Arguments\n    ///\n    /// * `property`: The style property to be added.\n    ///\n    /// # Errors\n    ///\n    /// * If the property is already present, an error is returned.\n    pub fn style_property(mut self, property: StyleProperty) -\u003e Result\u003cSelf, StyleClassError\u003e {\n        if self.style_properties.iter().any(|p| p.is_same_type(property)) {\n            return Err(StyleClassError::DuplicateProperty(property));\n        }\n        self.style_properties.push(property);\n        Ok(self)\n    }\n\n    #[must_use]\n    /// Sets the curve style for the edge.\n    pub fn curve_style(mut self, style: CurveStyle) -\u003e Self {\n        self.curve_style = style;\n        self\n    }\n\n    #[must_use]\n    /// Sets the length of the edge.\n    pub fn length(mut self, length: u8) -\u003e Self {\n        self.length = length;\n        self\n    }\n}\n\nimpl Default for FlowchartEdgeBuilder {\n    fn default() -\u003e Self {\n        Self {\n            id: None,\n            edge_builder: GenericEdgeBuilder::default(),\n            style_classes: Vec::new(),\n            style_properties: Vec::new(),\n            curve_style: CurveStyle::default(),\n            length: 1,\n        }\n    }\n}\n\nimpl TryFrom\u003cFlowchartEdgeBuilder\u003e for FlowchartEdge {\n    type Error = EdgeError;\n\n    fn try_from(builder: FlowchartEdgeBuilder) -\u003e Result\u003cSelf, Self::Error\u003e {\n        if builder.length == 0 {\n            return Err(EdgeError::InvalidLength);\n        }\n\n        Ok(FlowchartEdge {\n            id: builder.id.ok_or(EdgeError::MissingId)?,\n            edge: builder.edge_builder.try_into()?,\n            style_classes: builder.style_classes,\n            style_properties: builder.style_properties,\n            curve_style: builder.curve_style,\n            length: builder.length,\n        })\n    }\n}\n\nimpl EdgeBuilder for FlowchartEdgeBuilder {\n    type Edge = FlowchartEdge;\n    type Node = FlowchartNode;\n    type Error = EdgeError;\n\n    fn build(self) -\u003e Result\u003cSelf::Edge, Self::Error\u003e {\n        self.try_into()\n    }\n\n    fn source(mut self, node: std::rc::Rc\u003cSelf::Node\u003e) -\u003e Result\u003cSelf, Self::Error\u003e {\n        self.edge_builder = self.edge_builder.source(node)?;\n        Ok(self)\n    }\n\n    fn destination(mut self, node: std::rc::Rc\u003cSelf::Node\u003e) -\u003e Result\u003cSelf, Self::Error\u003e {\n        self.edge_builder = self.edge_builder.destination(node)?;\n        Ok(self)\n    }\n\n    fn label\u003cS: ToString\u003e(mut self, label: S) -\u003e Result\u003cSelf, Self::Error\u003e {\n        self.edge_builder = self.edge_builder.label(label)?;\n        Ok(self)\n    }\n\n    fn line_style(mut self, style: crate::shared::LineStyle) -\u003e Self {\n        self.edge_builder = self.edge_builder.line_style(style);\n        self\n    }\n\n    fn left_arrow_shape(mut self, shape: crate::shared::ArrowShape) -\u003e Result\u003cSelf, Self::Error\u003e {\n        self.edge_builder = self.edge_builder.left_arrow_shape(shape)?;\n        Ok(self)\n    }\n\n    fn right_arrow_shape(mut self, shape: crate::shared::ArrowShape) -\u003e Result\u003cSelf, Self::Error\u003e {\n        self.edge_builder = self.edge_builder.right_arrow_shape(shape)?;\n        Ok(self)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use std::rc::Rc;\n\n    use super::*;\n    use crate::{\n        diagrams::flowchart::flowchart_node::FlowchartNodeBuilder,\n        shared::{ArrowShape, LineStyle, StyleClassBuilder, style_class::Unit},\n        traits::{NodeBuilder, edge::Edge, node::Node},\n    };\n\n    #[test]\n    fn test_flowchart_edge_builder() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n        let node1 = Rc::new(FlowchartNodeBuilder::default().label(\"A\")?.id(0).build()?);\n        let node2 = Rc::new(FlowchartNodeBuilder::default().label(\"B\")?.id(1).build()?);\n        let style_class = Rc::new(\n            StyleClassBuilder::default()\n                .name(\"test\")?\n                .property(StyleProperty::StrokeWidth(Unit::Pixel(2)))?\n                .build()?,\n        );\n\n        let edge = FlowchartEdgeBuilder::default()\n            .id(1)\n            .source(node1.clone())?\n            .destination(node2.clone())?\n            .label(\"Edge Label\")?\n            .line_style(LineStyle::Dashed)\n            .left_arrow_shape(ArrowShape::Circle)?\n            .right_arrow_shape(ArrowShape::X)?\n            .curve_style(CurveStyle::StepAfter)\n            .length(2)\n            .style_class(style_class.clone())?\n            .style_property(StyleProperty::StrokeWidth(Unit::Pixel(2)))?\n            .build()?;\n\n        assert_eq!(edge.id, 1);\n        assert_eq!(edge.source().id(), 0);\n        assert_eq!(edge.destination().id(), 1);\n        assert_eq!(edge.label(), Some(\"Edge Label\"));\n        assert_eq!(edge.line_style(), LineStyle::Dashed);\n        assert_eq!(edge.left_arrow_shape(), Some(ArrowShape::Circle));\n        assert_eq!(edge.right_arrow_shape(), Some(ArrowShape::X));\n        assert_eq!(edge.curve_style, CurveStyle::StepAfter);\n        assert_eq!(edge.length, 2);\n        assert_eq!(edge.style_classes.len(), 1);\n        assert_eq!(edge.style_properties.len(), 1);\n        Ok(())\n    }\n}\n","traces":[{"line":56,"address":[204160],"length":1,"stats":{"Line":3}},{"line":57,"address":[204177],"length":1,"stats":{"Line":3}},{"line":58,"address":[204188],"length":1,"stats":{"Line":3}},{"line":70,"address":[203671,203168],"length":1,"stats":{"Line":1}},{"line":71,"address":[203291,203203],"length":1,"stats":{"Line":2}},{"line":72,"address":[203393,203469],"length":1,"stats":{"Line":0}},{"line":74,"address":[203364],"length":1,"stats":{"Line":1}},{"line":75,"address":[203410],"length":1,"stats":{"Line":1}},{"line":87,"address":[204131,203696],"length":1,"stats":{"Line":2}},{"line":88,"address":[203830,203762],"length":1,"stats":{"Line":4}},{"line":89,"address":[203996],"length":1,"stats":{"Line":0}},{"line":91,"address":[203903],"length":1,"stats":{"Line":2}},{"line":92,"address":[204077],"length":1,"stats":{"Line":2}},{"line":97,"address":[203120],"length":1,"stats":{"Line":2}},{"line":98,"address":[203138],"length":1,"stats":{"Line":2}},{"line":99,"address":[203141],"length":1,"stats":{"Line":2}},{"line":104,"address":[204208],"length":1,"stats":{"Line":2}},{"line":105,"address":[204226],"length":1,"stats":{"Line":2}},{"line":106,"address":[204229],"length":1,"stats":{"Line":2}},{"line":111,"address":[208772,208778,208496],"length":1,"stats":{"Line":4}},{"line":114,"address":[208518],"length":1,"stats":{"Line":4}},{"line":115,"address":[208528],"length":1,"stats":{"Line":4}},{"line":116,"address":[208574],"length":1,"stats":{"Line":4}},{"line":117,"address":[208612],"length":1,"stats":{"Line":4}},{"line":126,"address":[657634,656560],"length":1,"stats":{"Line":3}},{"line":127,"address":[656582],"length":1,"stats":{"Line":3}},{"line":128,"address":[656641],"length":1,"stats":{"Line":0}},{"line":131,"address":[657329],"length":1,"stats":{"Line":5}},{"line":132,"address":[656816,656702,657502],"length":1,"stats":{"Line":7}},{"line":133,"address":[656970,657497],"length":1,"stats":{"Line":5}},{"line":134,"address":[657227],"length":1,"stats":{"Line":5}},{"line":135,"address":[657271],"length":1,"stats":{"Line":5}},{"line":136,"address":[657315],"length":1,"stats":{"Line":5}},{"line":137,"address":[657322],"length":1,"stats":{"Line":5}},{"line":147,"address":[206272],"length":1,"stats":{"Line":3}},{"line":148,"address":[206288],"length":1,"stats":{"Line":3}},{"line":151,"address":[206336,206818],"length":1,"stats":{"Line":1}},{"line":152,"address":[206497,206366],"length":1,"stats":{"Line":6}},{"line":153,"address":[206686],"length":1,"stats":{"Line":6}},{"line":156,"address":[205074,204592],"length":1,"stats":{"Line":3}},{"line":157,"address":[204622,204753],"length":1,"stats":{"Line":12}},{"line":158,"address":[204942],"length":1,"stats":{"Line":6}},{"line":161,"address":[414368,414858],"length":1,"stats":{"Line":2}},{"line":162,"address":[414406,414537],"length":1,"stats":{"Line":4}},{"line":163,"address":[414726],"length":1,"stats":{"Line":2}},{"line":166,"address":[204557,204384,204579],"length":1,"stats":{"Line":2}},{"line":167,"address":[204505,204415],"length":1,"stats":{"Line":4}},{"line":168,"address":[204534],"length":1,"stats":{"Line":2}},{"line":171,"address":[205152,205638],"length":1,"stats":{"Line":2}},{"line":172,"address":[205183,205317],"length":1,"stats":{"Line":4}},{"line":173,"address":[205506],"length":1,"stats":{"Line":2}},{"line":176,"address":[206198,205712],"length":1,"stats":{"Line":2}},{"line":177,"address":[205743,205877],"length":1,"stats":{"Line":4}},{"line":178,"address":[206066],"length":1,"stats":{"Line":2}}],"covered":51,"coverable":54},{"path":["/","home","lucac","github","mermaid-builder","src","diagrams","flowchart","flowchart_edge.rs"],"content":"//! Submodule defining an edge which may be used in a flowchart diagram\n//! in Mermaid syntax.\n\nuse std::{fmt::Display, rc::Rc};\n\nuse crate::{\n    diagrams::flowchart::{curve_styles::CurveStyle, flowchart_node::FlowchartNode},\n    shared::{\n        ArrowShape, EDGE_LETTER, GenericEdge, LineStyle, NODE_LETTER, StyleClass, StyleProperty,\n    },\n    traits::{Edge, node::Node},\n};\n\npub mod builder;\npub use builder::FlowchartEdgeBuilder;\n\n#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// Represents an edge in a flowchart diagram, connecting two nodes with various\n/// properties such as styles, classes, and curve styles.\n///\n/// # Examples\n///\n/// ```\n/// use std::rc::Rc;\n///\n/// use mermaid_builder::{\n///     diagrams::flowchart::{FlowchartEdgeBuilder, FlowchartNodeBuilder},\n///     traits::{EdgeBuilder, NodeBuilder},\n/// };\n///\n/// fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n///     let node1 = Rc::new(FlowchartNodeBuilder::default().label(\"A\")?.id(1).build()?);\n///     let node2 = Rc::new(FlowchartNodeBuilder::default().label(\"B\")?.id(2).build()?);\n///\n///     let edge =\n///         FlowchartEdgeBuilder::default().source(node1)?.destination(node2)?.id(1).build()?;\n///     Ok(())\n/// }\n/// ```\npub struct FlowchartEdge {\n    /// Unique identifier for the edge.\n    id: usize,\n    /// Underlying generic edge.\n    edge: GenericEdge\u003cFlowchartNode\u003e,\n    /// Classes associated with the edge, used for styling.\n    style_classes: Vec\u003cRc\u003cStyleClass\u003e\u003e,\n    /// Styling properties for the edge, such as color and font.\n    style_properties: Vec\u003cStyleProperty\u003e,\n    /// The curve style of the edge.\n    curve_style: CurveStyle,\n    /// The number of segments composing the link style.\n    length: u8,\n}\n\nimpl Edge for FlowchartEdge {\n    type Builder = FlowchartEdgeBuilder;\n    type Node = FlowchartNode;\n\n    fn label(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n        self.edge.label()\n    }\n\n    fn source(\u0026self) -\u003e \u0026Rc\u003cSelf::Node\u003e {\n        self.edge.source()\n    }\n\n    fn destination(\u0026self) -\u003e \u0026Rc\u003cSelf::Node\u003e {\n        self.edge.destination()\n    }\n\n    fn classes(\u0026self) -\u003e impl Iterator\u003cItem = \u0026StyleClass\u003e {\n        self.style_classes.iter().map(AsRef::as_ref)\n    }\n\n    fn line_style(\u0026self) -\u003e LineStyle {\n        self.edge.line_style()\n    }\n\n    fn left_arrow_shape(\u0026self) -\u003e Option\u003cArrowShape\u003e {\n        self.edge.left_arrow_shape()\n    }\n\n    fn right_arrow_shape(\u0026self) -\u003e Option\u003cArrowShape\u003e {\n        self.edge.right_arrow_shape()\n    }\n}\n\nimpl Display for FlowchartEdge {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        use crate::traits::TabbedDisplay;\n        self.fmt_tabbed(f, 0)\n    }\n}\n\nimpl crate::traits::TabbedDisplay for FlowchartEdge {\n    fn fmt_tabbed(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e, tab_count: usize) -\u003e std::fmt::Result {\n        let indent = \" \".repeat(tab_count * 2);\n        let segment = match self.line_style() {\n            LineStyle::Solid =\u003e \"-\".repeat(2 + self.length as usize),\n            LineStyle::Thick =\u003e \"=\".repeat(2 + self.length as usize),\n            LineStyle::Dashed =\u003e format!(\"-{}-\", \".\".repeat(self.length as usize)),\n        };\n\n        let edge_prefix = if self.curve_style != CurveStyle::default()\n            || !self.style_classes.is_empty()\n            || !self.style_properties.is_empty()\n        {\n            format!(\"{EDGE_LETTER}{}@\", self.id)\n        } else {\n            String::default()\n        };\n\n        writeln!(\n            f,\n            \"{indent}{NODE_LETTER}{} {edge_prefix}{left_arrow}{segment}{right_arrow}{} {NODE_LETTER}{}\",\n            self.source().id(),\n            self.label().map_or_else(String::new, |label| format!(\"|\\\"`{label}`\\\"|\")),\n            self.destination().id(),\n            left_arrow = self.left_arrow_shape().as_ref().map_or_else(|| \"\", |shape| shape.left()),\n            right_arrow =\n                self.right_arrow_shape().as_ref().map_or_else(|| \"\", |shape| shape.right()),\n        )?;\n\n        if self.curve_style != CurveStyle::default() {\n            writeln!(f, \"{indent}{EDGE_LETTER}{}@{{curve: {}}}\", self.id, self.curve_style)?;\n        }\n\n        for class in \u0026self.style_classes {\n            writeln!(f, \"{indent}class {EDGE_LETTER}{} {}\", self.id, class.name())?;\n        }\n\n        if !self.style_properties.is_empty() {\n            write!(f, \"{indent}linkStyle {EDGE_LETTER}{} \", self.id)?;\n            for (style_number, style) in self.style_properties.iter().enumerate() {\n                if style_number \u003e 0 {\n                    write!(f, \", \")?;\n                }\n                write!(f, \"{style} \")?;\n            }\n            writeln!(f)?;\n        }\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::{\n        diagrams::flowchart::flowchart_node::FlowchartNodeBuilder,\n        shared::{StyleClassBuilder, style_class::Color},\n        traits::{EdgeBuilder, NodeBuilder},\n    };\n\n    #[test]\n    fn test_flowchart_edge_display() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n        let node1 = Rc::new(FlowchartNodeBuilder::default().label(\"A\")?.id(0).build()?);\n        let node2 = Rc::new(FlowchartNodeBuilder::default().label(\"B\")?.id(1).build()?);\n        let style_class = Rc::new(\n            StyleClassBuilder::default()\n                .name(\"myStyle\")?\n                .property(StyleProperty::Stroke(Color::from((255, 0, 0))))?\n                .build()?,\n        );\n\n        let edge = FlowchartEdgeBuilder::default()\n            .id(1)\n            .source(node1.clone())?\n            .destination(node2.clone())?\n            .label(\"Edge Label\")?\n            .line_style(LineStyle::Dashed)\n            .left_arrow_shape(ArrowShape::Circle)?\n            .right_arrow_shape(ArrowShape::X)?\n            .curve_style(CurveStyle::StepAfter)\n            .length(2)\n            .style_class(style_class.clone())?\n            .style_property(StyleProperty::Stroke(Color::from((255, 0, 0))))?\n            .build()?;\n\n        let output = format!(\"{}\", edge);\n        assert!(output.contains(\"v0 e1@o-..-x|\\\"`Edge Label`\\\"| v1\"));\n        assert!(output.contains(\"e1@{curve: stepAfter}\"));\n        assert!(output.contains(\"class e1 myStyle\"));\n        assert!(output.contains(\"linkStyle e1 stroke: #ff0000\"));\n\n        Ok(())\n    }\n\n    #[test]\n    fn test_flowchart_edge_traits() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n        let node1 = Rc::new(FlowchartNodeBuilder::default().label(\"A\")?.id(0).build()?);\n        let node2 = Rc::new(FlowchartNodeBuilder::default().label(\"B\")?.id(1).build()?);\n        let style_class = Rc::new(\n            StyleClassBuilder::default()\n                .name(\"myStyle\")?\n                .property(StyleProperty::Stroke(Color::from((255, 0, 0))))?\n                .build()?,\n        );\n\n        let edge = FlowchartEdgeBuilder::default()\n            .id(1)\n            .source(node1.clone())?\n            .destination(node2.clone())?\n            .style_class(style_class.clone())?\n            .build()?;\n\n        assert_eq!(edge.classes().count(), 1);\n        assert_eq!(edge.classes().next().unwrap().name(), \"myStyle\");\n        Ok(())\n    }\n}\n","traces":[{"line":60,"address":[651568],"length":1,"stats":{"Line":1}},{"line":61,"address":[651573],"length":1,"stats":{"Line":1}},{"line":64,"address":[651584],"length":1,"stats":{"Line":4}},{"line":65,"address":[651589],"length":1,"stats":{"Line":3}},{"line":68,"address":[651520],"length":1,"stats":{"Line":3}},{"line":69,"address":[651525],"length":1,"stats":{"Line":3}},{"line":72,"address":[651600],"length":1,"stats":{"Line":1}},{"line":73,"address":[651605],"length":1,"stats":{"Line":1}},{"line":76,"address":[651504],"length":1,"stats":{"Line":1}},{"line":77,"address":[651509],"length":1,"stats":{"Line":2}},{"line":80,"address":[651536],"length":1,"stats":{"Line":1}},{"line":81,"address":[651541],"length":1,"stats":{"Line":1}},{"line":84,"address":[651552],"length":1,"stats":{"Line":1}},{"line":85,"address":[651557],"length":1,"stats":{"Line":1}},{"line":90,"address":[659344],"length":1,"stats":{"Line":1}},{"line":92,"address":[659358],"length":1,"stats":{"Line":1}},{"line":97,"address":[656533,656539,651712],"length":1,"stats":{"Line":1}},{"line":98,"address":[651762,651838],"length":1,"stats":{"Line":1}},{"line":99,"address":[651824,651902],"length":1,"stats":{"Line":2}},{"line":100,"address":[652062,651947],"length":1,"stats":{"Line":0}},{"line":101,"address":[652156,651979],"length":1,"stats":{"Line":0}},{"line":102,"address":[652018,652211],"length":1,"stats":{"Line":2}},{"line":105,"address":[652119,652481],"length":1,"stats":{"Line":2}},{"line":106,"address":[652614,652531],"length":1,"stats":{"Line":0}},{"line":107,"address":[652628],"length":1,"stats":{"Line":0}},{"line":109,"address":[652710,652553],"length":1,"stats":{"Line":2}},{"line":111,"address":[652667],"length":1,"stats":{"Line":0}},{"line":114,"address":[656464,653411],"length":1,"stats":{"Line":1}},{"line":117,"address":[652914,652684],"length":1,"stats":{"Line":2}},{"line":118,"address":[527463,527440],"length":1,"stats":{"Line":3}},{"line":119,"address":[653105,653038],"length":1,"stats":{"Line":2}},{"line":120,"address":[527657,527648,527568,527577],"length":1,"stats":{"Line":3}},{"line":122,"address":[527616,527625,527600,527609],"length":1,"stats":{"Line":3}},{"line":125,"address":[654107],"length":1,"stats":{"Line":1}},{"line":126,"address":[656443,654232],"length":1,"stats":{"Line":1}},{"line":129,"address":[654625,654198],"length":1,"stats":{"Line":2}},{"line":130,"address":[656019,654735],"length":1,"stats":{"Line":2}},{"line":133,"address":[654773],"length":1,"stats":{"Line":1}},{"line":134,"address":[654812,655947,654912],"length":1,"stats":{"Line":2}},{"line":135,"address":[655169],"length":1,"stats":{"Line":1}},{"line":136,"address":[655451],"length":1,"stats":{"Line":1}},{"line":137,"address":[655926,655650],"length":1,"stats":{"Line":0}},{"line":139,"address":[655767,655627],"length":1,"stats":{"Line":2}},{"line":141,"address":[655466],"length":1,"stats":{"Line":1}},{"line":143,"address":[654882],"length":1,"stats":{"Line":1}}],"covered":39,"coverable":45},{"path":["/","home","lucac","github","mermaid-builder","src","diagrams","flowchart","flowchart_node","builder.rs"],"content":"//! Submodule defining a builder struct to construct flowchart nodes in the\n//! flowchart Mermaid diagrams.\n\nuse std::rc::Rc;\n\nuse crate::{\n    diagrams::flowchart::flowchart_node::{ClickEvent, FlowchartNode, shape::FlowchartNodeShape},\n    errors::NodeError,\n    shared::{\n        StyleClass, StyleClassError, generic_configuration::Direction,\n        generic_node::GenericNodeBuilder,\n    },\n    traits::{Node, NodeBuilder},\n};\n\n#[derive(Default, Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// Builder for creating a `FlowchartNode`.\n///\n/// # Example\n///\n/// ```\n/// use mermaid_builder::prelude::*;\n///\n/// let node = FlowchartNodeBuilder::default()\n///     .label(\"My Node\")\n///     .unwrap()\n///     .shape(FlowchartNodeShape::Circle)\n///     .id(0)\n///     .build()\n///     .unwrap();\n/// ```\npub struct FlowchartNodeBuilder {\n    /// Shared attributes builder for the node.\n    builder: GenericNodeBuilder,\n    /// The click event associated with the node, if any.\n    click_event: Option\u003cClickEvent\u003e,\n    /// The shape of the flowchart node.\n    shape: FlowchartNodeShape,\n    /// Possible subnodes of the flowchart node.\n    subnodes: Vec\u003cRc\u003cFlowchartNode\u003e\u003e,\n    /// The direction of the subgraph, if applicable.\n    direction: Option\u003cDirection\u003e,\n}\n\nimpl FlowchartNodeBuilder {\n    #[must_use]\n    /// Sets the click event for the flowchart node.\n    pub fn click_event(mut self, click_event: ClickEvent) -\u003e Self {\n        self.click_event = Some(click_event);\n        self\n    }\n\n    #[must_use]\n    /// Sets the shape of the flowchart node.\n    pub fn shape(mut self, shape: FlowchartNodeShape) -\u003e Self {\n        self.shape = shape;\n        self\n    }\n\n    /// Adds a subnode to the flowchart node.\n    ///\n    /// # Arguments\n    ///\n    /// * `subnode`: The subnode to be added, wrapped in a `Rc` for shared\n    ///   ownership.\n    ///\n    /// # Errors\n    ///\n    /// * If the subnode is already present in the list, an error is returned.\n    pub fn subnode(mut self, subnode: Rc\u003cFlowchartNode\u003e) -\u003e Result\u003cSelf, NodeError\u003e {\n        if self.subnodes.contains(\u0026subnode) {\n            return Err(NodeError::DuplicateNode(subnode.label().to_owned()));\n        }\n\n        self.subnodes.push(subnode);\n        Ok(self)\n    }\n\n    #[must_use]\n    /// Returns whether the current node builder is a subgraph node.\n    pub fn is_subgraph(\u0026self) -\u003e bool {\n        !self.subnodes.is_empty()\n    }\n\n    #[must_use]\n    /// Sets the direction of the subgraph for the flowchart node.\n    ///\n    /// # Arguments\n    ///\n    /// * `direction`: The direction of the subgraph.\n    pub fn direction(mut self, direction: Direction) -\u003e Self {\n        self.direction = Some(direction);\n        self\n    }\n\n    #[must_use]\n    /// Returns the direction of the subgraph, if set.\n    pub fn get_direction(\u0026self) -\u003e Option\u003cDirection\u003e {\n        self.direction\n    }\n\n    #[must_use]\n    /// Resets the direction of the subgraph for the flowchart node.\n    pub fn reset_direction(mut self) -\u003e Self {\n        self.direction = None;\n        self\n    }\n}\n\nimpl TryFrom\u003cFlowchartNodeBuilder\u003e for FlowchartNode {\n    type Error = NodeError;\n\n    fn try_from(mut builder: FlowchartNodeBuilder) -\u003e Result\u003cSelf, Self::Error\u003e {\n        if builder.direction.is_some() \u0026\u0026 builder.subnodes.is_empty() {\n            return Err(NodeError::MissingSubnodes);\n        }\n\n        builder.subnodes.sort_unstable();\n\n        Ok(FlowchartNode {\n            node: builder.builder.try_into()?,\n            click_event: builder.click_event,\n            shape: builder.shape,\n            subnodes: builder.subnodes,\n            direction: builder.direction,\n        })\n    }\n}\n\nimpl NodeBuilder for FlowchartNodeBuilder {\n    type Node = FlowchartNode;\n    type Error = NodeError;\n\n    fn build(self) -\u003e Result\u003cSelf::Node, Self::Error\u003e {\n        self.try_into()\n    }\n\n    fn id(mut self, id: u64) -\u003e Self {\n        self.builder = self.builder.id(id);\n        self\n    }\n\n    fn get_id(\u0026self) -\u003e Option\u003cu64\u003e {\n        self.builder.get_id()\n    }\n\n    fn label\u003cS: ToString\u003e(mut self, label: S) -\u003e Result\u003cSelf, Self::Error\u003e {\n        self.builder = self.builder.label(label)?;\n        Ok(self)\n    }\n\n    fn get_label(\u0026self) -\u003e Option\u003c\u0026String\u003e {\n        self.builder.get_label()\n    }\n\n    fn style_class(mut self, style_class: Rc\u003cStyleClass\u003e) -\u003e Result\u003cSelf, StyleClassError\u003e {\n        self.builder = self.builder.style_class(style_class)?;\n        Ok(self)\n    }\n\n    fn style_property(\n        mut self,\n        property: crate::shared::StyleProperty,\n    ) -\u003e Result\u003cSelf, StyleClassError\u003e {\n        self.builder = self.builder.style_property(property)?;\n        Ok(self)\n    }\n\n    fn style_properties(\u0026self) -\u003e impl Iterator\u003cItem = \u0026crate::prelude::StyleProperty\u003e {\n        self.builder.style_properties()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::{\n        shared::{\n            ClickEvent, StyleClassBuilder, StyleProperty,\n            click_event::Navigation,\n            style_class::Unit,\n        },\n        traits::node::Node,\n    };\n\n    #[test]\n    fn test_flowchart_node_builder() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n        let style_class = Rc::new(\n            StyleClassBuilder::default()\n                .name(\"test\")?\n                .property(StyleProperty::StrokeWidth(Unit::Pixel(2)))?\n                .build()?,\n        );\n        let subnode = Rc::new(FlowchartNodeBuilder::default().label(\"Sub\")?.id(2).build()?);\n\n        let node = FlowchartNodeBuilder::default()\n            .id(1)\n            .label(\"My Node\")?\n            .shape(FlowchartNodeShape::Circle)\n            .click_event(ClickEvent::Navigation(Navigation::new(\"https://example.com\")))\n            .subnode(subnode.clone())?\n            .direction(Direction::TopToBottom)\n            .style_class(style_class.clone())?\n            .style_property(StyleProperty::StrokeWidth(Unit::Pixel(2)))?\n            .build()?;\n\n        assert_eq!(node.id(), 1);\n        assert_eq!(node.label(), \"My Node\");\n        assert_eq!(node.shape, FlowchartNodeShape::Circle);\n        assert!(matches!(node.click_event, Some(ClickEvent::Navigation { .. })));\n        assert_eq!(node.subnodes.len(), 1);\n        assert_eq!(node.direction, Some(Direction::TopToBottom));\n        assert_eq!(node.classes().count(), 1);\n        assert_eq!(node.styles().count(), 1);\n        Ok(())\n    }\n\n    #[test]\n    fn test_flowchart_node_builder_subgraph_methods() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n        let mut builder = FlowchartNodeBuilder::default();\n        assert!(!builder.is_subgraph());\n\n        let subnode = Rc::new(FlowchartNodeBuilder::default().label(\"Sub\")?.id(2).build()?);\n        builder = builder.subnode(subnode)?;\n        assert!(builder.is_subgraph());\n\n        builder = builder.direction(Direction::LeftToRight);\n        assert_eq!(builder.get_direction(), Some(Direction::LeftToRight));\n\n        builder = builder.reset_direction();\n        assert_eq!(builder.get_direction(), None);\n\n        Ok(())\n    }\n}\n","traces":[{"line":49,"address":[598896,599096],"length":1,"stats":{"Line":1}},{"line":50,"address":[598923,599047],"length":1,"stats":{"Line":2}},{"line":51,"address":[599076],"length":1,"stats":{"Line":1}},{"line":56,"address":[599200],"length":1,"stats":{"Line":1}},{"line":57,"address":[599218],"length":1,"stats":{"Line":1}},{"line":58,"address":[599224],"length":1,"stats":{"Line":1}},{"line":71,"address":[599681,599248],"length":1,"stats":{"Line":1}},{"line":72,"address":[599283,599376],"length":1,"stats":{"Line":2}},{"line":73,"address":[599507,599431],"length":1,"stats":{"Line":0}},{"line":76,"address":[599402],"length":1,"stats":{"Line":1}},{"line":77,"address":[599448],"length":1,"stats":{"Line":1}},{"line":82,"address":[599120],"length":1,"stats":{"Line":1}},{"line":83,"address":[599125],"length":1,"stats":{"Line":1}},{"line":92,"address":[599712],"length":1,"stats":{"Line":1}},{"line":93,"address":[599730],"length":1,"stats":{"Line":1}},{"line":94,"address":[599736],"length":1,"stats":{"Line":1}},{"line":99,"address":[599152],"length":1,"stats":{"Line":1}},{"line":100,"address":[599157],"length":1,"stats":{"Line":1}},{"line":105,"address":[599168],"length":1,"stats":{"Line":1}},{"line":106,"address":[599176],"length":1,"stats":{"Line":1}},{"line":107,"address":[599183],"length":1,"stats":{"Line":1}},{"line":114,"address":[769184,770151],"length":1,"stats":{"Line":9}},{"line":115,"address":[769325,769362,769214],"length":1,"stats":{"Line":16}},{"line":116,"address":[769392],"length":1,"stats":{"Line":0}},{"line":119,"address":[769465,769336],"length":1,"stats":{"Line":15}},{"line":121,"address":[769863],"length":1,"stats":{"Line":11}},{"line":122,"address":[770016,769477],"length":1,"stats":{"Line":10}},{"line":123,"address":[769764],"length":1,"stats":{"Line":11}},{"line":124,"address":[769799],"length":1,"stats":{"Line":11}},{"line":125,"address":[769809],"length":1,"stats":{"Line":11}},{"line":126,"address":[769853],"length":1,"stats":{"Line":11}},{"line":135,"address":[601408],"length":1,"stats":{"Line":6}},{"line":136,"address":[601425],"length":1,"stats":{"Line":6}},{"line":139,"address":[601391,601168,601370],"length":1,"stats":{"Line":4}},{"line":140,"address":[601197,601323],"length":1,"stats":{"Line":14}},{"line":141,"address":[601347],"length":1,"stats":{"Line":5}},{"line":144,"address":[601472],"length":1,"stats":{"Line":1}},{"line":145,"address":[601477],"length":1,"stats":{"Line":1}},{"line":148,"address":[517920,518432],"length":1,"stats":{"Line":3}},{"line":149,"address":[518124,517958],"length":1,"stats":{"Line":8}},{"line":150,"address":[518300],"length":1,"stats":{"Line":5}},{"line":153,"address":[601488],"length":1,"stats":{"Line":0}},{"line":154,"address":[601493],"length":1,"stats":{"Line":0}},{"line":157,"address":[599824,600357],"length":1,"stats":{"Line":1}},{"line":158,"address":[599854,600020],"length":1,"stats":{"Line":2}},{"line":159,"address":[600225],"length":1,"stats":{"Line":1}},{"line":162,"address":[600432,601076],"length":1,"stats":{"Line":1}},{"line":166,"address":[600490,600739],"length":1,"stats":{"Line":2}},{"line":167,"address":[600944],"length":1,"stats":{"Line":1}},{"line":170,"address":[601152],"length":1,"stats":{"Line":0}},{"line":171,"address":[601157],"length":1,"stats":{"Line":0}}],"covered":45,"coverable":51},{"path":["/","home","lucac","github","mermaid-builder","src","diagrams","flowchart","flowchart_node","shape.rs"],"content":"//! Submodule defining the possible shapes for nodes in Mermaid diagrams.\nuse std::{fmt::Display, str::FromStr};\n\n#[derive(Default, Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// `FlowchartNodeShape` represents all supported node shapes for Mermaid\n/// diagrams.\npub enum FlowchartNodeShape {\n    /// Standard process shape\n    #[default]\n    Rectangle,\n    /// Represents an event\n    RoundEdges,\n    /// Terminal point\n    StadiumShape,\n    /// Subprocess\n    Subprocess,\n    /// Database storage\n    Cylinder,\n    /// Starting point\n    Circle,\n    /// Odd shape\n    Odd,\n    /// Decision-making step\n    Diamond,\n    /// Preparation or condition step\n    Hexagon,\n    /// Represents input or output (Lean right parallelogram)\n    LRParallelogram,\n    /// Represents output or input (Lean left parallelogram)\n    LLParallelogram,\n    /// Priority action (Base bottom trapezoid)\n    Trapezoid,\n    /// Manual task (Base top trapezoid)\n    ReverseTrapezoid,\n    /// Represents a stop point\n    DoubleCircle,\n    /// Represents a card\n    NotchedRectangle,\n    /// Lined/Shaded process shape\n    Linedrectangle,\n    /// Small starting point\n    SmallCircle,\n    /// Stop point\n    FramedCircle,\n    /// Fork or join in process flow\n    LongRectangle,\n    /// Represents a collate operation\n    Hourglass,\n    /// Adds a comment (Left curly brace)\n    LeftCurlyBrace,\n    /// Adds a comment (Right curly brace)\n    RightCurlyBrace,\n    /// Adds a comment (Braces on both sides)\n    CurlyBraces,\n    /// Communication link\n    LightningBolt,\n    /// Represents a document\n    Document,\n    /// Represents a delay\n    HalfRoundedRectangle,\n    /// Direct access storage\n    HorizontalCylinder,\n    /// Disk storage\n    LinedCylinder,\n    /// Represents a display\n    CurvedTrapezoid,\n    /// Divided process shape\n    DividedRectangle,\n    /// Extraction process\n    SmallTriangle,\n    /// Internal storage\n    WindowPane,\n    /// Junction point\n    FilledCircle,\n    /// Lined document\n    LinedDocument,\n    /// Loop limit step\n    NotchedPentagon,\n    /// Manual file operation\n    FlippedTriangle,\n    /// Manual input step\n    SlopedRectangle,\n    /// Multiple documents\n    StackedDocument,\n    /// Multiple processes\n    StackedRectangle,\n    /// Paper tape\n    Flag,\n    /// Stored data\n    BowTieRectangle,\n    /// Summary\n    CrossedCircle,\n    /// Tagged document\n    TaggedDocument,\n    /// Tagged process\n    TaggedRectangle,\n    /// Subprocess (framed rectangle)\n    FramedRectangle,\n    /// Text block\n    TextBlock,\n}\n\nimpl Display for FlowchartNodeShape {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::Rectangle =\u003e write!(f, \"rect\"),\n            Self::RoundEdges =\u003e write!(f, \"rounded\"),\n            Self::StadiumShape =\u003e write!(f, \"stadium\"),\n            Self::Subprocess =\u003e write!(f, \"subproc\"),\n            Self::Cylinder =\u003e write!(f, \"cyl\"),\n            Self::Circle =\u003e write!(f, \"circle\"),\n            Self::Odd =\u003e write!(f, \"odd\"),\n            Self::Diamond =\u003e write!(f, \"diamond\"),\n            Self::Hexagon =\u003e write!(f, \"hex\"),\n            Self::LRParallelogram =\u003e write!(f, \"lean-r\"),\n            Self::LLParallelogram =\u003e write!(f, \"lean-l\"),\n            Self::Trapezoid =\u003e write!(f, \"trap-b\"),\n            Self::ReverseTrapezoid =\u003e write!(f, \"trap-t\"),\n            Self::DoubleCircle =\u003e write!(f, \"dbl-circ\"),\n            Self::NotchedRectangle =\u003e write!(f, \"notch-rect\"),\n            Self::Linedrectangle =\u003e write!(f, \"lin-rect\"),\n            Self::SmallCircle =\u003e write!(f, \"sm-circ\"),\n            Self::FramedCircle =\u003e write!(f, \"framed-circle\"),\n            Self::LongRectangle =\u003e write!(f, \"fork\"),\n            Self::Hourglass =\u003e write!(f, \"hourglass\"),\n            Self::LeftCurlyBrace =\u003e write!(f, \"comment\"),\n            Self::RightCurlyBrace =\u003e write!(f, \"brace-r\"),\n            Self::CurlyBraces =\u003e write!(f, \"braces\"),\n            Self::LightningBolt =\u003e write!(f, \"bolt\"),\n            Self::Document =\u003e write!(f, \"doc\"),\n            Self::HalfRoundedRectangle =\u003e write!(f, \"delay\"),\n            Self::HorizontalCylinder =\u003e write!(f, \"das\"),\n            Self::LinedCylinder =\u003e write!(f, \"lin-cyl\"),\n            Self::CurvedTrapezoid =\u003e write!(f, \"curv-trap\"),\n            Self::DividedRectangle =\u003e write!(f, \"div-rect\"),\n            Self::SmallTriangle =\u003e write!(f, \"tri\"),\n            Self::WindowPane =\u003e write!(f, \"win-pane\"),\n            Self::FilledCircle =\u003e write!(f, \"f-circ\"),\n            Self::LinedDocument =\u003e write!(f, \"lin-doc\"),\n            Self::NotchedPentagon =\u003e write!(f, \"notch-pent\"),\n            Self::FlippedTriangle =\u003e write!(f, \"flip-tri\"),\n            Self::SlopedRectangle =\u003e write!(f, \"sl-rect\"),\n            Self::StackedDocument =\u003e write!(f, \"docs\"),\n            Self::StackedRectangle =\u003e write!(f, \"processes\"),\n            Self::Flag =\u003e write!(f, \"flag\"),\n            Self::BowTieRectangle =\u003e write!(f, \"bow-rect\"),\n            Self::CrossedCircle =\u003e write!(f, \"cross-circ\"),\n            Self::TaggedDocument =\u003e write!(f, \"tag-doc\"),\n            Self::TaggedRectangle =\u003e write!(f, \"tag-rect\"),\n            Self::FramedRectangle =\u003e write!(f, \"fr-rect\"),\n            Self::TextBlock =\u003e write!(f, \"text\"),\n        }\n    }\n}\n\nimpl FromStr for FlowchartNodeShape {\n    type Err = ();\n    fn from_str(s: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        match s.to_ascii_lowercase().as_str() {\n            // Rectangle\n            \"rect\" | \"rectangle\" | \"proc\" | \"process\" =\u003e Ok(Self::Rectangle),\n            // Rounded Rectangle\n            \"rounded\" | \"event\" =\u003e Ok(Self::RoundEdges),\n            // Stadium\n            \"stadium\" | \"pill\" | \"terminal\" =\u003e Ok(Self::StadiumShape),\n            // Subprocess\n            \"subproc\" | \"subprocess\" | \"subroutine\" | \"framed-rectangle\" =\u003e Ok(Self::Subprocess),\n            // Cylinder\n            \"cyl\" | \"cylinder\" | \"database\" | \"db\" =\u003e Ok(Self::Cylinder),\n            // Circle\n            \"circle\" | \"circ\" =\u003e Ok(Self::Circle),\n            // Odd\n            \"odd\" =\u003e Ok(Self::Odd),\n            // Diamond\n            \"diamond\" | \"diam\" | \"decision\" | \"question\" =\u003e Ok(Self::Diamond),\n            // Hexagon\n            \"hex\" | \"hexagon\" | \"prepare\" =\u003e Ok(Self::Hexagon),\n            // Lean right parallelogram\n            \"lean-r\" | \"lean-right\" | \"in-out\" =\u003e Ok(Self::LRParallelogram),\n            // Lean left parallelogram\n            \"lean-l\" | \"lean-left\" | \"out-in\" =\u003e Ok(Self::LLParallelogram),\n            // Base bottom trapezoid\n            \"trap-b\" | \"trapezoid\" | \"priority\" | \"trapezoid-bottom\" =\u003e Ok(Self::Trapezoid),\n            // Base top trapezoid\n            \"trap-t\" | \"inv-trapezoid\" | \"manual\" | \"trapezoid-top\" =\u003e Ok(Self::ReverseTrapezoid),\n            // Double Circle\n            \"dbl-circ\" | \"double-circle\" | \"stop\" =\u003e Ok(Self::DoubleCircle),\n            // Notched Rectangle\n            \"notch-rect\" | \"card\" | \"notched-rectangle\" =\u003e Ok(Self::NotchedRectangle),\n            // Lined Rectangle\n            \"lin-rect\" | \"lin-proc\" | \"lined-process\" | \"lined-rectangle\" | \"shaded-process\" =\u003e {\n                Ok(Self::Linedrectangle)\n            }\n            // Small Circle\n            \"sm-circ\" | \"small-circle\" | \"start\" =\u003e Ok(Self::SmallCircle),\n            // Framed Circle\n            \"framed-circle\" | \"fr-circ\" =\u003e Ok(Self::FramedCircle),\n            // Long Rectangle\n            \"fork\" | \"join\" =\u003e Ok(Self::LongRectangle),\n            // Hourglass\n            \"hourglass\" | \"collate\" =\u003e Ok(Self::Hourglass),\n            // Left Curly Brace\n            \"comment\" | \"brace-l\" =\u003e Ok(Self::LeftCurlyBrace),\n            // Right Curly Brace\n            \"brace-r\" =\u003e Ok(Self::RightCurlyBrace),\n            // Curly Braces\n            \"braces\" =\u003e Ok(Self::CurlyBraces),\n            // Lightning Bolt\n            \"bolt\" | \"com-link\" | \"lightning-bolt\" =\u003e Ok(Self::LightningBolt),\n            // Document\n            \"doc\" | \"document\" =\u003e Ok(Self::Document),\n            // Half-Rounded Rectangle\n            \"delay\" | \"half-rounded-rectangle\" =\u003e Ok(Self::HalfRoundedRectangle),\n            // Horizontal Cylinder\n            \"das\" | \"h-cyl\" | \"horizontal-cylinder\" =\u003e Ok(Self::HorizontalCylinder),\n            // Lined Cylinder\n            \"lin-cyl\" | \"disk\" | \"lined-cylinder\" =\u003e Ok(Self::LinedCylinder),\n            // Curved Trapezoid\n            \"curv-trap\" | \"curved-trapezoid\" | \"display\" =\u003e Ok(Self::CurvedTrapezoid),\n            // Divided Rectangle\n            \"div-rect\" | \"div-proc\" | \"divided-process\" | \"divided-rectangle\" =\u003e {\n                Ok(Self::DividedRectangle)\n            }\n            // Small Triangle\n            \"tri\" | \"extract\" | \"triangle\" =\u003e Ok(Self::SmallTriangle),\n            // Window Pane\n            \"win-pane\" | \"internal-storage\" | \"window-pane\" =\u003e Ok(Self::WindowPane),\n            // Filled Circle\n            \"f-circ\" | \"filled-circle\" | \"junction\" =\u003e Ok(Self::FilledCircle),\n            // Lined Document\n            \"lin-doc\" | \"lined-document\" =\u003e Ok(Self::LinedDocument),\n            // Notched Pentagon\n            \"notch-pent\" | \"loop-limit\" | \"notched-pentagon\" =\u003e Ok(Self::NotchedPentagon),\n            // Flipped Triangle\n            \"flip-tri\" | \"flipped-triangle\" | \"manual-file\" =\u003e Ok(Self::FlippedTriangle),\n            // Sloped Rectangle\n            \"sl-rect\" | \"manual-input\" | \"sloped-rectangle\" =\u003e Ok(Self::SlopedRectangle),\n            // Stacked Document\n            \"docs\" | \"documents\" | \"st-doc\" | \"stacked-document\" =\u003e Ok(Self::StackedDocument),\n            // Stacked Rectangle\n            \"processes\" | \"procs\" | \"st-rect\" | \"stacked-rectangle\" =\u003e Ok(Self::StackedRectangle),\n            // Flag\n            \"flag\" | \"paper-tape\" =\u003e Ok(Self::Flag),\n            // Bow Tie Rectangle\n            \"bow-rect\" | \"bow-tie-rectangle\" | \"stored-data\" =\u003e Ok(Self::BowTieRectangle),\n            // Crossed Circle\n            \"cross-circ\" | \"crossed-circle\" | \"summary\" =\u003e Ok(Self::CrossedCircle),\n            // Tagged Document\n            \"tag-doc\" | \"tagged-document\" =\u003e Ok(Self::TaggedDocument),\n            // Tagged Rectangle\n            \"tag-rect\" | \"tag-proc\" | \"tagged-process\" | \"tagged-rectangle\" =\u003e {\n                Ok(Self::TaggedRectangle)\n            }\n            // Framed Rectangle (added for completeness)\n            \"fr-rect\" =\u003e Ok(Self::FramedRectangle),\n            // Text Block\n            \"text\" | \"text-block\" =\u003e Ok(Self::TextBlock),\n            _ =\u003e Err(()),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_flowchart_node_shape_display() {\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::Rectangle), \"rect\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::RoundEdges), \"rounded\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::StadiumShape), \"stadium\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::Subprocess), \"subproc\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::Cylinder), \"cyl\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::Circle), \"circle\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::Odd), \"odd\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::Diamond), \"diamond\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::Hexagon), \"hex\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::LRParallelogram), \"lean-r\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::LLParallelogram), \"lean-l\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::Trapezoid), \"trap-b\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::ReverseTrapezoid), \"trap-t\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::DoubleCircle), \"dbl-circ\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::NotchedRectangle), \"notch-rect\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::Linedrectangle), \"lin-rect\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::SmallCircle), \"sm-circ\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::FramedCircle), \"framed-circle\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::LongRectangle), \"fork\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::Hourglass), \"hourglass\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::LeftCurlyBrace), \"comment\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::RightCurlyBrace), \"brace-r\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::CurlyBraces), \"braces\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::LightningBolt), \"bolt\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::Document), \"doc\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::HalfRoundedRectangle), \"delay\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::HorizontalCylinder), \"das\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::LinedCylinder), \"lin-cyl\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::CurvedTrapezoid), \"curv-trap\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::DividedRectangle), \"div-rect\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::SmallTriangle), \"tri\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::WindowPane), \"win-pane\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::FilledCircle), \"f-circ\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::LinedDocument), \"lin-doc\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::NotchedPentagon), \"notch-pent\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::FlippedTriangle), \"flip-tri\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::SlopedRectangle), \"sl-rect\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::StackedDocument), \"docs\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::StackedRectangle), \"processes\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::Flag), \"flag\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::BowTieRectangle), \"bow-rect\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::CrossedCircle), \"cross-circ\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::TaggedDocument), \"tag-doc\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::TaggedRectangle), \"tag-rect\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::FramedRectangle), \"fr-rect\");\n        assert_eq!(format!(\"{}\", FlowchartNodeShape::TextBlock), \"text\");\n    }\n\n    #[test]\n    #[allow(clippy::too_many_lines)]\n    fn test_flowchart_node_shape_from_str() {\n        assert_eq!(FlowchartNodeShape::from_str(\"rect\").unwrap(), FlowchartNodeShape::Rectangle);\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"rectangle\").unwrap(),\n            FlowchartNodeShape::Rectangle\n        );\n        assert_eq!(FlowchartNodeShape::from_str(\"proc\").unwrap(), FlowchartNodeShape::Rectangle);\n        assert_eq!(FlowchartNodeShape::from_str(\"process\").unwrap(), FlowchartNodeShape::Rectangle);\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"rounded\").unwrap(),\n            FlowchartNodeShape::RoundEdges\n        );\n        assert_eq!(FlowchartNodeShape::from_str(\"event\").unwrap(), FlowchartNodeShape::RoundEdges);\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"stadium\").unwrap(),\n            FlowchartNodeShape::StadiumShape\n        );\n        assert_eq!(FlowchartNodeShape::from_str(\"pill\").unwrap(), FlowchartNodeShape::StadiumShape);\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"terminal\").unwrap(),\n            FlowchartNodeShape::StadiumShape\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"subproc\").unwrap(),\n            FlowchartNodeShape::Subprocess\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"subprocess\").unwrap(),\n            FlowchartNodeShape::Subprocess\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"subroutine\").unwrap(),\n            FlowchartNodeShape::Subprocess\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"framed-rectangle\").unwrap(),\n            FlowchartNodeShape::Subprocess\n        );\n        assert_eq!(FlowchartNodeShape::from_str(\"cyl\").unwrap(), FlowchartNodeShape::Cylinder);\n        assert_eq!(FlowchartNodeShape::from_str(\"cylinder\").unwrap(), FlowchartNodeShape::Cylinder);\n        assert_eq!(FlowchartNodeShape::from_str(\"database\").unwrap(), FlowchartNodeShape::Cylinder);\n        assert_eq!(FlowchartNodeShape::from_str(\"db\").unwrap(), FlowchartNodeShape::Cylinder);\n        assert_eq!(FlowchartNodeShape::from_str(\"circle\").unwrap(), FlowchartNodeShape::Circle);\n        assert_eq!(FlowchartNodeShape::from_str(\"circ\").unwrap(), FlowchartNodeShape::Circle);\n        assert_eq!(FlowchartNodeShape::from_str(\"odd\").unwrap(), FlowchartNodeShape::Odd);\n        assert_eq!(FlowchartNodeShape::from_str(\"diamond\").unwrap(), FlowchartNodeShape::Diamond);\n        assert_eq!(FlowchartNodeShape::from_str(\"diam\").unwrap(), FlowchartNodeShape::Diamond);\n        assert_eq!(FlowchartNodeShape::from_str(\"decision\").unwrap(), FlowchartNodeShape::Diamond);\n        assert_eq!(FlowchartNodeShape::from_str(\"question\").unwrap(), FlowchartNodeShape::Diamond);\n        assert_eq!(FlowchartNodeShape::from_str(\"hex\").unwrap(), FlowchartNodeShape::Hexagon);\n        assert_eq!(FlowchartNodeShape::from_str(\"hexagon\").unwrap(), FlowchartNodeShape::Hexagon);\n        assert_eq!(FlowchartNodeShape::from_str(\"prepare\").unwrap(), FlowchartNodeShape::Hexagon);\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"lean-r\").unwrap(),\n            FlowchartNodeShape::LRParallelogram\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"lean-right\").unwrap(),\n            FlowchartNodeShape::LRParallelogram\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"in-out\").unwrap(),\n            FlowchartNodeShape::LRParallelogram\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"lean-l\").unwrap(),\n            FlowchartNodeShape::LLParallelogram\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"lean-left\").unwrap(),\n            FlowchartNodeShape::LLParallelogram\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"out-in\").unwrap(),\n            FlowchartNodeShape::LLParallelogram\n        );\n        assert_eq!(FlowchartNodeShape::from_str(\"trap-b\").unwrap(), FlowchartNodeShape::Trapezoid);\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"trapezoid\").unwrap(),\n            FlowchartNodeShape::Trapezoid\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"priority\").unwrap(),\n            FlowchartNodeShape::Trapezoid\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"trapezoid-bottom\").unwrap(),\n            FlowchartNodeShape::Trapezoid\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"trap-t\").unwrap(),\n            FlowchartNodeShape::ReverseTrapezoid\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"inv-trapezoid\").unwrap(),\n            FlowchartNodeShape::ReverseTrapezoid\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"manual\").unwrap(),\n            FlowchartNodeShape::ReverseTrapezoid\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"trapezoid-top\").unwrap(),\n            FlowchartNodeShape::ReverseTrapezoid\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"dbl-circ\").unwrap(),\n            FlowchartNodeShape::DoubleCircle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"double-circle\").unwrap(),\n            FlowchartNodeShape::DoubleCircle\n        );\n        assert_eq!(FlowchartNodeShape::from_str(\"stop\").unwrap(), FlowchartNodeShape::DoubleCircle);\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"notch-rect\").unwrap(),\n            FlowchartNodeShape::NotchedRectangle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"card\").unwrap(),\n            FlowchartNodeShape::NotchedRectangle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"notched-rectangle\").unwrap(),\n            FlowchartNodeShape::NotchedRectangle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"lin-rect\").unwrap(),\n            FlowchartNodeShape::Linedrectangle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"lin-proc\").unwrap(),\n            FlowchartNodeShape::Linedrectangle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"lined-process\").unwrap(),\n            FlowchartNodeShape::Linedrectangle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"lined-rectangle\").unwrap(),\n            FlowchartNodeShape::Linedrectangle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"shaded-process\").unwrap(),\n            FlowchartNodeShape::Linedrectangle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"sm-circ\").unwrap(),\n            FlowchartNodeShape::SmallCircle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"small-circle\").unwrap(),\n            FlowchartNodeShape::SmallCircle\n        );\n        assert_eq!(FlowchartNodeShape::from_str(\"start\").unwrap(), FlowchartNodeShape::SmallCircle);\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"framed-circle\").unwrap(),\n            FlowchartNodeShape::FramedCircle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"fr-circ\").unwrap(),\n            FlowchartNodeShape::FramedCircle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"fork\").unwrap(),\n            FlowchartNodeShape::LongRectangle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"join\").unwrap(),\n            FlowchartNodeShape::LongRectangle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"hourglass\").unwrap(),\n            FlowchartNodeShape::Hourglass\n        );\n        assert_eq!(FlowchartNodeShape::from_str(\"collate\").unwrap(), FlowchartNodeShape::Hourglass);\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"comment\").unwrap(),\n            FlowchartNodeShape::LeftCurlyBrace\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"brace-l\").unwrap(),\n            FlowchartNodeShape::LeftCurlyBrace\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"brace-r\").unwrap(),\n            FlowchartNodeShape::RightCurlyBrace\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"braces\").unwrap(),\n            FlowchartNodeShape::CurlyBraces\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"bolt\").unwrap(),\n            FlowchartNodeShape::LightningBolt\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"com-link\").unwrap(),\n            FlowchartNodeShape::LightningBolt\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"lightning-bolt\").unwrap(),\n            FlowchartNodeShape::LightningBolt\n        );\n        assert_eq!(FlowchartNodeShape::from_str(\"doc\").unwrap(), FlowchartNodeShape::Document);\n        assert_eq!(FlowchartNodeShape::from_str(\"document\").unwrap(), FlowchartNodeShape::Document);\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"delay\").unwrap(),\n            FlowchartNodeShape::HalfRoundedRectangle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"half-rounded-rectangle\").unwrap(),\n            FlowchartNodeShape::HalfRoundedRectangle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"das\").unwrap(),\n            FlowchartNodeShape::HorizontalCylinder\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"h-cyl\").unwrap(),\n            FlowchartNodeShape::HorizontalCylinder\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"horizontal-cylinder\").unwrap(),\n            FlowchartNodeShape::HorizontalCylinder\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"lin-cyl\").unwrap(),\n            FlowchartNodeShape::LinedCylinder\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"disk\").unwrap(),\n            FlowchartNodeShape::LinedCylinder\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"lined-cylinder\").unwrap(),\n            FlowchartNodeShape::LinedCylinder\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"curv-trap\").unwrap(),\n            FlowchartNodeShape::CurvedTrapezoid\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"curved-trapezoid\").unwrap(),\n            FlowchartNodeShape::CurvedTrapezoid\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"display\").unwrap(),\n            FlowchartNodeShape::CurvedTrapezoid\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"div-rect\").unwrap(),\n            FlowchartNodeShape::DividedRectangle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"div-proc\").unwrap(),\n            FlowchartNodeShape::DividedRectangle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"divided-process\").unwrap(),\n            FlowchartNodeShape::DividedRectangle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"divided-rectangle\").unwrap(),\n            FlowchartNodeShape::DividedRectangle\n        );\n        assert_eq!(FlowchartNodeShape::from_str(\"tri\").unwrap(), FlowchartNodeShape::SmallTriangle);\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"extract\").unwrap(),\n            FlowchartNodeShape::SmallTriangle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"triangle\").unwrap(),\n            FlowchartNodeShape::SmallTriangle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"win-pane\").unwrap(),\n            FlowchartNodeShape::WindowPane\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"internal-storage\").unwrap(),\n            FlowchartNodeShape::WindowPane\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"window-pane\").unwrap(),\n            FlowchartNodeShape::WindowPane\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"f-circ\").unwrap(),\n            FlowchartNodeShape::FilledCircle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"filled-circle\").unwrap(),\n            FlowchartNodeShape::FilledCircle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"junction\").unwrap(),\n            FlowchartNodeShape::FilledCircle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"lin-doc\").unwrap(),\n            FlowchartNodeShape::LinedDocument\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"lined-document\").unwrap(),\n            FlowchartNodeShape::LinedDocument\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"notch-pent\").unwrap(),\n            FlowchartNodeShape::NotchedPentagon\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"loop-limit\").unwrap(),\n            FlowchartNodeShape::NotchedPentagon\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"notched-pentagon\").unwrap(),\n            FlowchartNodeShape::NotchedPentagon\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"flip-tri\").unwrap(),\n            FlowchartNodeShape::FlippedTriangle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"flipped-triangle\").unwrap(),\n            FlowchartNodeShape::FlippedTriangle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"manual-file\").unwrap(),\n            FlowchartNodeShape::FlippedTriangle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"sl-rect\").unwrap(),\n            FlowchartNodeShape::SlopedRectangle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"manual-input\").unwrap(),\n            FlowchartNodeShape::SlopedRectangle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"sloped-rectangle\").unwrap(),\n            FlowchartNodeShape::SlopedRectangle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"docs\").unwrap(),\n            FlowchartNodeShape::StackedDocument\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"documents\").unwrap(),\n            FlowchartNodeShape::StackedDocument\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"st-doc\").unwrap(),\n            FlowchartNodeShape::StackedDocument\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"stacked-document\").unwrap(),\n            FlowchartNodeShape::StackedDocument\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"processes\").unwrap(),\n            FlowchartNodeShape::StackedRectangle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"procs\").unwrap(),\n            FlowchartNodeShape::StackedRectangle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"st-rect\").unwrap(),\n            FlowchartNodeShape::StackedRectangle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"stacked-rectangle\").unwrap(),\n            FlowchartNodeShape::StackedRectangle\n        );\n        assert_eq!(FlowchartNodeShape::from_str(\"flag\").unwrap(), FlowchartNodeShape::Flag);\n        assert_eq!(FlowchartNodeShape::from_str(\"paper-tape\").unwrap(), FlowchartNodeShape::Flag);\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"bow-rect\").unwrap(),\n            FlowchartNodeShape::BowTieRectangle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"bow-tie-rectangle\").unwrap(),\n            FlowchartNodeShape::BowTieRectangle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"stored-data\").unwrap(),\n            FlowchartNodeShape::BowTieRectangle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"cross-circ\").unwrap(),\n            FlowchartNodeShape::CrossedCircle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"crossed-circle\").unwrap(),\n            FlowchartNodeShape::CrossedCircle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"summary\").unwrap(),\n            FlowchartNodeShape::CrossedCircle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"tag-doc\").unwrap(),\n            FlowchartNodeShape::TaggedDocument\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"tagged-document\").unwrap(),\n            FlowchartNodeShape::TaggedDocument\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"tag-rect\").unwrap(),\n            FlowchartNodeShape::TaggedRectangle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"tag-proc\").unwrap(),\n            FlowchartNodeShape::TaggedRectangle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"tagged-process\").unwrap(),\n            FlowchartNodeShape::TaggedRectangle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"tagged-rectangle\").unwrap(),\n            FlowchartNodeShape::TaggedRectangle\n        );\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"fr-rect\").unwrap(),\n            FlowchartNodeShape::FramedRectangle\n        );\n        assert_eq!(FlowchartNodeShape::from_str(\"text\").unwrap(), FlowchartNodeShape::TextBlock);\n        assert_eq!(\n            FlowchartNodeShape::from_str(\"text-block\").unwrap(),\n            FlowchartNodeShape::TextBlock\n        );\n        assert!(FlowchartNodeShape::from_str(\"invalid\").is_err());\n    }\n}\n","traces":[{"line":105,"address":[488160],"length":1,"stats":{"Line":1}},{"line":106,"address":[488178],"length":1,"stats":{"Line":1}},{"line":107,"address":[488209],"length":1,"stats":{"Line":1}},{"line":108,"address":[488249],"length":1,"stats":{"Line":1}},{"line":109,"address":[488289],"length":1,"stats":{"Line":1}},{"line":110,"address":[488329],"length":1,"stats":{"Line":1}},{"line":111,"address":[488369],"length":1,"stats":{"Line":1}},{"line":112,"address":[488409],"length":1,"stats":{"Line":1}},{"line":113,"address":[488449],"length":1,"stats":{"Line":1}},{"line":114,"address":[488489],"length":1,"stats":{"Line":1}},{"line":115,"address":[488529],"length":1,"stats":{"Line":1}},{"line":116,"address":[488569],"length":1,"stats":{"Line":1}},{"line":117,"address":[488609],"length":1,"stats":{"Line":1}},{"line":118,"address":[488649],"length":1,"stats":{"Line":1}},{"line":119,"address":[488689],"length":1,"stats":{"Line":1}},{"line":120,"address":[488729],"length":1,"stats":{"Line":1}},{"line":121,"address":[488769],"length":1,"stats":{"Line":1}},{"line":122,"address":[488809],"length":1,"stats":{"Line":1}},{"line":123,"address":[488849],"length":1,"stats":{"Line":1}},{"line":124,"address":[488889],"length":1,"stats":{"Line":1}},{"line":125,"address":[488929],"length":1,"stats":{"Line":1}},{"line":126,"address":[488969],"length":1,"stats":{"Line":1}},{"line":127,"address":[489009],"length":1,"stats":{"Line":1}},{"line":128,"address":[489049],"length":1,"stats":{"Line":1}},{"line":129,"address":[489089],"length":1,"stats":{"Line":1}},{"line":130,"address":[489129],"length":1,"stats":{"Line":1}},{"line":131,"address":[489169],"length":1,"stats":{"Line":1}},{"line":132,"address":[489209],"length":1,"stats":{"Line":1}},{"line":133,"address":[489249],"length":1,"stats":{"Line":1}},{"line":134,"address":[489289],"length":1,"stats":{"Line":1}},{"line":135,"address":[489329],"length":1,"stats":{"Line":1}},{"line":136,"address":[489369],"length":1,"stats":{"Line":1}},{"line":137,"address":[489409],"length":1,"stats":{"Line":1}},{"line":138,"address":[489449],"length":1,"stats":{"Line":1}},{"line":139,"address":[489489],"length":1,"stats":{"Line":1}},{"line":140,"address":[489529],"length":1,"stats":{"Line":1}},{"line":141,"address":[489569],"length":1,"stats":{"Line":1}},{"line":142,"address":[489609],"length":1,"stats":{"Line":1}},{"line":143,"address":[489649],"length":1,"stats":{"Line":1}},{"line":144,"address":[489689],"length":1,"stats":{"Line":1}},{"line":145,"address":[489729],"length":1,"stats":{"Line":1}},{"line":146,"address":[489769],"length":1,"stats":{"Line":1}},{"line":147,"address":[489809],"length":1,"stats":{"Line":1}},{"line":148,"address":[489849],"length":1,"stats":{"Line":1}},{"line":149,"address":[489889],"length":1,"stats":{"Line":1}},{"line":150,"address":[489926],"length":1,"stats":{"Line":1}},{"line":151,"address":[489963],"length":1,"stats":{"Line":1}},{"line":152,"address":[490000],"length":1,"stats":{"Line":1}},{"line":159,"address":[491664,498872,498878],"length":1,"stats":{"Line":1}},{"line":160,"address":[491709,491805],"length":1,"stats":{"Line":2}},{"line":162,"address":[491827],"length":1,"stats":{"Line":1}},{"line":164,"address":[492064],"length":1,"stats":{"Line":1}},{"line":166,"address":[492187],"length":1,"stats":{"Line":1}},{"line":168,"address":[492365],"length":1,"stats":{"Line":1}},{"line":170,"address":[492574],"length":1,"stats":{"Line":1}},{"line":172,"address":[492783],"length":1,"stats":{"Line":1}},{"line":174,"address":[492894,492966],"length":1,"stats":{"Line":2}},{"line":176,"address":[492943,492983],"length":1,"stats":{"Line":2}},{"line":178,"address":[493165],"length":1,"stats":{"Line":1}},{"line":180,"address":[493325],"length":1,"stats":{"Line":1}},{"line":182,"address":[493485],"length":1,"stats":{"Line":1}},{"line":184,"address":[493645],"length":1,"stats":{"Line":1}},{"line":186,"address":[493854],"length":1,"stats":{"Line":1}},{"line":188,"address":[494063],"length":1,"stats":{"Line":1}},{"line":190,"address":[494223],"length":1,"stats":{"Line":1}},{"line":192,"address":[494472,494383],"length":1,"stats":{"Line":2}},{"line":193,"address":[494455],"length":1,"stats":{"Line":1}},{"line":196,"address":[494645],"length":1,"stats":{"Line":1}},{"line":198,"address":[494805],"length":1,"stats":{"Line":1}},{"line":200,"address":[494916],"length":1,"stats":{"Line":1}},{"line":202,"address":[495027],"length":1,"stats":{"Line":1}},{"line":204,"address":[495138],"length":1,"stats":{"Line":1}},{"line":206,"address":[495249,495321],"length":1,"stats":{"Line":2}},{"line":208,"address":[495383,495298,495338],"length":1,"stats":{"Line":3}},{"line":210,"address":[495400,495360],"length":1,"stats":{"Line":2}},{"line":212,"address":[495533],"length":1,"stats":{"Line":1}},{"line":214,"address":[495644],"length":1,"stats":{"Line":1}},{"line":216,"address":[495755],"length":1,"stats":{"Line":1}},{"line":218,"address":[495915],"length":1,"stats":{"Line":1}},{"line":220,"address":[496075],"length":1,"stats":{"Line":1}},{"line":222,"address":[496324,496235],"length":1,"stats":{"Line":2}},{"line":223,"address":[496307],"length":1,"stats":{"Line":1}},{"line":226,"address":[496444],"length":1,"stats":{"Line":1}},{"line":228,"address":[496604],"length":1,"stats":{"Line":1}},{"line":230,"address":[496764],"length":1,"stats":{"Line":1}},{"line":232,"address":[496924],"length":1,"stats":{"Line":1}},{"line":234,"address":[497035],"length":1,"stats":{"Line":1}},{"line":236,"address":[497195],"length":1,"stats":{"Line":1}},{"line":238,"address":[497355],"length":1,"stats":{"Line":1}},{"line":240,"address":[497515],"length":1,"stats":{"Line":1}},{"line":242,"address":[497724],"length":1,"stats":{"Line":1}},{"line":244,"address":[497933],"length":1,"stats":{"Line":1}},{"line":246,"address":[498044],"length":1,"stats":{"Line":1}},{"line":248,"address":[498204],"length":1,"stats":{"Line":1}},{"line":250,"address":[498364],"length":1,"stats":{"Line":1}},{"line":252,"address":[498564,498475],"length":1,"stats":{"Line":2}},{"line":253,"address":[498547],"length":1,"stats":{"Line":1}},{"line":256,"address":[498756,498684],"length":1,"stats":{"Line":2}},{"line":258,"address":[498733,498770],"length":1,"stats":{"Line":2}},{"line":259,"address":[498835],"length":1,"stats":{"Line":1}}],"covered":100,"coverable":100},{"path":["/","home","lucac","github","mermaid-builder","src","diagrams","flowchart","flowchart_node.rs"],"content":"//! Submodule defining a node which may be used in a flowchart diagram\n//! in Mermaid syntax.\n\nmod builder;\nmod shape;\nuse std::{fmt::Display, rc::Rc};\n\npub use builder::FlowchartNodeBuilder;\npub use shape::FlowchartNodeShape;\n\nuse crate::{\n    shared::{\n        ClickEvent, GenericNode, NODE_LETTER, StyleClass, generic_configuration::Direction,\n        style_class::StyleProperty,\n    },\n    traits::Node,\n};\n\n#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// Represents a node in a flowchart diagram, which can have various\n/// properties and may include click events.\n///\n/// # Examples\n///\n/// ```\n/// use mermaid_builder::{\n///     diagrams::flowchart::FlowchartNodeBuilder,\n///     traits::{Node, NodeBuilder},\n/// };\n///\n/// fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n///     let node = FlowchartNodeBuilder::default().label(\"My Node\")?.id(1).build()?;\n///\n///     assert_eq!(node.label(), \"My Node\");\n///     Ok(())\n/// }\n/// ```\npub struct FlowchartNode {\n    /// Underlying node structure.\n    node: GenericNode,\n    /// The click event associated with the node, if any.\n    click_event: Option\u003cClickEvent\u003e,\n    /// The shape of the node, which can be customized.\n    shape: FlowchartNodeShape,\n    /// The sub-nodes, when the node is a subgraph.\n    subnodes: Vec\u003cRc\u003cFlowchartNode\u003e\u003e,\n    /// The direction of the subgraph, if applicable.\n    direction: Option\u003cDirection\u003e,\n}\n\nimpl FlowchartNode {\n    /// Returns an iterator over the subnodes of the flowchart node.\n    pub fn subnodes(\u0026self) -\u003e impl Iterator\u003cItem = \u0026FlowchartNode\u003e {\n        self.subnodes.iter().map(AsRef::as_ref)\n    }\n}\n\nimpl Node for FlowchartNode {\n    type Builder = FlowchartNodeBuilder;\n\n    fn label(\u0026self) -\u003e \u0026str {\n        self.node.label()\n    }\n\n    fn id(\u0026self) -\u003e u64 {\n        self.node.id()\n    }\n\n    fn styles(\u0026self) -\u003e impl Iterator\u003cItem = \u0026StyleProperty\u003e {\n        self.node.styles()\n    }\n\n    fn classes(\u0026self) -\u003e impl Iterator\u003cItem = \u0026StyleClass\u003e {\n        self.node.classes()\n    }\n\n    fn is_compatible_arrow_shape(shape: crate::shared::ArrowShape) -\u003e bool {\n        matches!(\n            shape,\n            crate::shared::ArrowShape::Normal\n                | crate::shared::ArrowShape::Circle\n                | crate::shared::ArrowShape::X\n        )\n    }\n}\n\nimpl Display for FlowchartNode {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        use crate::traits::TabbedDisplay;\n        self.fmt_tabbed(f, 0)\n    }\n}\n\nimpl crate::traits::TabbedDisplay for FlowchartNode {\n    fn fmt_tabbed(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e, tab_count: usize) -\u003e std::fmt::Result {\n        let indent = \" \".repeat(tab_count * 2);\n        if self.subnodes.is_empty() {\n            writeln!(\n                f,\n                \"{indent}{NODE_LETTER}{}@{{shape: {}, label: \\\"{}\\\"}}\",\n                self.id(),\n                self.shape,\n                self.label()\n            )?;\n\n            if let Some(click_event) = \u0026self.click_event {\n                writeln!(f, \"{indent}click {NODE_LETTER}{} {click_event}\", self.id(),)?;\n            }\n\n            for class in self.classes() {\n                writeln!(f, \"{indent}class {NODE_LETTER}{} {}\", self.id(), class.name())?;\n            }\n        } else {\n            writeln!(f, \"{indent}subgraph {NODE_LETTER}{} [\\\"`{}`\\\"]\", self.id(), self.label())?;\n            if let Some(direction) = \u0026self.direction {\n                writeln!(f, \"{indent}    direction {direction}\")?;\n            }\n\n            for node in \u0026self.subnodes {\n                node.fmt_tabbed(f, tab_count + 1)?;\n            }\n            writeln!(f, \"{indent}end\")?;\n        }\n        if self.has_styles() {\n            write!(f, \"{indent}style {NODE_LETTER}{} \", self.id())?;\n            for (style_number, style) in self.styles().enumerate() {\n                if style_number \u003e 0 {\n                    write!(f, \", \")?;\n                }\n                write!(f, \"{style} \")?;\n            }\n            writeln!(f)?;\n        }\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::{\n        shared::{\n            ClickEvent, StyleClassBuilder, StyleProperty, style_class::Color,\n            click_event::Navigation,\n        },\n        traits::NodeBuilder,\n    };\n\n    #[test]\n    fn test_flowchart_node_display_simple() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n        let node = FlowchartNodeBuilder::default()\n            .label(\"My Node\")?\n            .id(1)\n            .shape(FlowchartNodeShape::Circle)\n            .build()?;\n\n        let output = format!(\"{}\", node);\n        assert!(output.contains(\"v1@{shape: circle, label: \\\"My Node\\\"}\"));\n        Ok(())\n    }\n\n    #[test]\n    fn test_flowchart_node_display_full() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n        let style_class = Rc::new(\n            StyleClassBuilder::default()\n                .name(\"myClass\")?\n                .property(StyleProperty::Fill(Color::from((255, 0, 0))))?\n                .build()?,\n        );\n\n        let node = FlowchartNodeBuilder::default()\n            .label(\"My Node\")?\n            .id(1)\n            .shape(FlowchartNodeShape::Rectangle)\n            .style_class(style_class)?\n            .style_property(StyleProperty::Stroke(Color::from((0, 0, 255))))?\n            .click_event(ClickEvent::Navigation(\n                Navigation::new(\"https://example.com\")\n                    .anchor(true)\n                    .tooltip(\"Open link\"),\n            ))\n            .build()?;\n\n        let output = format!(\"{}\", node);\n        assert!(output.contains(\"v1@{shape: rect, label: \\\"My Node\\\"}\"));\n        assert!(output.contains(\"click v1 href \\\"https://example.com\\\" \\\"Open link\\\"\"));\n        assert!(output.contains(\"class v1 myClass\"));\n        assert!(output.contains(\"style v1 stroke: #0000ff\"));\n        Ok(())\n    }\n\n    #[test]\n    fn test_flowchart_node_subgraph() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n        let subnode = Rc::new(FlowchartNodeBuilder::default().label(\"Sub Node\")?.id(2).build()?);\n        \n        let node = FlowchartNodeBuilder::default()\n            .label(\"My Subgraph\")?\n            .id(1)\n            .subnode(subnode)?\n            .direction(Direction::LeftToRight)\n            .build()?;\n\n        let output = format!(\"{}\", node);\n        assert!(output.contains(\"subgraph v1 [\\\"`My Subgraph`\\\"]\"));\n        assert!(output.contains(\"direction LR\"));\n        assert!(output.contains(\"v2@{shape: rect, label: \\\"Sub Node\\\"}\"));\n        assert!(output.contains(\"end\"));\n        Ok(())\n    }\n}\n","traces":[{"line":54,"address":[762656],"length":1,"stats":{"Line":0}},{"line":55,"address":[762661],"length":1,"stats":{"Line":0}},{"line":62,"address":[769136],"length":1,"stats":{"Line":1}},{"line":63,"address":[769141],"length":1,"stats":{"Line":1}},{"line":66,"address":[769120],"length":1,"stats":{"Line":2}},{"line":67,"address":[769125],"length":1,"stats":{"Line":2}},{"line":70,"address":[769152],"length":1,"stats":{"Line":1}},{"line":71,"address":[769157],"length":1,"stats":{"Line":1}},{"line":74,"address":[769168],"length":1,"stats":{"Line":5}},{"line":75,"address":[769173],"length":1,"stats":{"Line":5}},{"line":78,"address":[769056],"length":1,"stats":{"Line":2}},{"line":79,"address":[769071],"length":1,"stats":{"Line":2}},{"line":80,"address":[769063],"length":1,"stats":{"Line":2}},{"line":89,"address":[762768],"length":1,"stats":{"Line":0}},{"line":91,"address":[762782],"length":1,"stats":{"Line":0}},{"line":96,"address":[767461,762864,767467],"length":1,"stats":{"Line":0}},{"line":97,"address":[762922,763002],"length":1,"stats":{"Line":0}},{"line":98,"address":[762984,763066],"length":1,"stats":{"Line":0}},{"line":99,"address":[764673,767447,764585],"length":1,"stats":{"Line":0}},{"line":102,"address":[763103,764577],"length":1,"stats":{"Line":0}},{"line":104,"address":[764602],"length":1,"stats":{"Line":0}},{"line":107,"address":[765102],"length":1,"stats":{"Line":0}},{"line":108,"address":[765231,765174],"length":1,"stats":{"Line":0}},{"line":111,"address":[765197,765655],"length":1,"stats":{"Line":0}},{"line":112,"address":[765816,767015],"length":1,"stats":{"Line":0}},{"line":115,"address":[763137,763080,764547],"length":1,"stats":{"Line":0}},{"line":116,"address":[763590],"length":1,"stats":{"Line":0}},{"line":117,"address":[763754,763657],"length":1,"stats":{"Line":0}},{"line":120,"address":[763708,763996],"length":1,"stats":{"Line":0}},{"line":121,"address":[764098,764369],"length":1,"stats":{"Line":0}},{"line":123,"address":[764347,764124],"length":1,"stats":{"Line":0}},{"line":125,"address":[765841,764323],"length":1,"stats":{"Line":0}},{"line":126,"address":[765882,766985],"length":1,"stats":{"Line":0}},{"line":127,"address":[766244],"length":1,"stats":{"Line":0}},{"line":128,"address":[766489],"length":1,"stats":{"Line":0}},{"line":129,"address":[766688,766964],"length":1,"stats":{"Line":0}},{"line":131,"address":[766805,766665],"length":1,"stats":{"Line":0}},{"line":133,"address":[766643,766504],"length":1,"stats":{"Line":0}},{"line":135,"address":[765847],"length":1,"stats":{"Line":0}}],"covered":11,"coverable":39},{"path":["/","home","lucac","github","mermaid-builder","src","diagrams","flowchart.rs"],"content":"//! Submodule providing structs for creating flowcharts in Mermaid syntax.\n\nmod builder;\nmod configuration;\nmod curve_styles;\nmod flowchart_edge;\nmod flowchart_node;\nuse std::fmt::Display;\n\npub use builder::FlowchartBuilder;\npub use configuration::{FlowchartConfiguration, FlowchartConfigurationBuilder};\npub use curve_styles::CurveStyle;\npub use flowchart_edge::{FlowchartEdge, FlowchartEdgeBuilder};\npub use flowchart_node::{FlowchartNode, FlowchartNodeBuilder, FlowchartNodeShape};\n\nuse crate::{\n    shared::generic_diagram::GenericDiagram,\n    traits::{Configuration, Diagram, Node, edge::Edge},\n};\n\n#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// Represents a flowchart diagram in Mermaid syntax.\n///\n/// # Example\n///\n/// ```\n/// use mermaid_builder::prelude::*;\n///\n/// let mut builder = FlowchartBuilder::default();\n/// let node = builder.node(FlowchartNodeBuilder::default().label(\"Node\").unwrap()).unwrap();\n/// let flowchart = Flowchart::from(builder);\n/// ```\npub struct Flowchart {\n    generic: GenericDiagram\u003cFlowchartNode, FlowchartEdge, FlowchartConfiguration\u003e,\n}\n\nimpl Diagram for Flowchart {\n    type Builder = FlowchartBuilder;\n    type Configuration = FlowchartConfiguration;\n    type Edge = FlowchartEdge;\n    type Node = FlowchartNode;\n\n    fn configuration(\u0026self) -\u003e \u0026Self::Configuration {\n        self.generic.configuration()\n    }\n\n    fn edges(\u0026self) -\u003e impl Iterator\u003cItem = \u0026Self::Edge\u003e {\n        self.generic.edges()\n    }\n\n    fn get_node_by_id(\u0026self, id: u64) -\u003e Option\u003cstd::rc::Rc\u003cSelf::Node\u003e\u003e {\n        self.generic.get_node_by_id(id)\n    }\n\n    fn get_style_class_by_name(\n        \u0026self,\n        name: \u0026str,\n    ) -\u003e Option\u003cstd::rc::Rc\u003ccrate::shared::StyleClass\u003e\u003e {\n        self.generic.get_style_class_by_name(name)\n    }\n\n    fn nodes(\u0026self) -\u003e impl Iterator\u003cItem = \u0026Self::Node\u003e {\n        self.generic.nodes()\n    }\n\n    fn style_classes(\u0026self) -\u003e impl Iterator\u003cItem = \u0026crate::shared::StyleClass\u003e {\n        self.generic.style_classes()\n    }\n}\n\nimpl Display for Flowchart {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        use crate::traits::TabbedDisplay;\n        self.fmt_tabbed(f, 0)\n    }\n}\n\nimpl crate::traits::TabbedDisplay for Flowchart {\n    fn fmt_tabbed(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e, tab_count: usize) -\u003e std::fmt::Result {\n        let indent = \" \".repeat(tab_count * 2);\n        write!(f, \"{}\", self.configuration())?;\n        writeln!(f, \"{indent}flowchart {}\", self.configuration().direction())?;\n        for style_class in self.style_classes() {\n            if !self.nodes().any(|n| n.classes().any(|sc| sc == style_class))\n                \u0026\u0026 !self.edges().any(|e| e.classes().any(|sc| sc == style_class))\n            {\n                continue;\n            }\n\n            style_class.fmt_tabbed(f, tab_count + 1)?;\n        }\n\n        let mut subgraph_nodes = Vec::new();\n        for node in self.nodes() {\n            if subgraph_nodes.contains(\u0026node) {\n                continue;\n            }\n            subgraph_nodes.extend(node.subnodes());\n        }\n        subgraph_nodes.sort_unstable();\n\n        for node in self.nodes() {\n            if subgraph_nodes.contains(\u0026node) {\n                continue;\n            }\n            node.fmt_tabbed(f, tab_count + 1)?;\n        }\n        for edge in self.edges() {\n            edge.fmt_tabbed(f, tab_count + 1)?;\n        }\n        Ok(())\n    }\n}\n","traces":[{"line":44,"address":[550160],"length":1,"stats":{"Line":0}},{"line":45,"address":[550165],"length":1,"stats":{"Line":0}},{"line":48,"address":[550256],"length":1,"stats":{"Line":0}},{"line":49,"address":[550261],"length":1,"stats":{"Line":0}},{"line":52,"address":[550192],"length":1,"stats":{"Line":0}},{"line":53,"address":[550206],"length":1,"stats":{"Line":0}},{"line":56,"address":[550224],"length":1,"stats":{"Line":0}},{"line":60,"address":[550242],"length":1,"stats":{"Line":0}},{"line":63,"address":[550272],"length":1,"stats":{"Line":0}},{"line":64,"address":[550277],"length":1,"stats":{"Line":0}},{"line":67,"address":[550176],"length":1,"stats":{"Line":0}},{"line":68,"address":[550181],"length":1,"stats":{"Line":0}},{"line":73,"address":[553392],"length":1,"stats":{"Line":0}},{"line":75,"address":[553406],"length":1,"stats":{"Line":0}},{"line":80,"address":[553025,550448,552659],"length":1,"stats":{"Line":0}},{"line":81,"address":[550583,550506],"length":1,"stats":{"Line":0}},{"line":82,"address":[550648,550568,553011],"length":1,"stats":{"Line":0}},{"line":83,"address":[552990,550862],"length":1,"stats":{"Line":0}},{"line":84,"address":[551174],"length":1,"stats":{"Line":0}},{"line":85,"address":[551362,552681],"length":1,"stats":{"Line":0}},{"line":86,"address":[552742,552796],"length":1,"stats":{"Line":0}},{"line":91,"address":[552865,552767],"length":1,"stats":{"Line":0}},{"line":94,"address":[551396],"length":1,"stats":{"Line":0}},{"line":95,"address":[551490,551411],"length":1,"stats":{"Line":0}},{"line":96,"address":[552579,551639],"length":1,"stats":{"Line":0}},{"line":99,"address":[552604],"length":1,"stats":{"Line":0}},{"line":101,"address":[551673],"length":1,"stats":{"Line":0}},{"line":103,"address":[551727],"length":1,"stats":{"Line":0}},{"line":104,"address":[551915,552355],"length":1,"stats":{"Line":0}},{"line":107,"address":[552388],"length":1,"stats":{"Line":0}},{"line":109,"address":[551949],"length":1,"stats":{"Line":0}},{"line":110,"address":[552118,552209],"length":1,"stats":{"Line":0}},{"line":112,"address":[552137],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":33},{"path":["/","home","lucac","github","mermaid-builder","src","diagrams.rs"],"content":"//! Submodule defining properties and structures shared across different types\n//! of Mermaid diagrams.\n\npub mod class_diagram;\npub mod entity_relationship;\npub mod flowchart;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","lucac","github","mermaid-builder","src","errors","config_error.rs"],"content":"//! Submodule providing an enumeration of possible errors that can occur in the\n//! configuration of diagrams in Mermaid syntax.\n\nuse thiserror::Error;\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Error)]\n#[cfg_attr(feature = \"serde\", derive(serde::Deserialize, serde::Serialize))]\n/// Enum representing errors related to configuration in Mermaid diagrams.\npub enum ConfigError {\n    /// The provided diagram title is empty.\n    #[error(\"Configuration title cannot be empty.\")]\n    EmptyTitle,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","lucac","github","mermaid-builder","src","errors","edge_error.rs"],"content":"//! Submodule providing an enumeration of possible errors that can occur in the\n//! edges of diagrams in Mermaid syntax.\n\nuse thiserror::Error;\n\nuse crate::shared::ArrowShape;\n\n#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Error)]\n#[cfg_attr(feature = \"serde\", derive(serde::Deserialize, serde::Serialize))]\n/// Enum representing errors related to edges in Mermaid diagrams.\npub enum EdgeError {\n    /// The provided edge label is empty.\n    #[error(\"Edge label cannot be empty.\")]\n    EmptyLabel,\n    /// The provided left arrow shape is not compatible with the diagram.\n    #[error(\"Incompatible left arrow shape: `{}`\", .0.left())]\n    IncompatibleLeftArrowShape(ArrowShape),\n    /// The provided right arrow shape is not compatible with the diagram.\n    #[error(\"Incompatible right arrow shape: `{}`\", .0.right())]\n    IncompatibleRightArrowShape(ArrowShape),\n    /// The provided source node does not exist in the diagram.\n    #[error(\"Source node not found: `{0}`\")]\n    SourceNodeNotFound(String),\n    /// The provided destination node does not exist in the diagram.\n    #[error(\"Destination node not found: `{0}`\")]\n    DestinationNodeNotFound(String),\n    /// The source node is missing.\n    #[error(\"Source node is missing.\")]\n    MissingSource,\n    /// The destination node is missing.\n    #[error(\"Destination node is missing.\")]\n    MissingDestination,\n    /// The edge ID is missing.\n    #[error(\"Edge ID is missing.\")]\n    MissingId,\n    /// The edge length is invalid (must be \u003e 0).\n    #[error(\"Edge length must be greater than 0.\")]\n    InvalidLength,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","lucac","github","mermaid-builder","src","errors","node_error.rs"],"content":"//! Submodule providing an enumeration of possible errors that can occur in the\n//! nodes of diagrams in Mermaid syntax.\n\nuse thiserror::Error;\n\n#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Error)]\n#[cfg_attr(feature = \"serde\", derive(serde::Deserialize, serde::Serialize))]\n/// Enum representing errors related to nodes in Mermaid diagrams.\npub enum NodeError {\n    /// The provided node label is empty.\n    #[error(\"Node label cannot be empty.\")]\n    EmptyLabel,\n    /// The provided node ID is empty.\n    #[error(\"Node ID cannot be empty.\")]\n    EmptyId,\n    /// The provided node ID contains invalid characters.\n    #[error(\"Node ID `{0}` contains invalid characters.\")]\n    InvalidId(String),\n    /// The provided node already exists in the diagram.\n    #[error(\"Node `{0}` already exists.\")]\n    DuplicateNode(String),\n    /// The node ID is missing.\n    #[error(\"Node ID is missing.\")]\n    MissingId,\n    /// The node label is missing.\n    #[error(\"Node label is missing.\")]\n    MissingLabel,\n    /// The subnodes are missing (required for subgraph with direction).\n    #[error(\"Subnodes are missing.\")]\n    MissingSubnodes,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","lucac","github","mermaid-builder","src","errors.rs"],"content":"//! Submodule defining the possible errors that can occur in the Mermaid\n//! library.\n\nuse thiserror::Error;\n\nmod config_error;\npub use config_error::ConfigError;\nmod edge_error;\npub use edge_error::EdgeError;\nmod node_error;\npub use node_error::NodeError;\n\npub use crate::shared::style_class::StyleClassError;\n\n#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Error)]\n#[cfg_attr(feature = \"serde\", derive(serde::Deserialize, serde::Serialize))]\n/// Enum representing the different types of errors that can occur in the\n/// Mermaid library.\npub enum Error {\n    /// An error regarding nodes.\n    #[error(\"Node error: {0}\")]\n    Node(#[from] NodeError),\n    /// An error regarding edges.\n    #[error(\"Edge error: {0}\")]\n    Edge(#[from] EdgeError),\n    /// An error regarding diagram configuration.\n    #[error(\"Configuration error: {0}\")]\n    Config(#[from] ConfigError),\n    /// An error regarding style classes.\n    #[error(\"Style class error: {0}\")]\n    StyleClass(#[from] StyleClassError),\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","lucac","github","mermaid-builder","src","lib.rs"],"content":"#![doc = include_str!(\"../README.md\")]\npub mod diagrams;\nmod errors;\nmod shared;\npub mod traits;\npub use errors::{ConfigError, EdgeError, NodeError, StyleClassError};\n\n/// Submodule providing common traits and types for Mermaid diagrams.\npub mod prelude {\n    pub use crate::{\n        diagrams::{class_diagram::*, entity_relationship::*, flowchart::*},\n        shared::{\n            ArrowShape, Color, Direction, FontWeight, LineStyle, Renderer, StyleClass,\n            StyleClassBuilder, StyleProperty, Unit,\n        },\n        traits::*,\n    };\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","lucac","github","mermaid-builder","src","nodes","shape.rs"],"content":"","traces":[],"covered":0,"coverable":0},{"path":["/","home","lucac","github","mermaid-builder","src","shared","arrow_shape.rs"],"content":"//! Submodule defining the possible arrow shapes for links in Mermaid diagrams.\n\n#[derive(Default, Copy, Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// Represents the shape of an arrow that can be used in Mermaid diagrams.\npub enum ArrowShape {\n    /// Arrow shape with a normal arrowhead.\n    #[default]\n    Normal,\n    /// A sharp arrowhead shape.\n    Sharp,\n    /// X shape arrowhead.\n    X,\n    /// Circle shape arrowhead.\n    Circle,\n    /// Triangle shape arrowhead.\n    Triangle,\n    /// Star shape arrowhead.\n    Star,\n    /// Shape representing zero or one dependency.\n    ZeroOrOne,\n    /// Shape representing exactly one dependency.\n    ExactlyOne,\n    /// Shape representing zero or more dependencies.\n    ZeroOrMore,\n    /// Shape representing one or more dependencies.\n    OneOrMore,\n}\n\nimpl ArrowShape {\n    #[must_use]\n    /// Returns the left-oriented arrow shape.\n    pub fn left(\u0026self) -\u003e \u0026str {\n        match self {\n            ArrowShape::Normal =\u003e \"\u003c\",\n            ArrowShape::Sharp =\u003e \"(\",\n            ArrowShape::X =\u003e \"x\",\n            ArrowShape::Circle =\u003e \"o\",\n            ArrowShape::Triangle =\u003e \"\u003c|\",\n            ArrowShape::Star =\u003e \"*\",\n            ArrowShape::ZeroOrOne =\u003e \"|o\",\n            ArrowShape::ExactlyOne =\u003e \"||\",\n            ArrowShape::ZeroOrMore =\u003e \"}o\",\n            ArrowShape::OneOrMore =\u003e \"}|\",\n        }\n    }\n\n    #[must_use]\n    /// Returns the right-oriented arrow shape.\n    pub fn right(\u0026self) -\u003e \u0026str {\n        match self {\n            ArrowShape::Normal =\u003e \"\u003e\",\n            ArrowShape::Sharp =\u003e \")\",\n            ArrowShape::X =\u003e \"x\",\n            ArrowShape::Circle =\u003e \"o\",\n            ArrowShape::Triangle =\u003e \"|\u003e\",\n            ArrowShape::Star =\u003e \"*\",\n            ArrowShape::ZeroOrOne =\u003e \"o|\",\n            ArrowShape::ExactlyOne =\u003e \"||\",\n            ArrowShape::ZeroOrMore =\u003e \"o{\",\n            ArrowShape::OneOrMore =\u003e \"|{\",\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_arrow_shape_left() {\n        assert_eq!(ArrowShape::Normal.left(), \"\u003c\");\n        assert_eq!(ArrowShape::Sharp.left(), \"(\");\n        assert_eq!(ArrowShape::X.left(), \"x\");\n        assert_eq!(ArrowShape::Circle.left(), \"o\");\n        assert_eq!(ArrowShape::Triangle.left(), \"\u003c|\");\n        assert_eq!(ArrowShape::Star.left(), \"*\");\n        assert_eq!(ArrowShape::ZeroOrOne.left(), \"|o\");\n        assert_eq!(ArrowShape::ExactlyOne.left(), \"||\");\n        assert_eq!(ArrowShape::ZeroOrMore.left(), \"}o\");\n        assert_eq!(ArrowShape::OneOrMore.left(), \"}|\");\n    }\n\n    #[test]\n    fn test_arrow_shape_right() {\n        assert_eq!(ArrowShape::Normal.right(), \"\u003e\");\n        assert_eq!(ArrowShape::Sharp.right(), \")\");\n        assert_eq!(ArrowShape::X.right(), \"x\");\n        assert_eq!(ArrowShape::Circle.right(), \"o\");\n        assert_eq!(ArrowShape::Triangle.right(), \"|\u003e\");\n        assert_eq!(ArrowShape::Star.right(), \"*\");\n        assert_eq!(ArrowShape::ZeroOrOne.right(), \"o|\");\n        assert_eq!(ArrowShape::ExactlyOne.right(), \"||\");\n        assert_eq!(ArrowShape::ZeroOrMore.right(), \"o{\");\n        assert_eq!(ArrowShape::OneOrMore.right(), \"|{\");\n    }\n}\n","traces":[{"line":33,"address":[529888],"length":1,"stats":{"Line":1}},{"line":34,"address":[529893],"length":1,"stats":{"Line":1}},{"line":35,"address":[529924],"length":1,"stats":{"Line":1}},{"line":36,"address":[529950],"length":1,"stats":{"Line":1}},{"line":37,"address":[529976],"length":1,"stats":{"Line":1}},{"line":38,"address":[530002],"length":1,"stats":{"Line":1}},{"line":39,"address":[530028],"length":1,"stats":{"Line":1}},{"line":40,"address":[530051],"length":1,"stats":{"Line":1}},{"line":41,"address":[530074],"length":1,"stats":{"Line":1}},{"line":42,"address":[530097],"length":1,"stats":{"Line":1}},{"line":43,"address":[530120],"length":1,"stats":{"Line":1}},{"line":44,"address":[530143],"length":1,"stats":{"Line":1}},{"line":50,"address":[530176],"length":1,"stats":{"Line":1}},{"line":51,"address":[530181],"length":1,"stats":{"Line":1}},{"line":52,"address":[530212],"length":1,"stats":{"Line":1}},{"line":53,"address":[530238],"length":1,"stats":{"Line":1}},{"line":54,"address":[530264],"length":1,"stats":{"Line":1}},{"line":55,"address":[530290],"length":1,"stats":{"Line":1}},{"line":56,"address":[530316],"length":1,"stats":{"Line":1}},{"line":57,"address":[530339],"length":1,"stats":{"Line":1}},{"line":58,"address":[530362],"length":1,"stats":{"Line":1}},{"line":59,"address":[530385],"length":1,"stats":{"Line":1}},{"line":60,"address":[530408],"length":1,"stats":{"Line":1}},{"line":61,"address":[530431],"length":1,"stats":{"Line":1}}],"covered":24,"coverable":24},{"path":["/","home","lucac","github","mermaid-builder","src","shared","click_event","js_function_call.rs"],"content":"//! Submodule handling click events in Mermaid nodes which lead to calling\n//! JavaScript functions, including the typing of the function signature\n//! and the function call itself.\n\nuse std::fmt::Display;\n\n#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// Represents a JavaScript function call that can be triggered by a click event\n/// on a Mermaid node.\npub struct JsFunctionCall {\n    /// The name of the JavaScript function to call.\n    function_name: String,\n    /// The arguments to pass to the JavaScript function.\n    args: Vec\u003cString\u003e,\n}\n\nimpl Display for JsFunctionCall {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        let args_str = if self.args.is_empty() {\n            String::new()\n        } else {\n            format!(\"({})\", self.args.join(\", \"))\n        };\n        write!(f, \"{}{}\", self.function_name, args_str)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_js_function_call_display() {\n        let call = JsFunctionCall { function_name: \"myFunc\".to_string(), args: vec![] };\n        assert_eq!(format!(\"{call}\"), \"myFunc\");\n\n        let call = JsFunctionCall {\n            function_name: \"myFunc\".to_string(),\n            args: vec![\"arg1\".to_string(), \"arg2\".to_string()],\n        };\n        assert_eq!(format!(\"{call}\"), \"myFunc(arg1, arg2)\");\n    }\n}\n","traces":[{"line":19,"address":[774667,774336,774661],"length":1,"stats":{"Line":1}},{"line":20,"address":[774369],"length":1,"stats":{"Line":1}},{"line":21,"address":[774459],"length":1,"stats":{"Line":1}},{"line":23,"address":[774474,774387],"length":1,"stats":{"Line":1}},{"line":25,"address":[774718,774621],"length":1,"stats":{"Line":2}}],"covered":5,"coverable":5},{"path":["/","home","lucac","github","mermaid-builder","src","shared","click_event","navigation.rs"],"content":"//! Submodule handling navigation click events in Mermaid diagrams, which\n//! can include anchor-like links or JavaScript function calls navigating to\n//! external resources or internal sections, with or without opening in a new\n//! tab.\n\nuse std::fmt::Display;\n\n/// Represents a navigation event triggered by a click on a node in a Mermaid\n/// diagram. This can include external links, with options for opening in a new\n/// tab and whether to use an anchor-like link or a JavaScript function for\n/// navigation.\n///\n/// # Example\n///\n/// Some example of mermaid syntax for a navigation event:\n///\n/// ```mermaid\n/// click A \"https://www.github.com\" _blank\n/// click B \"https://www.github.com\" \"Open this in a new tab\" _blank\n/// click C href \"https://www.github.com\" _blank\n/// click D href \"https://www.github.com\" \"Open this in a new tab\" _blank\n/// ```\n#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\npub struct Navigation {\n    /// The URL to navigate to when the node is clicked.\n    url: String,\n    /// Whether to open the link in a new tab.\n    new_tab: bool,\n    /// Whether to employ an anchor-like link or a JavaScript function for\n    /// navigation.\n    anchor: bool,\n    /// Descriptive tooltip for the navigation link.\n    tooltip: Option\u003cString\u003e,\n}\n\nimpl Navigation {\n    /// Creates a new navigation event.\n    pub fn new(url: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            url: url.into(),\n            new_tab: false,\n            anchor: false,\n            tooltip: None,\n        }\n    }\n\n    /// Sets whether to open the link in a new tab.\n    pub fn new_tab(mut self, new_tab: bool) -\u003e Self {\n        self.new_tab = new_tab;\n        self\n    }\n\n    /// Sets whether to employ an anchor-like link or a JavaScript function for\n    /// navigation.\n    pub fn anchor(mut self, anchor: bool) -\u003e Self {\n        self.anchor = anchor;\n        self\n    }\n\n    /// Sets the tooltip for the navigation link.\n    pub fn tooltip(mut self, tooltip: impl Into\u003cString\u003e) -\u003e Self {\n        self.tooltip = Some(tooltip.into());\n        self\n    }\n}\n\nimpl Display for Navigation {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        // We omit the `click {node_name}` part as it is not relevant for the\n        // display of the navigation event, and is handled by the parent\n        // `ClickEvent` enum.\n        if self.anchor {\n            write!(f, \"href\")?;\n        }\n        write!(f, \" \\\"{}\\\"\", self.url)?;\n\n        if let Some(tooltip) = \u0026self.tooltip {\n            write!(f, \" \\\"{tooltip}\\\"\")?;\n        }\n\n        if self.new_tab {\n            write!(f, \" _blank\")?;\n        }\n\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_navigation_display() {\n        let nav = Navigation {\n            url: \"https://example.com\".to_string(),\n            new_tab: false,\n            anchor: false,\n            tooltip: None,\n        };\n        assert_eq!(format!(\"{nav}\"), \" \\\"https://example.com\\\"\");\n\n        let nav = Navigation {\n            url: \"https://example.com\".to_string(),\n            new_tab: true,\n            anchor: false,\n            tooltip: None,\n        };\n        assert_eq!(format!(\"{nav}\"), \" \\\"https://example.com\\\" _blank\");\n\n        let nav = Navigation {\n            url: \"https://example.com\".to_string(),\n            new_tab: false,\n            anchor: true,\n            tooltip: None,\n        };\n        assert_eq!(format!(\"{nav}\"), \"href \\\"https://example.com\\\"\");\n\n        let nav = Navigation {\n            url: \"https://example.com\".to_string(),\n            new_tab: true,\n            anchor: true,\n            tooltip: Some(\"Tooltip\".to_string()),\n        };\n        assert_eq!(format!(\"{nav}\"), \"href \\\"https://example.com\\\" \\\"Tooltip\\\" _blank\");\n    }\n}\n","traces":[{"line":39,"address":[588400],"length":1,"stats":{"Line":1}},{"line":41,"address":[588424],"length":1,"stats":{"Line":1}},{"line":49,"address":[371008],"length":1,"stats":{"Line":0}},{"line":50,"address":[371031],"length":1,"stats":{"Line":0}},{"line":51,"address":[371036],"length":1,"stats":{"Line":0}},{"line":56,"address":[370960],"length":1,"stats":{"Line":0}},{"line":57,"address":[370983],"length":1,"stats":{"Line":0}},{"line":58,"address":[370988],"length":1,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[372272],"length":1,"stats":{"Line":1}},{"line":73,"address":[372299],"length":1,"stats":{"Line":1}},{"line":74,"address":[372406],"length":1,"stats":{"Line":1}},{"line":76,"address":[372310,372487],"length":1,"stats":{"Line":1}},{"line":78,"address":[372515],"length":1,"stats":{"Line":1}},{"line":79,"address":[372686,372570],"length":1,"stats":{"Line":1}},{"line":82,"address":[372678],"length":1,"stats":{"Line":1}},{"line":83,"address":[372725],"length":1,"stats":{"Line":1}},{"line":86,"address":[372718],"length":1,"stats":{"Line":1}}],"covered":11,"coverable":20},{"path":["/","home","lucac","github","mermaid-builder","src","shared","click_event.rs"],"content":"//! Enumeration of events associated with a click action on a node in a Mermaid\n//! diagram.\n\nmod navigation;\nuse std::fmt::Display;\n\npub use navigation::Navigation;\nmod js_function_call;\npub use js_function_call::JsFunctionCall;\n\n#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\npub enum ClickEvent {\n    /// Represents a click event that triggers a navigation event,\n    /// which can be a external link with or without opening in a new tab,\n    /// and that can either be triggered via a real anchor link or a JavaScript\n    /// function.\n    Navigation(Navigation),\n    /// Represents a click event that triggers a JavaScript function call.\n    JsFunctionCall(JsFunctionCall),\n}\n\nimpl Display for ClickEvent {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            ClickEvent::Navigation(nav) =\u003e write!(f, \"{nav}\",),\n            ClickEvent::JsFunctionCall(js_call) =\u003e write!(f, \"{js_call}\",),\n        }\n    }\n}\n","traces":[{"line":24,"address":[215264],"length":1,"stats":{"Line":0}},{"line":25,"address":[215290],"length":1,"stats":{"Line":0}},{"line":26,"address":[215426],"length":1,"stats":{"Line":0}},{"line":27,"address":[215326],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":4},{"path":["/","home","lucac","github","mermaid-builder","src","shared","constants.rs"],"content":"//! Constants used across the mermaid crate.\n\npub(crate) const NODE_LETTER: \u0026str = \"v\";\npub(crate) const EDGE_LETTER: \u0026str = \"e\";\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","lucac","github","mermaid-builder","src","shared","generic_configuration","direction.rs"],"content":"//! Submodule defining whether a flowchart is meant to extend in a horizontal or\n//! vertical direction.\n\nuse std::fmt::Display;\n\n#[derive(Default, Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// Represents the direction of a flowchart in Mermaid diagrams.\npub enum Direction {\n    /// The flowchart extends horizontally.\n    #[default]\n    LeftToRight,\n    /// The flowchart extends vertically.\n    TopToBottom,\n    /// The flowchart extends in a right-to-left direction.\n    RightToLeft,\n    /// The flowchart extends in a bottom-to-top direction.\n    BottomToTop,\n}\n\nimpl Direction {\n    #[must_use]\n    /// Changes the orientation from vertical to horizontal or vice versa.\n    pub fn flip(self) -\u003e Self {\n        match self {\n            Self::LeftToRight =\u003e Self::TopToBottom,\n            Self::TopToBottom =\u003e Self::LeftToRight,\n            Self::RightToLeft =\u003e Self::BottomToTop,\n            Self::BottomToTop =\u003e Self::RightToLeft,\n        }\n    }\n}\n\nimpl Display for Direction {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(\n            f,\n            \"{}\",\n            match self {\n                Self::LeftToRight =\u003e \"LR\",\n                Self::TopToBottom =\u003e \"TB\",\n                Self::RightToLeft =\u003e \"RL\",\n                Self::BottomToTop =\u003e \"BT\",\n            }\n        )\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_direction_display() {\n        assert_eq!(format!(\"{}\", Direction::LeftToRight), \"LR\");\n        assert_eq!(format!(\"{}\", Direction::TopToBottom), \"TB\");\n        assert_eq!(format!(\"{}\", Direction::RightToLeft), \"RL\");\n        assert_eq!(format!(\"{}\", Direction::BottomToTop), \"BT\");\n    }\n\n    #[test]\n    fn test_direction_flip() {\n        assert_eq!(Direction::LeftToRight.flip(), Direction::TopToBottom);\n        assert_eq!(Direction::TopToBottom.flip(), Direction::LeftToRight);\n        assert_eq!(Direction::RightToLeft.flip(), Direction::BottomToTop);\n        assert_eq!(Direction::BottomToTop.flip(), Direction::RightToLeft);\n    }\n}\n","traces":[{"line":24,"address":[749920],"length":1,"stats":{"Line":1}},{"line":25,"address":[749927],"length":1,"stats":{"Line":1}},{"line":26,"address":[749958],"length":1,"stats":{"Line":1}},{"line":27,"address":[749965],"length":1,"stats":{"Line":1}},{"line":28,"address":[749972],"length":1,"stats":{"Line":1}},{"line":29,"address":[749979],"length":1,"stats":{"Line":1}},{"line":35,"address":[750528],"length":1,"stats":{"Line":1}},{"line":36,"address":[750667],"length":1,"stats":{"Line":1}},{"line":39,"address":[750546],"length":1,"stats":{"Line":1}},{"line":40,"address":[750577],"length":1,"stats":{"Line":1}},{"line":41,"address":[750600],"length":1,"stats":{"Line":1}},{"line":42,"address":[750623],"length":1,"stats":{"Line":1}},{"line":43,"address":[750646],"length":1,"stats":{"Line":1}}],"covered":13,"coverable":13},{"path":["/","home","lucac","github","mermaid-builder","src","shared","generic_configuration","look.rs"],"content":"//! The looks enumeration to use for rendering a Mermaid diagram.\n\nuse std::fmt::Display;\n\n#[derive(Default, Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// The looks enumeration to use for rendering a Mermaid diagram.\npub enum Look {\n    /// The Neo look, a modern style for diagrams.\n    Neo,\n    /// The hand-drawn look, a sketch-like style for diagrams.\n    HandDrawn,\n    #[default]\n    /// The Classic look, the traditional Mermaid style.\n    Classic,\n}\n\nimpl Display for Look {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(\n            f,\n            \"{}\",\n            match self {\n                Look::Neo =\u003e \"neo\",\n                Look::HandDrawn =\u003e \"handDrawn\",\n                Look::Classic =\u003e \"classic\",\n            }\n        )\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_look_display() {\n        assert_eq!(format!(\"{}\", Look::Neo), \"neo\");\n        assert_eq!(format!(\"{}\", Look::HandDrawn), \"handDrawn\");\n        assert_eq!(format!(\"{}\", Look::Classic), \"classic\");\n    }\n}\n","traces":[{"line":19,"address":[549440],"length":1,"stats":{"Line":1}},{"line":20,"address":[549557],"length":1,"stats":{"Line":1}},{"line":23,"address":[549458],"length":1,"stats":{"Line":1}},{"line":24,"address":[549490],"length":1,"stats":{"Line":1}},{"line":25,"address":[549513],"length":1,"stats":{"Line":1}},{"line":26,"address":[549536],"length":1,"stats":{"Line":2}}],"covered":6,"coverable":6},{"path":["/","home","lucac","github","mermaid-builder","src","shared","generic_configuration","renderers.rs"],"content":"//! Submodule defining the possible renderers which may be used in a flowchart\n//! configuration in Mermaid.\n\nuse std::fmt::Display;\n\n#[derive(Default, Copy, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// Represents the renderer used for Mermaid diagrams.\npub enum Renderer {\n    /// The dagre renderer, which is the default renderer for flowcharts.\n    #[default]\n    Dagre,\n    /// The newer Eclipse Layout Kernel (ELK) renderer, which is an alternative\n    /// to the dagre renderer.\n    EclipseLayoutKernel,\n}\n\nimpl Display for Renderer {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Renderer::Dagre =\u003e write!(f, \"dagre\"),\n            Renderer::EclipseLayoutKernel =\u003e write!(f, \"elk\"),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_renderer_display() {\n        assert_eq!(format!(\"{}\", Renderer::Dagre), \"dagre\");\n        assert_eq!(format!(\"{}\", Renderer::EclipseLayoutKernel), \"elk\");\n    }\n}\n","traces":[{"line":19,"address":[802064],"length":1,"stats":{"Line":1}},{"line":20,"address":[802083],"length":1,"stats":{"Line":1}},{"line":21,"address":[802136],"length":1,"stats":{"Line":1}},{"line":22,"address":[802098],"length":1,"stats":{"Line":1}}],"covered":4,"coverable":4},{"path":["/","home","lucac","github","mermaid-builder","src","shared","generic_configuration","theme.rs"],"content":"//! The themes enumeration to use for rendering a Mermaid diagram.\n\nuse std::fmt::Display;\n\n#[derive(Default, Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// The themes enumeration to use for rendering a Mermaid diagram.\npub enum Theme {\n    /// The classic Mermaid chart theme.\n    MermaidChart,\n    /// The `Neo` theme, a modern style for diagrams.\n    Neo,\n    /// The `NeoDark` theme, a dark variant of Neo.\n    NeoDark,\n    /// The default theme for Mermaid diagrams.\n    #[default]\n    Default,\n    /// The `Forest` theme, with green accents and natural tones.\n    Forest,\n    /// The `Base` theme, a minimal and clean style.\n    Base,\n    /// The `Dark` theme, for diagrams with a dark background.\n    Dark,\n    /// The `Neutral` theme, with muted and balanced colors.\n    Neutral,\n    /// The `Redux` theme, a vibrant and bold style.\n    Redux,\n    /// The `ReduxDark` theme, a dark variant of Redux.\n    ReduxDark,\n}\n\nimpl Display for Theme {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(\n            f,\n            \"{}\",\n            match self {\n                Theme::MermaidChart =\u003e \"mc\",\n                Theme::Neo =\u003e \"neo\",\n                Theme::NeoDark =\u003e \"neo-dark\",\n                Theme::Default =\u003e \"default\",\n                Theme::Forest =\u003e \"forest\",\n                Theme::Base =\u003e \"base\",\n                Theme::Dark =\u003e \"dark\",\n                Theme::Neutral =\u003e \"neutral\",\n                Theme::Redux =\u003e \"redux\",\n                Theme::ReduxDark =\u003e \"redux-dark\",\n            }\n        )\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_theme_display() {\n        assert_eq!(format!(\"{}\", Theme::MermaidChart), \"mc\");\n        assert_eq!(format!(\"{}\", Theme::Neo), \"neo\");\n        assert_eq!(format!(\"{}\", Theme::NeoDark), \"neo-dark\");\n        assert_eq!(format!(\"{}\", Theme::Default), \"default\");\n        assert_eq!(format!(\"{}\", Theme::Forest), \"forest\");\n        assert_eq!(format!(\"{}\", Theme::Base), \"base\");\n        assert_eq!(format!(\"{}\", Theme::Dark), \"dark\");\n        assert_eq!(format!(\"{}\", Theme::Neutral), \"neutral\");\n        assert_eq!(format!(\"{}\", Theme::Redux), \"redux\");\n        assert_eq!(format!(\"{}\", Theme::ReduxDark), \"redux-dark\");\n    }\n}\n","traces":[{"line":33,"address":[680320],"length":1,"stats":{"Line":1}},{"line":34,"address":[680609],"length":1,"stats":{"Line":1}},{"line":37,"address":[680338],"length":1,"stats":{"Line":1}},{"line":38,"address":[680369],"length":1,"stats":{"Line":1}},{"line":39,"address":[680395],"length":1,"stats":{"Line":1}},{"line":40,"address":[680421],"length":1,"stats":{"Line":1}},{"line":41,"address":[680447],"length":1,"stats":{"Line":1}},{"line":42,"address":[680473],"length":1,"stats":{"Line":1}},{"line":43,"address":[680496],"length":1,"stats":{"Line":1}},{"line":44,"address":[680519],"length":1,"stats":{"Line":1}},{"line":45,"address":[680542],"length":1,"stats":{"Line":1}},{"line":46,"address":[680565],"length":1,"stats":{"Line":1}},{"line":47,"address":[680588],"length":1,"stats":{"Line":1}}],"covered":13,"coverable":13},{"path":["/","home","lucac","github","mermaid-builder","src","shared","generic_configuration.rs"],"content":"//! Submodule defining the configuration options which are applied at the top\n//! level of a Mermaid diagram.\n\nmod renderers;\nuse std::fmt::Display;\n\npub use renderers::Renderer;\nmod direction;\npub use direction::Direction;\nmod theme;\npub use theme::Theme;\nmod look;\npub use look::Look;\n\nuse crate::{\n    errors::ConfigError,\n    traits::{Configuration, ConfigurationBuilder},\n};\n\n#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// Represents the configuration options for a Mermaid diagram.\npub struct GenericConfiguration {\n    /// The title of the diagram.\n    title: Option\u003cString\u003e,\n    /// The renderer to use for the diagram.\n    renderer: Renderer,\n    /// The direction of the flowchart.\n    direction: Direction,\n    /// The theme to use for the diagram.\n    theme: Theme,\n    /// The look to use for the diagram.\n    look: Look,\n}\n\nimpl Configuration for GenericConfiguration {\n    type Builder = GenericConfigurationBuilder;\n\n    fn title(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n        self.title.as_deref()\n    }\n\n    fn renderer(\u0026self) -\u003e Renderer {\n        self.renderer\n    }\n\n    fn direction(\u0026self) -\u003e Direction {\n        self.direction\n    }\n\n    fn theme(\u0026self) -\u003e Theme {\n        self.theme\n    }\n\n    fn look(\u0026self) -\u003e Look {\n        self.look\n    }\n}\n\nimpl Display for GenericConfiguration {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        writeln!(f, \"---\")?;\n        writeln!(f, \"config:\")?;\n        writeln!(f, \"  layout: {}\", self.renderer)?;\n        writeln!(f, \"  theme: {}\", self.theme)?;\n        writeln!(f, \"  look: {}\", self.look)?;\n        if let Some(title) = \u0026self.title {\n            writeln!(f, \"title: {title}\")?;\n        }\n        writeln!(f, \"---\")?;\n\n        Ok(())\n    }\n}\n\n#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// Builder for creating a `GenericConfiguration`.\npub struct GenericConfigurationBuilder {\n    /// The title of the diagram.\n    title: Option\u003cString\u003e,\n    /// The renderer to use for the diagram.\n    renderer: Renderer,\n    /// The direction of the flowchart.\n    direction: Direction,\n    /// The theme to use for the diagram.\n    theme: Theme,\n    /// The look to use for the diagram.\n    look: Look,\n}\n\nimpl TryFrom\u003cGenericConfigurationBuilder\u003e for GenericConfiguration {\n    type Error = ConfigError;\n\n    fn try_from(builder: GenericConfigurationBuilder) -\u003e Result\u003cSelf, Self::Error\u003e {\n        Ok(GenericConfiguration {\n            title: builder.title,\n            renderer: builder.renderer,\n            direction: builder.direction,\n            theme: builder.theme,\n            look: builder.look,\n        })\n    }\n}\n\nimpl ConfigurationBuilder for GenericConfigurationBuilder {\n    type Configuration = GenericConfiguration;\n    type Error = ConfigError;\n\n    fn build(self) -\u003e Result\u003cSelf::Configuration, Self::Error\u003e {\n        self.try_into()\n    }\n\n    fn title\u003cS: ToString\u003e(mut self, title: S) -\u003e Result\u003cSelf, Self::Error\u003e {\n        let title = title.to_string();\n        if title.is_empty() {\n            return Err(ConfigError::EmptyTitle);\n        }\n        self.title = Some(title);\n        Ok(self)\n    }\n\n    fn renderer(mut self, renderer: Renderer) -\u003e Self {\n        self.renderer = renderer;\n        self\n    }\n\n    fn direction(mut self, direction: Direction) -\u003e Self {\n        self.direction = direction;\n        self\n    }\n}\n\nimpl GenericConfigurationBuilder {\n    /// Sets the theme to use for the diagram.\n    #[must_use]\n    pub fn theme(mut self, theme: Theme) -\u003e Self {\n        self.theme = theme;\n        self\n    }\n\n    /// Sets the look to use for the diagram.\n    #[must_use]\n    pub fn look(mut self, look: Look) -\u003e Self {\n        self.look = look;\n        self\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_generic_configuration_display() {\n        let config = GenericConfiguration::default();\n        assert_eq!(\n            format!(\"{config}\"),\n            \"---\\nconfig:\\n  layout: dagre\\n  theme: default\\n  look: classic\\n---\\n\"\n        );\n    }\n\n    #[test]\n    fn test_generic_configuration_builder() -\u003e Result\u003c(), ConfigError\u003e {\n        let config = GenericConfigurationBuilder::default()\n            .title(\"My Diagram\")?\n            .renderer(Renderer::EclipseLayoutKernel)\n            .direction(Direction::TopToBottom)\n            .theme(Theme::Forest)\n            .look(Look::HandDrawn)\n            .build()?;\n\n        assert_eq!(config.title(), Some(\"My Diagram\"));\n        assert_eq!(config.renderer(), Renderer::EclipseLayoutKernel);\n        assert_eq!(config.direction(), Direction::TopToBottom);\n        assert_eq!(config.theme(), Theme::Forest);\n        assert_eq!(config.look(), Look::HandDrawn);\n        Ok(())\n    }\n\n    #[test]\n    fn test_generic_configuration_builder_errors() {\n        let builder = GenericConfigurationBuilder::default();\n        assert!(matches!(builder.title(\"\"), Err(ConfigError::EmptyTitle)));\n    }\n}\n","traces":[{"line":39,"address":[783568],"length":1,"stats":{"Line":1}},{"line":40,"address":[783573],"length":1,"stats":{"Line":1}},{"line":43,"address":[783584],"length":1,"stats":{"Line":1}},{"line":44,"address":[783589],"length":1,"stats":{"Line":1}},{"line":47,"address":[783600],"length":1,"stats":{"Line":1}},{"line":48,"address":[783605],"length":1,"stats":{"Line":1}},{"line":51,"address":[783552],"length":1,"stats":{"Line":1}},{"line":52,"address":[783557],"length":1,"stats":{"Line":1}},{"line":55,"address":[783536],"length":1,"stats":{"Line":1}},{"line":56,"address":[783541],"length":1,"stats":{"Line":1}},{"line":61,"address":[785248],"length":1,"stats":{"Line":1}},{"line":62,"address":[785281],"length":1,"stats":{"Line":1}},{"line":63,"address":[785358],"length":1,"stats":{"Line":1}},{"line":64,"address":[785440],"length":1,"stats":{"Line":1}},{"line":65,"address":[785564],"length":1,"stats":{"Line":1}},{"line":66,"address":[785689],"length":1,"stats":{"Line":1}},{"line":67,"address":[785813],"length":1,"stats":{"Line":1}},{"line":68,"address":[785862,786044],"length":1,"stats":{"Line":0}},{"line":70,"address":[786076,785988],"length":1,"stats":{"Line":1}},{"line":72,"address":[786096],"length":1,"stats":{"Line":1}},{"line":95,"address":[783744],"length":1,"stats":{"Line":1}},{"line":96,"address":[783790],"length":1,"stats":{"Line":4}},{"line":97,"address":[783750],"length":1,"stats":{"Line":1}},{"line":98,"address":[783776],"length":1,"stats":{"Line":1}},{"line":99,"address":[783780],"length":1,"stats":{"Line":1}},{"line":100,"address":[783784],"length":1,"stats":{"Line":1}},{"line":101,"address":[783787],"length":1,"stats":{"Line":4}},{"line":110,"address":[784016],"length":1,"stats":{"Line":1}},{"line":111,"address":[784027],"length":1,"stats":{"Line":1}},{"line":114,"address":[590256,590819,590803],"length":1,"stats":{"Line":2}},{"line":115,"address":[590356,590288],"length":1,"stats":{"Line":9}},{"line":116,"address":[590369,590422],"length":1,"stats":{"Line":14}},{"line":117,"address":[590509],"length":1,"stats":{"Line":1}},{"line":119,"address":[590433,590536],"length":1,"stats":{"Line":1}},{"line":120,"address":[590641],"length":1,"stats":{"Line":6}},{"line":123,"address":[784096],"length":1,"stats":{"Line":1}},{"line":124,"address":[784110],"length":1,"stats":{"Line":1}},{"line":125,"address":[784116],"length":1,"stats":{"Line":1}},{"line":128,"address":[784160],"length":1,"stats":{"Line":1}},{"line":129,"address":[784169],"length":1,"stats":{"Line":1}},{"line":130,"address":[784172],"length":1,"stats":{"Line":1}},{"line":137,"address":[783488],"length":1,"stats":{"Line":1}},{"line":138,"address":[783497],"length":1,"stats":{"Line":1}},{"line":139,"address":[783500],"length":1,"stats":{"Line":1}},{"line":144,"address":[783440],"length":1,"stats":{"Line":1}},{"line":145,"address":[783449],"length":1,"stats":{"Line":1}},{"line":146,"address":[783452],"length":1,"stats":{"Line":1}}],"covered":46,"coverable":47},{"path":["/","home","lucac","github","mermaid-builder","src","shared","generic_diagram.rs"],"content":"//! Submodule defining a generic diagram struct which can be used as a base\n//! for various types of diagrams in Mermaid syntax.\n\nuse std::{fmt::Display, rc::Rc};\n\nuse crate::{\n    shared::{StyleClass, StyleClassError},\n    traits::{\n        Configuration, ConfigurationBuilder, Diagram, DiagramBuilder, Edge, EdgeBuilder, Node,\n        NodeBuilder,\n    },\n};\n\n#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// A generic diagram struct that can be extended for specific diagram types.\npub struct GenericDiagram\u003cNode, Edge, Config\u003e {\n    /// Style classes associated with this diagram.\n    style_classes: Vec\u003cRc\u003cStyleClass\u003e\u003e,\n    /// Nodes in the diagram.\n    nodes: Vec\u003cRc\u003cNode\u003e\u003e,\n    /// Edges in the diagram.\n    edges: Vec\u003cRc\u003cEdge\u003e\u003e,\n    /// Configuration options for the diagram.\n    configuration: Config,\n}\n\nimpl\u003cN: Node + Display, E: Edge\u003cNode = N\u003e + Display, C: Configuration\u003e Diagram\n    for GenericDiagram\u003cN, E, C\u003e\nwhere\n    crate::errors::Error: From\u003c\u003cN::Builder as NodeBuilder\u003e::Error\u003e\n        + From\u003c\u003cE::Builder as EdgeBuilder\u003e::Error\u003e\n        + From\u003c\u003cC::Builder as ConfigurationBuilder\u003e::Error\u003e,\n{\n    type Builder = GenericDiagramBuilder\u003cN, E, C\u003e;\n    type Node = N;\n    type Edge = E;\n    type Configuration = C;\n\n    fn configuration(\u0026self) -\u003e \u0026Self::Configuration {\n        \u0026self.configuration\n    }\n\n    fn nodes(\u0026self) -\u003e impl Iterator\u003cItem = \u0026Self::Node\u003e {\n        self.nodes.iter().map(AsRef::as_ref)\n    }\n\n    fn edges(\u0026self) -\u003e impl Iterator\u003cItem = \u0026Self::Edge\u003e {\n        self.edges.iter().map(AsRef::as_ref)\n    }\n\n    fn style_classes(\u0026self) -\u003e impl Iterator\u003cItem = \u0026StyleClass\u003e {\n        self.style_classes.iter().map(AsRef::as_ref)\n    }\n\n    fn get_node_by_id(\u0026self, id: u64) -\u003e Option\u003cRc\u003cSelf::Node\u003e\u003e {\n        self.nodes.iter().find(|node| node.id() == id).cloned()\n    }\n\n    fn get_style_class_by_name(\u0026self, name: \u0026str) -\u003e Option\u003cRc\u003cStyleClass\u003e\u003e {\n        self.style_classes.iter().find(|sc| sc.name() == name).cloned()\n    }\n}\n\n#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// A builder for creating a generic diagram.\npub struct GenericDiagramBuilder\u003cNode, Edge, Config\u003e {\n    /// Underlying generic diagram.\n    generic_diagram: GenericDiagram\u003cNode, Edge, Config\u003e,\n}\n\nimpl\u003cNode, Edge, Config: Default\u003e Default for GenericDiagramBuilder\u003cNode, Edge, Config\u003e {\n    fn default() -\u003e Self {\n        Self {\n            generic_diagram: GenericDiagram {\n                style_classes: Vec::new(),\n                nodes: Vec::new(),\n                edges: Vec::new(),\n                configuration: Config::default(),\n            },\n        }\n    }\n}\n\nimpl\u003cN: Node + Display, E: Edge\u003cNode = N\u003e + Display, C: Configuration\u003e\n    From\u003cGenericDiagramBuilder\u003cN, E, C\u003e\u003e for GenericDiagram\u003cN, E, C\u003e\n{\n    fn from(builder: GenericDiagramBuilder\u003cN, E, C\u003e) -\u003e Self {\n        builder.generic_diagram\n    }\n}\n\nimpl\u003cN: Node + Display, E: Edge\u003cNode = N\u003e + Display, C: Configuration\u003e DiagramBuilder\n    for GenericDiagramBuilder\u003cN, E, C\u003e\nwhere\n    crate::errors::Error: From\u003c\u003cN::Builder as NodeBuilder\u003e::Error\u003e\n        + From\u003c\u003cE::Builder as EdgeBuilder\u003e::Error\u003e\n        + From\u003c\u003cC::Builder as ConfigurationBuilder\u003e::Error\u003e,\n    GenericDiagram\u003cN, E, C\u003e: Diagram\u003cNode = N, Edge = E, Configuration = C, Builder = Self\u003e,\n{\n    type Diagram = GenericDiagram\u003cN, E, C\u003e;\n    type Node = N;\n    type NodeBuilder = N::Builder;\n    type Edge = E;\n    type EdgeBuilder = E::Builder;\n    type Configuration = C;\n    type ConfigurationBuilder = C::Builder;\n    type Error = crate::errors::Error;\n\n    fn configuration(\n        mut self,\n        configuration: Self::ConfigurationBuilder,\n    ) -\u003e Result\u003cSelf, Self::Error\u003e {\n        self.generic_diagram.configuration =\n            configuration.build().map_err(crate::errors::Error::from)?;\n        Ok(self)\n    }\n\n    fn edge(\u0026mut self, edge: Self::EdgeBuilder) -\u003e Result\u003cRc\u003cSelf::Edge\u003e, Self::Error\u003e {\n        let edge = edge.build().map_err(crate::errors::Error::from)?;\n\n        if !self.generic_diagram.nodes.contains(edge.source()) {\n            return Err(crate::errors::EdgeError::SourceNodeNotFound(\n                edge.source().label().to_owned(),\n            )\n            .into());\n        }\n\n        if !self.generic_diagram.nodes.contains(edge.destination()) {\n            return Err(crate::errors::EdgeError::DestinationNodeNotFound(\n                edge.destination().label().to_owned(),\n            )\n            .into());\n        }\n\n        let rc = Rc::new(edge);\n        self.generic_diagram.edges.push(rc.clone());\n        Ok(rc)\n    }\n\n    fn node(\u0026mut self, mut node: Self::NodeBuilder) -\u003e Result\u003cRc\u003cSelf::Node\u003e, Self::Error\u003e {\n        let number_of_nodes = self.generic_diagram.nodes.len();\n        {\n            use crate::traits::node_builder::NodeBuilder;\n            if node.get_id().is_none() {\n                node = node.id(number_of_nodes as u64);\n            }\n        }\n        let node = node.build().map_err(crate::errors::Error::from)?;\n\n        for class in node.classes() {\n            if !self.generic_diagram.style_classes.iter().any(|sc| sc.name() == class.name()) {\n                return Err(StyleClassError::UnknownClass(class.clone()).into());\n            }\n        }\n\n        let rc = Rc::new(node);\n        self.generic_diagram.nodes.push(rc.clone());\n        Ok(rc)\n    }\n\n    fn nodes(\u0026self) -\u003e impl Iterator\u003cItem = \u0026Rc\u003cSelf::Node\u003e\u003e + '_ {\n        self.generic_diagram.nodes.iter()\n    }\n\n    fn get_node_by_id(\u0026self, id: u64) -\u003e Option\u003cRc\u003cSelf::Node\u003e\u003e {\n        self.generic_diagram.get_node_by_id(id)\n    }\n\n    fn get_style_class_by_name(\u0026self, name: \u0026str) -\u003e Option\u003cRc\u003cStyleClass\u003e\u003e {\n        self.generic_diagram.get_style_class_by_name(name)\n    }\n\n    fn number_of_nodes(\u0026self) -\u003e usize {\n        self.generic_diagram.nodes.len()\n    }\n\n    fn number_of_edges(\u0026self) -\u003e usize {\n        self.generic_diagram.edges.len()\n    }\n\n    fn style_class(\n        \u0026mut self,\n        style_class: super::StyleClassBuilder,\n    ) -\u003e Result\u003cRc\u003cStyleClass\u003e, Self::Error\u003e {\n        let style_class = style_class.build().map_err(crate::errors::Error::from)?;\n\n        if self.generic_diagram.style_classes.iter().any(|sc| sc.name() == style_class.name()) {\n            return Err(StyleClassError::DuplicateClass(style_class.name().to_owned()).into());\n        }\n\n        let rc = Rc::new(style_class);\n        self.generic_diagram.style_classes.push(rc.clone());\n        Ok(rc)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::diagrams::flowchart::{\n        FlowchartConfiguration, FlowchartConfigurationBuilder, FlowchartEdge, FlowchartEdgeBuilder,\n        FlowchartNode, FlowchartNodeBuilder,\n    };\n    use crate::shared::{style_class::Unit, StyleClassBuilder, StyleProperty};\n    use crate::traits::{ConfigurationBuilder, EdgeBuilder, NodeBuilder};\n    use std::rc::Rc;\n\n    #[test]\n    fn test_generic_diagram_builder() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n        let mut builder = GenericDiagramBuilder::\u003c\n            FlowchartNode,\n            FlowchartEdge,\n            FlowchartConfiguration,\n        \u003e::default();\n\n        // Test Node\n        let node_builder = FlowchartNodeBuilder::default().label(\"Node 1\")?.id(1);\n        let node1 = builder.node(node_builder)?;\n        assert_eq!(node1.id(), 1);\n\n        let node_builder2 = FlowchartNodeBuilder::default().label(\"Node 2\")?.id(2);\n        let node2 = builder.node(node_builder2)?;\n        assert_eq!(node2.id(), 2);\n\n        // Test Edge\n        let edge_builder = FlowchartEdgeBuilder::default()\n            .source(node1.clone())?\n            .destination(node2.clone())?\n            .id(1);\n        let edge = builder.edge(edge_builder)?;\n        assert_eq!(edge.source().id(), 1);\n        assert_eq!(edge.destination().id(), 2);\n\n        // Test Config\n        let config_builder = FlowchartConfigurationBuilder::default().title(\"My Diagram\")?;\n        builder = builder.configuration(config_builder)?;\n\n        let diagram: GenericDiagram\u003cFlowchartNode, FlowchartEdge, FlowchartConfiguration\u003e =\n            builder.into();\n\n        assert_eq!(diagram.nodes().count(), 2);\n        assert_eq!(diagram.edges().count(), 1);\n        assert_eq!(diagram.configuration().title(), Some(\"My Diagram\"));\n\n        Ok(())\n    }\n\n    #[test]\n    fn test_generic_diagram_methods() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n        let mut builder = GenericDiagramBuilder::\u003c\n            FlowchartNode,\n            FlowchartEdge,\n            FlowchartConfiguration,\n        \u003e::default();\n\n        let node_builder = FlowchartNodeBuilder::default().label(\"Node 1\")?.id(1);\n        builder.node(node_builder)?;\n\n        // Test Builder methods\n        assert_eq!(builder.number_of_nodes(), 1);\n        assert_eq!(builder.number_of_edges(), 0);\n        assert!(builder.get_node_by_id(1).is_some());\n        assert!(builder.get_node_by_id(2).is_none());\n        assert_eq!(builder.nodes().count(), 1);\n\n        let diagram: GenericDiagram\u003cFlowchartNode, FlowchartEdge, FlowchartConfiguration\u003e =\n            builder.into();\n\n        assert_eq!(diagram.nodes().count(), 1);\n        assert_eq!(diagram.edges().count(), 0);\n        assert!(diagram.get_node_by_id(1).is_some());\n        assert!(diagram.get_node_by_id(2).is_none());\n\n        Ok(())\n    }\n\n    #[test]\n    fn test_style_class_management() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n        let mut builder = GenericDiagramBuilder::\u003c\n            FlowchartNode,\n            FlowchartEdge,\n            FlowchartConfiguration,\n        \u003e::default();\n\n        let style_class_builder = StyleClassBuilder::default()\n            .name(\"test_class\")?\n            .property(StyleProperty::StrokeWidth(Unit::Pixel(1)))?;\n        let style_class = builder.style_class(style_class_builder)?;\n\n        assert_eq!(style_class.name(), \"test_class\");\n\n        // Test Builder methods\n        assert!(builder.get_style_class_by_name(\"test_class\").is_some());\n        assert!(builder.get_style_class_by_name(\"unknown\").is_none());\n\n        // Test duplicate class\n        let style_class_builder_dup = StyleClassBuilder::default()\n            .name(\"test_class\")?\n            .property(StyleProperty::StrokeWidth(Unit::Pixel(1)))?;\n        let result = builder.style_class(style_class_builder_dup);\n        assert!(result.is_err());\n\n        let diagram: GenericDiagram\u003cFlowchartNode, FlowchartEdge, FlowchartConfiguration\u003e =\n            builder.into();\n        assert!(diagram.get_style_class_by_name(\"test_class\").is_some());\n        assert!(diagram.get_style_class_by_name(\"unknown\").is_none());\n        assert_eq!(diagram.style_classes().count(), 1);\n\n        Ok(())\n    }\n\n    #[test]\n    fn test_node_with_unknown_class() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n        let mut builder = GenericDiagramBuilder::\u003c\n            FlowchartNode,\n            FlowchartEdge,\n            FlowchartConfiguration,\n        \u003e::default();\n\n        let class = StyleClassBuilder::default()\n            .name(\"unknown\")?\n            .property(StyleProperty::StrokeWidth(Unit::Pixel(2)))?\n            .build()?;\n\n        let node_builder = FlowchartNodeBuilder::default()\n            .label(\"Node 1\")?\n            .id(1)\n            .style_class(Rc::new(class))?;\n\n        let result = builder.node(node_builder);\n        assert!(result.is_err());\n        Ok(())\n    }\n\n    #[test]\n    fn test_edge_with_unknown_nodes() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n        let mut builder = GenericDiagramBuilder::\u003c\n            FlowchartNode,\n            FlowchartEdge,\n            FlowchartConfiguration,\n        \u003e::default();\n\n        let node1 = Rc::new(\n            FlowchartNodeBuilder::default()\n                .label(\"Node 1\")?\n                .id(1)\n                .build()?,\n        );\n        let node2 = Rc::new(\n            FlowchartNodeBuilder::default()\n                .label(\"Node 2\")?\n                .id(2)\n                .build()?,\n        );\n\n        let edge_builder = FlowchartEdgeBuilder::default()\n            .source(node1)?\n            .destination(node2)?\n            .id(1);\n\n        let result = builder.edge(edge_builder);\n        assert!(result.is_err());\n        Ok(())\n    }\n\n    #[test]\n    fn test_edge_destination_node_not_found() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n        let mut builder = GenericDiagramBuilder::\u003c\n            FlowchartNode,\n            FlowchartEdge,\n            FlowchartConfiguration,\n        \u003e::default();\n\n        let node1_builder = FlowchartNodeBuilder::default().label(\"Node 1\")?.id(1);\n        let node1 = builder.node(node1_builder)?;\n\n        let node2 = Rc::new(\n            FlowchartNodeBuilder::default()\n                .label(\"Node 2\")?\n                .id(2)\n                .build()?,\n        );\n\n        let edge_builder = FlowchartEdgeBuilder::default()\n            .source(node1)?\n            .destination(node2)?\n            .id(1);\n\n        let result = builder.edge(edge_builder);\n        assert!(result.is_err());\n        Ok(())\n    }\n\n    #[test]\n    fn test_node_auto_id() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n        let mut builder = GenericDiagramBuilder::\u003c\n            FlowchartNode,\n            FlowchartEdge,\n            FlowchartConfiguration,\n        \u003e::default();\n\n        let node_builder = FlowchartNodeBuilder::default().label(\"Node 1\")?;\n        let node = builder.node(node_builder)?;\n        assert_eq!(node.id(), 0);\n        \n        let node_builder2 = FlowchartNodeBuilder::default().label(\"Node 2\")?;\n        let node2 = builder.node(node_builder2)?;\n        assert_eq!(node2.id(), 1);\n\n        Ok(())\n    }\n}\n","traces":[{"line":40,"address":[501664,501824,501504],"length":1,"stats":{"Line":1}},{"line":41,"address":[501672,501832,501512],"length":1,"stats":{"Line":1}},{"line":44,"address":[501616,501776,502096],"length":1,"stats":{"Line":1}},{"line":45,"address":[502101,501621,501781],"length":1,"stats":{"Line":1}},{"line":48,"address":[502048,501568,501728],"length":1,"stats":{"Line":1}},{"line":49,"address":[501573,501733,502053],"length":1,"stats":{"Line":1}},{"line":52,"address":[501840,501520,501680],"length":1,"stats":{"Line":1}},{"line":53,"address":[501845,501525,501685],"length":1,"stats":{"Line":1}},{"line":56,"address":[501888],"length":1,"stats":{"Line":1}},{"line":57,"address":[501902,501136,501154],"length":1,"stats":{"Line":5}},{"line":60,"address":[501968],"length":1,"stats":{"Line":1}},{"line":61,"address":[501200,501218,501986],"length":1,"stats":{"Line":3}},{"line":74,"address":[508176,508548,508542],"length":1,"stats":{"Line":8}},{"line":76,"address":[508365],"length":1,"stats":{"Line":8}},{"line":89,"address":[502144],"length":1,"stats":{"Line":1}},{"line":90,"address":[502152],"length":1,"stats":{"Line":1}},{"line":111,"address":[503120,503619],"length":1,"stats":{"Line":1}},{"line":115,"address":[503528,503460],"length":1,"stats":{"Line":2}},{"line":116,"address":[503242,503141,503497],"length":1,"stats":{"Line":2}},{"line":117,"address":[503554],"length":1,"stats":{"Line":1}},{"line":120,"address":[505263,503744,505257],"length":1,"stats":{"Line":3}},{"line":121,"address":[503802],"length":1,"stats":{"Line":3}},{"line":123,"address":[504257,504365],"length":1,"stats":{"Line":8}},{"line":124,"address":[504634,504556],"length":1,"stats":{"Line":2}},{"line":125,"address":[504439,504497],"length":1,"stats":{"Line":2}},{"line":127,"address":[504596],"length":1,"stats":{"Line":1}},{"line":130,"address":[504701,504462],"length":1,"stats":{"Line":6}},{"line":131,"address":[505057,504979],"length":1,"stats":{"Line":2}},{"line":132,"address":[504757,504920],"length":1,"stats":{"Line":2}},{"line":134,"address":[505019],"length":1,"stats":{"Line":1}},{"line":137,"address":[505106,504772],"length":1,"stats":{"Line":3}},{"line":138,"address":[505114,505193],"length":1,"stats":{"Line":4}},{"line":139,"address":[505208],"length":1,"stats":{"Line":2}},{"line":142,"address":[506808,505296,506539],"length":1,"stats":{"Line":1}},{"line":143,"address":[505354,505454],"length":1,"stats":{"Line":2}},{"line":146,"address":[505462,505732],"length":1,"stats":{"Line":2}},{"line":147,"address":[505629],"length":1,"stats":{"Line":1}},{"line":150,"address":[505753,505560,506806],"length":1,"stats":{"Line":8}},{"line":152,"address":[506053,506133,506225],"length":1,"stats":{"Line":15}},{"line":153,"address":[506555,501424,501392,506293],"length":1,"stats":{"Line":2}},{"line":154,"address":[506649],"length":1,"stats":{"Line":1}},{"line":158,"address":[506315],"length":1,"stats":{"Line":4}},{"line":159,"address":[506396,506475],"length":1,"stats":{"Line":8}},{"line":160,"address":[506490],"length":1,"stats":{"Line":4}},{"line":163,"address":[506848],"length":1,"stats":{"Line":1}},{"line":164,"address":[506853],"length":1,"stats":{"Line":1}},{"line":167,"address":[503648],"length":1,"stats":{"Line":1}},{"line":168,"address":[503662],"length":1,"stats":{"Line":1}},{"line":171,"address":[503712],"length":1,"stats":{"Line":1}},{"line":172,"address":[503730],"length":1,"stats":{"Line":1}},{"line":175,"address":[503696],"length":1,"stats":{"Line":1}},{"line":176,"address":[503701],"length":1,"stats":{"Line":1}},{"line":179,"address":[503680],"length":1,"stats":{"Line":1}},{"line":180,"address":[503685],"length":1,"stats":{"Line":1}},{"line":183,"address":[502930,502208,503087],"length":1,"stats":{"Line":1}},{"line":187,"address":[502251],"length":1,"stats":{"Line":1}},{"line":189,"address":[502546,502614,501280,501312],"length":1,"stats":{"Line":4}},{"line":190,"address":[502954,502769],"length":1,"stats":{"Line":2}},{"line":193,"address":[502691,502794],"length":1,"stats":{"Line":2}},{"line":194,"address":[502810,502872],"length":1,"stats":{"Line":2}},{"line":195,"address":[502884],"length":1,"stats":{"Line":1}}],"covered":61,"coverable":61},{"path":["/","home","lucac","github","mermaid-builder","src","shared","generic_edge.rs"],"content":"//! Submodule providing a generic node struct which may be reused across\n//! different diagrams.\n\nuse std::{iter::empty, rc::Rc};\n\nuse crate::{\n    errors::EdgeError,\n    shared::{ArrowShape, LineStyle, StyleClass},\n    traits::{Edge, EdgeBuilder, Node},\n};\n\n#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// Struct representing a generic node in Mermaid diagrams.\npub struct GenericEdge\u003cNode\u003e {\n    /// Label for the node.\n    label: Option\u003cString\u003e,\n    /// The source node of the edge.\n    source: Rc\u003cNode\u003e,\n    /// The destination node of the edge.\n    destination: Rc\u003cNode\u003e,\n    /// The line style of the link.\n    line_style: LineStyle,\n    /// The left arrow shape of the link, if any.\n    left_arrow_shape: Option\u003cArrowShape\u003e,\n    /// The right arrow shape of the link, if any.\n    right_arrow_shape: Option\u003cArrowShape\u003e,\n}\n\nimpl\u003cN: Node\u003e Edge for GenericEdge\u003cN\u003e {\n    type Builder = GenericEdgeBuilder\u003cN\u003e;\n    type Node = N;\n\n    fn label(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n        self.label.as_deref()\n    }\n\n    fn source(\u0026self) -\u003e \u0026Rc\u003cSelf::Node\u003e {\n        \u0026self.source\n    }\n\n    fn destination(\u0026self) -\u003e \u0026Rc\u003cSelf::Node\u003e {\n        \u0026self.destination\n    }\n\n    fn line_style(\u0026self) -\u003e LineStyle {\n        self.line_style\n    }\n\n    fn classes(\u0026self) -\u003e impl Iterator\u003cItem = \u0026StyleClass\u003e {\n        empty()\n    }\n\n    fn left_arrow_shape(\u0026self) -\u003e Option\u003cArrowShape\u003e {\n        self.left_arrow_shape\n    }\n\n    fn right_arrow_shape(\u0026self) -\u003e Option\u003cArrowShape\u003e {\n        self.right_arrow_shape\n    }\n}\n\n#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// Builder for creating a `GenericEdge`.\npub struct GenericEdgeBuilder\u003cNode\u003e {\n    /// Label for the edge.\n    label: Option\u003cString\u003e,\n    /// Source node for the edge.\n    source: Option\u003cRc\u003cNode\u003e\u003e,\n    /// Destination node for the edge.\n    destination: Option\u003cRc\u003cNode\u003e\u003e,\n    /// Line style of the edge.\n    line_style: LineStyle,\n    /// Left arrow shape of the edge, if any.\n    left_arrow_shape: Option\u003cArrowShape\u003e,\n    /// Right arrow shape of the edge, if any.\n    right_arrow_shape: Option\u003cArrowShape\u003e,\n}\n\nimpl\u003cNode\u003e Default for GenericEdgeBuilder\u003cNode\u003e {\n    fn default() -\u003e Self {\n        Self {\n            label: None,\n            source: None,\n            destination: None,\n            line_style: LineStyle::default(),\n            left_arrow_shape: None,\n            right_arrow_shape: None,\n        }\n    }\n}\n\nimpl\u003cN\u003e TryFrom\u003cGenericEdgeBuilder\u003cN\u003e\u003e for GenericEdge\u003cN\u003e {\n    type Error = EdgeError;\n\n    fn try_from(builder: GenericEdgeBuilder\u003cN\u003e) -\u003e Result\u003cSelf, Self::Error\u003e {\n        Ok(GenericEdge {\n            label: builder.label,\n            source: builder.source.ok_or(EdgeError::MissingSource)?,\n            destination: builder.destination.ok_or(EdgeError::MissingDestination)?,\n            line_style: builder.line_style,\n            left_arrow_shape: builder.left_arrow_shape,\n            right_arrow_shape: builder.right_arrow_shape,\n        })\n    }\n}\n\nimpl\u003cN: Node\u003e EdgeBuilder for GenericEdgeBuilder\u003cN\u003e {\n    type Node = N;\n    type Edge = GenericEdge\u003cN\u003e;\n    type Error = EdgeError;\n\n    fn build(self) -\u003e Result\u003cSelf::Edge, Self::Error\u003e {\n        self.try_into()\n    }\n\n    fn label\u003cS: ToString\u003e(mut self, label: S) -\u003e Result\u003cSelf, Self::Error\u003e {\n        let label = label.to_string();\n        if label.is_empty() {\n            return Err(EdgeError::EmptyLabel);\n        }\n        self.label = Some(label);\n        Ok(self)\n    }\n\n    fn source(mut self, source: Rc\u003cSelf::Node\u003e) -\u003e Result\u003cSelf, Self::Error\u003e {\n        self.source = Some(source);\n        Ok(self)\n    }\n\n    fn destination(mut self, destination: Rc\u003cSelf::Node\u003e) -\u003e Result\u003cSelf, Self::Error\u003e {\n        self.destination = Some(destination);\n        Ok(self)\n    }\n\n    fn line_style(mut self, style: LineStyle) -\u003e Self {\n        self.line_style = style;\n        self\n    }\n    fn left_arrow_shape(mut self, shape: ArrowShape) -\u003e Result\u003cSelf, Self::Error\u003e {\n        if !Self::Node::is_compatible_arrow_shape(shape) {\n            return Err(EdgeError::IncompatibleLeftArrowShape(shape));\n        }\n        self.left_arrow_shape = Some(shape);\n        Ok(self)\n    }\n    fn right_arrow_shape(mut self, shape: ArrowShape) -\u003e Result\u003cSelf, Self::Error\u003e {\n        if !Self::Node::is_compatible_arrow_shape(shape) {\n            return Err(EdgeError::IncompatibleRightArrowShape(shape));\n        }\n        self.right_arrow_shape = Some(shape);\n        Ok(self)\n    }\n}\n","traces":[{"line":34,"address":[221248,221152,221056],"length":1,"stats":{"Line":3}},{"line":35,"address":[221061,221253,221157],"length":1,"stats":{"Line":3}},{"line":38,"address":[221072,221264,221168],"length":1,"stats":{"Line":6}},{"line":39,"address":[221272,221080,221176],"length":1,"stats":{"Line":6}},{"line":42,"address":[221200,221104,221008],"length":1,"stats":{"Line":5}},{"line":43,"address":[221112,221208,221016],"length":1,"stats":{"Line":5}},{"line":46,"address":[220992,221088,221184],"length":1,"stats":{"Line":4}},{"line":47,"address":[221093,220997,221189],"length":1,"stats":{"Line":4}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[221024,221216,221120],"length":1,"stats":{"Line":3}},{"line":55,"address":[221221,221125,221029],"length":1,"stats":{"Line":3}},{"line":58,"address":[221040,221232,221136],"length":1,"stats":{"Line":3}},{"line":59,"address":[221237,221141,221045],"length":1,"stats":{"Line":3}},{"line":82,"address":[230190,229792,230368,229982,230208,230160,230398,229952,230000],"length":1,"stats":{"Line":4}},{"line":87,"address":[229839,230047,230255],"length":1,"stats":{"Line":7}},{"line":97,"address":[223881,223001,221280,222930,223040,223810,222160,222121,222050],"length":1,"stats":{"Line":7}},{"line":98,"address":[223062,222182,221824,223584,221302,222704],"length":1,"stats":{"Line":15}},{"line":99,"address":[221318,223078,222198],"length":1,"stats":{"Line":7}},{"line":100,"address":[223180,222300,221420,221335,222215,223095],"length":1,"stats":{"Line":14}},{"line":101,"address":[221661,222541,222445,221565,223325,223421],"length":1,"stats":{"Line":16}},{"line":102,"address":[223575,221815,222695],"length":1,"stats":{"Line":8}},{"line":103,"address":[223578,221818,222698],"length":1,"stats":{"Line":8}},{"line":104,"address":[221821,223581,222701],"length":1,"stats":{"Line":6}},{"line":114,"address":[225520],"length":1,"stats":{"Line":1}},{"line":115,"address":[225534],"length":1,"stats":{"Line":1}},{"line":118,"address":[220890,219024,220958,219680,220336,220234,220302,219578,219646],"length":1,"stats":{"Line":4}},{"line":119,"address":[219140,219712,219056,220368,219796,220452],"length":1,"stats":{"Line":8}},{"line":120,"address":[219153,219862,219206,220465,220518,219809],"length":1,"stats":{"Line":8}},{"line":121,"address":[220607,219951,219295],"length":1,"stats":{"Line":0}},{"line":123,"address":[219355,220529,220667,219217,220011,219873],"length":1,"stats":{"Line":4}},{"line":124,"address":[219461,220773,220117],"length":1,"stats":{"Line":4}},{"line":127,"address":[226605,225584,224781,224640,226464,225725],"length":1,"stats":{"Line":4}},{"line":128,"address":[226556,225620,225676,224676,226500,224732],"length":1,"stats":{"Line":14}},{"line":129,"address":[224736,226560,225680],"length":1,"stats":{"Line":8}},{"line":132,"address":[223968,225792,224989,224109,225933,224848],"length":1,"stats":{"Line":9}},{"line":133,"address":[224004,224884,225828,225884,224060,224940],"length":1,"stats":{"Line":18}},{"line":134,"address":[224064,224944,225888],"length":1,"stats":{"Line":9}},{"line":137,"address":[224800,223920,225744],"length":1,"stats":{"Line":5}},{"line":138,"address":[223938,224818,225762],"length":1,"stats":{"Line":5}},{"line":139,"address":[225765,223941,224821],"length":1,"stats":{"Line":5}},{"line":141,"address":[225008,224128,224363,225243,226187,225952],"length":1,"stats":{"Line":5}},{"line":142,"address":[224163,225043,224218,226042,225987,225098],"length":1,"stats":{"Line":10}},{"line":143,"address":[226062,224238,225118],"length":1,"stats":{"Line":0}},{"line":145,"address":[225192,224312,226136],"length":1,"stats":{"Line":5}},{"line":146,"address":[224315,226139,225195],"length":1,"stats":{"Line":5}},{"line":148,"address":[226208,225264,226443,224619,224384,225499],"length":1,"stats":{"Line":5}},{"line":149,"address":[225354,226243,224419,226298,225299,224474],"length":1,"stats":{"Line":10}},{"line":150,"address":[224494,226318,225374],"length":1,"stats":{"Line":0}},{"line":152,"address":[225448,224568,226392],"length":1,"stats":{"Line":5}},{"line":153,"address":[225451,226395,224571],"length":1,"stats":{"Line":5}}],"covered":46,"coverable":51},{"path":["/","home","lucac","github","mermaid-builder","src","shared","generic_node.rs"],"content":"//! Submodule providing a generic node struct which may be reused across\n//! different diagrams.\n\nuse std::rc::Rc;\n\nuse crate::{\n    errors::NodeError,\n    shared::{StyleClass, StyleClassError, StyleProperty},\n    traits::{Node, NodeBuilder},\n};\n\n#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// Struct representing a generic node in Mermaid diagrams.\npub(crate) struct GenericNode {\n    /// Unique identifier for the node.\n    id: u64,\n    /// Label for the node.\n    label: String,\n    /// Classes associated with the node, used for styling.\n    classes: Vec\u003cRc\u003cStyleClass\u003e\u003e,\n    /// Style properties for the node.\n    style: Vec\u003cStyleProperty\u003e,\n}\n\nimpl Node for GenericNode {\n    type Builder = GenericNodeBuilder;\n\n    fn id(\u0026self) -\u003e u64 {\n        self.id\n    }\n\n    fn label(\u0026self) -\u003e \u0026str {\n        \u0026self.label\n    }\n\n    fn classes(\u0026self) -\u003e impl Iterator\u003cItem = \u0026StyleClass\u003e {\n        self.classes.iter().map(AsRef::as_ref)\n    }\n\n    fn styles(\u0026self) -\u003e impl Iterator\u003cItem = \u0026StyleProperty\u003e {\n        self.style.iter()\n    }\n\n    fn is_compatible_arrow_shape(_shape: super::ArrowShape) -\u003e bool {\n        true\n    }\n}\n\n#[derive(Debug, Default, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// Builder for creating a `GenericNode`.\npub(crate) struct GenericNodeBuilder {\n    /// Unique identifier for the node.\n    id: Option\u003cu64\u003e,\n    /// Label for the node.\n    label: Option\u003cString\u003e,\n    /// Classes associated with the node, used for styling.\n    classes: Vec\u003cRc\u003cStyleClass\u003e\u003e,\n    /// Style properties for the node.\n    style: Vec\u003cStyleProperty\u003e,\n}\n\nimpl TryFrom\u003cGenericNodeBuilder\u003e for GenericNode {\n    type Error = NodeError;\n\n    fn try_from(builder: GenericNodeBuilder) -\u003e Result\u003cSelf, Self::Error\u003e {\n        let id = builder.id.ok_or(NodeError::MissingId)?;\n        let label = builder.label.ok_or(NodeError::MissingLabel)?;\n\n        Ok(GenericNode { id, label, classes: builder.classes, style: builder.style })\n    }\n}\n\nimpl NodeBuilder for GenericNodeBuilder {\n    type Node = GenericNode;\n    type Error = NodeError;\n\n    fn build(self) -\u003e Result\u003cSelf::Node, Self::Error\u003e {\n        self.try_into()\n    }\n\n    fn id(mut self, id: u64) -\u003e Self {\n        self.id = Some(id);\n        self\n    }\n\n    fn get_id(\u0026self) -\u003e Option\u003cu64\u003e {\n        self.id\n    }\n\n    fn label\u003cS: ToString\u003e(mut self, label: S) -\u003e Result\u003cSelf, Self::Error\u003e {\n        let label = label.to_string();\n        if label.is_empty() {\n            return Err(crate::errors::NodeError::EmptyLabel);\n        }\n\n        self.label = Some(label);\n        Ok(self)\n    }\n\n    fn get_label(\u0026self) -\u003e Option\u003c\u0026String\u003e {\n        self.label.as_ref()\n    }\n\n    fn style_class(mut self, style_class: Rc\u003cStyleClass\u003e) -\u003e Result\u003cSelf, StyleClassError\u003e {\n        if self.classes.iter().any(|c| c.name() == style_class.name()) {\n            return Err(StyleClassError::DuplicateClass(style_class.name().to_owned()));\n        }\n\n        self.classes.push(style_class);\n        Ok(self)\n    }\n\n    fn style_property(mut self, property: StyleProperty) -\u003e Result\u003cSelf, StyleClassError\u003e {\n        if self.style.iter().any(|p| p.is_same_type(property)) {\n            return Err(StyleClassError::DuplicateProperty(property));\n        }\n\n        self.style.push(property);\n        Ok(self)\n    }\n\n    fn style_properties(\u0026self) -\u003e impl Iterator\u003cItem = \u0026StyleProperty\u003e {\n        self.style.iter()\n    }\n}\n","traces":[{"line":29,"address":[187888],"length":1,"stats":{"Line":1}},{"line":30,"address":[187893],"length":1,"stats":{"Line":1}},{"line":33,"address":[187904],"length":1,"stats":{"Line":1}},{"line":34,"address":[187909],"length":1,"stats":{"Line":1}},{"line":37,"address":[187952],"length":1,"stats":{"Line":5}},{"line":38,"address":[187957],"length":1,"stats":{"Line":5}},{"line":41,"address":[187920],"length":1,"stats":{"Line":1}},{"line":42,"address":[187925],"length":1,"stats":{"Line":2}},{"line":45,"address":[187872],"length":1,"stats":{"Line":0}},{"line":67,"address":[191827,190880],"length":1,"stats":{"Line":10}},{"line":68,"address":[190905,191005,191698],"length":1,"stats":{"Line":22}},{"line":69,"address":[191684,191147],"length":1,"stats":{"Line":13}},{"line":71,"address":[191429],"length":1,"stats":{"Line":13}},{"line":79,"address":[189200],"length":1,"stats":{"Line":0}},{"line":80,"address":[189213],"length":1,"stats":{"Line":0}},{"line":83,"address":[189152],"length":1,"stats":{"Line":4}},{"line":84,"address":[189169],"length":1,"stats":{"Line":4}},{"line":85,"address":[189180],"length":1,"stats":{"Line":8}},{"line":88,"address":[189264],"length":1,"stats":{"Line":1}},{"line":89,"address":[189269],"length":1,"stats":{"Line":4}},{"line":92,"address":[271102,271174,270544],"length":1,"stats":{"Line":12}},{"line":93,"address":[270660,270576],"length":1,"stats":{"Line":23}},{"line":94,"address":[270726,270673],"length":1,"stats":{"Line":16}},{"line":95,"address":[270819],"length":1,"stats":{"Line":0}},{"line":98,"address":[270877,270737],"length":1,"stats":{"Line":5}},{"line":99,"address":[270985],"length":1,"stats":{"Line":12}},{"line":102,"address":[189280],"length":1,"stats":{"Line":0}},{"line":103,"address":[189285],"length":1,"stats":{"Line":0}},{"line":106,"address":[188631,188128],"length":1,"stats":{"Line":1}},{"line":107,"address":[188251,188163],"length":1,"stats":{"Line":2}},{"line":108,"address":[188429,188353],"length":1,"stats":{"Line":0}},{"line":111,"address":[188324],"length":1,"stats":{"Line":1}},{"line":112,"address":[188370],"length":1,"stats":{"Line":1}},{"line":115,"address":[189091,188656],"length":1,"stats":{"Line":1}},{"line":116,"address":[188722,188790],"length":1,"stats":{"Line":2}},{"line":117,"address":[188956],"length":1,"stats":{"Line":0}},{"line":120,"address":[188863],"length":1,"stats":{"Line":1}},{"line":121,"address":[189037],"length":1,"stats":{"Line":1}},{"line":124,"address":[189120],"length":1,"stats":{"Line":0}},{"line":125,"address":[189125],"length":1,"stats":{"Line":0}}],"covered":30,"coverable":40},{"path":["/","home","lucac","github","mermaid-builder","src","shared","javascript_function_signature.rs"],"content":"//! Submodule defining a JavaScript function signature.\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","lucac","github","mermaid-builder","src","shared","javascript_types.rs"],"content":"//! Submodule defining an enumeration for JavaScript types which may be employed\n//! as the signature of a JavaScript function call in Mermaid diagrams.\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","lucac","github","mermaid-builder","src","shared","line_style.rs"],"content":"//! Submodule providing an enumeration for the possible link line styles in\n//! Mermaid diagrams.\n\n#[derive(Default, Copy, Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// Represents the line style of links in Mermaid diagrams.\npub enum LineStyle {\n    /// A normal line style.\n    #[default]\n    Solid,\n    /// A Thick line style.\n    Thick,\n    /// A Dashed line style.\n    Dashed,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","lucac","github","mermaid-builder","src","shared","style_class","builder.rs"],"content":"//! Submodule providing a builder struct for style classes in Mermaid diagrams.\n\nuse crate::shared::{\n    StyleClass,\n    style_class::{StyleClassError, StyleProperty},\n};\n\n#[derive(Default, Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// Builder struct for creating style classes in Mermaid diagrams.\n///\n/// # Example\n///\n/// ```\n/// use mermaid_builder::prelude::*;\n///\n/// let style_class = StyleClassBuilder::default()\n///     .name(\"myClass\")\n///     .unwrap()\n///     .property(StyleProperty::Fill(Color::from((255, 0, 0))))\n///     .unwrap()\n///     .build()\n///     .unwrap();\n/// ```\npub struct StyleClassBuilder {\n    /// The name of the style class.\n    name: Option\u003cString\u003e,\n    /// The properties associated with the style class.\n    properties: Vec\u003cStyleProperty\u003e,\n}\n\nimpl TryFrom\u003cStyleClassBuilder\u003e for StyleClass {\n    type Error = StyleClassError;\n\n    fn try_from(builder: StyleClassBuilder) -\u003e Result\u003cSelf, Self::Error\u003e {\n        if builder.properties.is_empty() {\n            return Err(StyleClassError::MissingProperties);\n        }\n\n        Ok(StyleClass {\n            name: builder.name.ok_or(StyleClassError::MissingName)?,\n            properties: builder.properties,\n        })\n    }\n}\n\nimpl StyleClassBuilder {\n    /// Sets the name of the style class.\n    ///\n    /// # Arguments\n    ///\n    /// * `name` - A string slice that holds the name of the style class.\n    ///\n    /// # Errors\n    ///\n    /// * Returns `StyleClassError::EmptyName` if the provided name is empty.\n    pub fn name(mut self, name: impl Into\u003cString\u003e) -\u003e Result\u003cSelf, StyleClassError\u003e {\n        let name = name.into();\n\n        if name.is_empty() {\n            return Err(StyleClassError::EmptyName);\n        }\n\n        self.name = Some(name);\n\n        Ok(self)\n    }\n\n    /// Adds a property to the style class.\n    ///\n    /// # Arguments\n    ///\n    /// * `property` - A `StyleProperty` that will be added to the style class.\n    ///\n    /// # Errors\n    ///\n    /// * Returns `StyleClassError::DuplicateProperty` if the property is\n    ///   already present.\n    pub fn property(mut self, property: StyleProperty) -\u003e Result\u003cSelf, StyleClassError\u003e {\n        if self.properties.contains(\u0026property) {\n            return Err(StyleClassError::DuplicateProperty(property));\n        }\n\n        self.properties.push(property);\n        Ok(self)\n    }\n\n    /// Builds the style class.\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if the style class cannot be built.\n    pub fn build(self) -\u003e Result\u003cStyleClass, StyleClassError\u003e {\n        self.try_into()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::shared::style_class::color::Color;\n\n    #[test]\n    fn test_style_class_builder() -\u003e Result\u003c(), StyleClassError\u003e {\n        let style_class = StyleClassBuilder::default()\n            .name(\"myClass\")?\n            .property(StyleProperty::Fill(Color::from((255, 0, 0))))?\n            .property(StyleProperty::Stroke(Color::from((0, 0, 255))))?\n            .build()?;\n\n        assert_eq!(style_class.name, \"myClass\");\n        assert_eq!(style_class.properties.len(), 2);\n        assert!(style_class.properties.contains(\u0026StyleProperty::Fill(Color::from((255, 0, 0)))));\n        assert!(style_class.properties.contains(\u0026StyleProperty::Stroke(Color::from((0, 0, 255)))));\n        Ok(())\n    }\n\n    #[test]\n    fn test_style_class_builder_errors() {\n        let builder = StyleClassBuilder::default();\n        assert!(matches!(builder.name(\"\"), Err(StyleClassError::EmptyName)));\n\n        let builder = StyleClassBuilder::default().name(\"myClass\").unwrap();\n        assert!(matches!(builder.build(), Err(StyleClassError::MissingProperties)));\n\n        let builder = StyleClassBuilder::default()\n            .name(\"myClass\")\n            .unwrap()\n            .property(StyleProperty::Fill(Color::from((255, 0, 0))))\n            .unwrap();\n        assert!(matches!(\n            builder.property(StyleProperty::Fill(Color::from((255, 0, 0)))),\n            Err(StyleClassError::DuplicateProperty(_))\n        ));\n    }\n}\n","traces":[{"line":35,"address":[515344,516086],"length":1,"stats":{"Line":1}},{"line":36,"address":[515372,515460],"length":1,"stats":{"Line":2}},{"line":37,"address":[515556],"length":1,"stats":{"Line":1}},{"line":40,"address":[515893],"length":1,"stats":{"Line":5}},{"line":41,"address":[516015,515470,515623],"length":1,"stats":{"Line":4}},{"line":42,"address":[515850],"length":1,"stats":{"Line":3}},{"line":57,"address":[372816,373400],"length":1,"stats":{"Line":5}},{"line":58,"address":[372880,372944],"length":1,"stats":{"Line":12}},{"line":60,"address":[373010,372957],"length":1,"stats":{"Line":13}},{"line":61,"address":[373116],"length":1,"stats":{"Line":1}},{"line":64,"address":[373179,373021],"length":1,"stats":{"Line":3}},{"line":66,"address":[373283],"length":1,"stats":{"Line":6}},{"line":79,"address":[375515,375120],"length":1,"stats":{"Line":3}},{"line":80,"address":[375255,375186],"length":1,"stats":{"Line":9}},{"line":81,"address":[375370],"length":1,"stats":{"Line":1}},{"line":84,"address":[375281],"length":1,"stats":{"Line":3}},{"line":85,"address":[375451],"length":1,"stats":{"Line":3}},{"line":93,"address":[375056],"length":1,"stats":{"Line":1}},{"line":94,"address":[375070],"length":1,"stats":{"Line":1}}],"covered":19,"coverable":19},{"path":["/","home","lucac","github","mermaid-builder","src","shared","style_class","color.rs"],"content":"//! Submodule defining the `Color` struct for Mermaid diagrams.\n\nuse colorsys::{Hsl, Rgb};\n\n/// Represents a color in the Mermaid diagram style class.\n#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\npub struct Color {\n    /// Red component of the color (0-255).\n    red: u8,\n    /// Green component of the color (0-255).\n    green: u8,\n    /// Blue component of the color (0-255).\n    blue: u8,\n}\n\nimpl From\u003c(u8, u8, u8)\u003e for Color {\n    fn from(rgb: (u8, u8, u8)) -\u003e Self {\n        Color { red: rgb.0, green: rgb.1, blue: rgb.2 }\n    }\n}\n\nimpl From\u003cRgb\u003e for Color {\n    #[allow(clippy::cast_possible_truncation)]\n    #[allow(clippy::cast_sign_loss)]\n    fn from(rgb: Rgb) -\u003e Self {\n        Color { red: rgb.red() as u8, green: rgb.green() as u8, blue: rgb.blue() as u8 }\n    }\n}\n\nimpl From\u003cHsl\u003e for Color {\n    fn from(hsl: Hsl) -\u003e Self {\n        let rgb = Rgb::from(hsl);\n        Color::from(rgb)\n    }\n}\n\nimpl From\u003cColor\u003e for Rgb {\n    fn from(color: Color) -\u003e Self {\n        Rgb::new(f64::from(color.red), f64::from(color.green), f64::from(color.blue), None)\n    }\n}\n\nimpl From\u003cColor\u003e for Hsl {\n    fn from(color: Color) -\u003e Self {\n        let rgb: Rgb = color.into();\n        Hsl::from(rgb)\n    }\n}\n\nimpl Color {\n    #[must_use]\n    /// Returns a new pastel red color.\n    pub fn pastel_red() -\u003e Self {\n        Color { red: 240, green: 116, blue: 108 }\n    }\n\n    #[must_use]\n    /// Returns a new pastel blue color.\n    pub fn pastel_blue() -\u003e Self {\n        Color { red: 108, green: 116, blue: 240 }\n    }\n\n    #[must_use]\n    /// Returns a new pastel cyan color.\n    pub fn pastel_cyan() -\u003e Self {\n        Color { red: 167, green: 239, blue: 240 }\n    }\n\n    #[must_use]\n    /// Returns the color as a hexadecimal string.\n    pub fn to_hex(self) -\u003e String {\n        format!(\"#{:02x}{:02x}{:02x}\", self.red, self.green, self.blue)\n    }\n\n    #[must_use]\n    /// Returns `n` maximally distinct colors.\n    ///\n    /// # Arguments\n    ///\n    /// * `n` - The number of distinct colors to generate.\n    /// * `saturation` - The saturation of the colors (0-100).\n    /// * `lightness` - The lightness of the colors (0-100).\n    pub fn maximally_distinct(n: u16, saturation: u8, lightness: u8) -\u003e Vec\u003cColor\u003e {\n        let mut colors = Vec::with_capacity(usize::from(n));\n        let saturation = f64::from(saturation);\n        let lightness = f64::from(lightness);\n        for i in 0..n {\n            let hue = f64::from(i) * 360.0 / f64::from(n);\n            let hsl = Hsl::new(hue, saturation, lightness, None);\n            colors.push(hsl.into());\n        }\n        colors\n    }\n\n    #[must_use]\n    /// Returns the color darkened by the provided amount (0-100).\n    pub fn darken(self, amount: u8) -\u003e Color {\n        let hsl: Hsl = self.into();\n        let new_lightness = (hsl.lightness() - f64::from(amount)).max(0.0);\n        let new_hsl = Hsl::new(hsl.hue(), hsl.saturation(), new_lightness, None);\n        new_hsl.into()\n    }\n\n    #[must_use]\n    /// Returns the color lightened by the provided amount (0-100).\n    pub fn lighten(self, amount: u8) -\u003e Color {\n        let hsl: Hsl = self.into();\n        let new_lightness = (hsl.lightness() + f64::from(amount)).min(100.0);\n        let new_hsl = Hsl::new(hsl.hue(), hsl.saturation(), new_lightness, None);\n        new_hsl.into()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_color_from_tuple() {\n        let color = Color::from((255, 0, 0));\n        assert_eq!(color.red, 255);\n        assert_eq!(color.green, 0);\n        assert_eq!(color.blue, 0);\n    }\n\n    #[test]\n    fn test_color_to_hex() {\n        let color = Color::from((255, 0, 0));\n        assert_eq!(color.to_hex(), \"#ff0000\");\n    }\n\n    #[test]\n    fn test_pastel_colors() {\n        let red = Color::pastel_red();\n        assert_eq!(red.to_hex(), \"#f0746c\");\n\n        let blue = Color::pastel_blue();\n        assert_eq!(blue.to_hex(), \"#6c74f0\");\n\n        let cyan = Color::pastel_cyan();\n        assert_eq!(cyan.to_hex(), \"#a7eff0\");\n    }\n\n    #[test]\n    fn test_maximally_distinct() {\n        let colors = Color::maximally_distinct(3, 100, 50);\n        assert_eq!(colors.len(), 3);\n        // Check if colors are distinct enough (basic check)\n        assert_ne!(colors[0], colors[1]);\n        assert_ne!(colors[1], colors[2]);\n        assert_ne!(colors[0], colors[2]);\n    }\n\n    #[test]\n    fn test_darken_lighten() {\n        let color = Color::from((100, 100, 100));\n        let darkened = color.darken(10);\n        let lightened = color.lighten(10);\n\n        // Converting to HSL to check lightness would be ideal, but checking inequality\n        // is a start\n        assert_ne!(color, darkened);\n        assert_ne!(color, lightened);\n    }\n}\n","traces":[{"line":18,"address":[596304],"length":1,"stats":{"Line":7}},{"line":19,"address":[596340],"length":1,"stats":{"Line":7}},{"line":26,"address":[597104],"length":1,"stats":{"Line":2}},{"line":27,"address":[597112],"length":1,"stats":{"Line":2}},{"line":32,"address":[596448],"length":1,"stats":{"Line":2}},{"line":33,"address":[596455],"length":1,"stats":{"Line":2}},{"line":34,"address":[596539],"length":1,"stats":{"Line":2}},{"line":39,"address":[212240],"length":1,"stats":{"Line":1}},{"line":40,"address":[212289],"length":1,"stats":{"Line":1}},{"line":45,"address":[361408],"length":1,"stats":{"Line":1}},{"line":46,"address":[361461],"length":1,"stats":{"Line":1}},{"line":47,"address":[361529],"length":1,"stats":{"Line":1}},{"line":72,"address":[595520],"length":1,"stats":{"Line":1}},{"line":73,"address":[595572],"length":1,"stats":{"Line":1}},{"line":84,"address":[595012,595018,594304],"length":1,"stats":{"Line":1}},{"line":85,"address":[594359],"length":1,"stats":{"Line":1}},{"line":86,"address":[594447,594384],"length":1,"stats":{"Line":2}},{"line":87,"address":[594456],"length":1,"stats":{"Line":1}},{"line":88,"address":[594594,594492],"length":1,"stats":{"Line":2}},{"line":89,"address":[594589,594681,594605],"length":1,"stats":{"Line":3}},{"line":90,"address":[594744],"length":1,"stats":{"Line":1}},{"line":91,"address":[594767],"length":1,"stats":{"Line":1}},{"line":93,"address":[594628],"length":1,"stats":{"Line":1}},{"line":98,"address":[595040],"length":1,"stats":{"Line":1}},{"line":99,"address":[595097],"length":1,"stats":{"Line":1}},{"line":100,"address":[595199],"length":1,"stats":{"Line":1}},{"line":101,"address":[595267],"length":1,"stats":{"Line":1}},{"line":102,"address":[595332],"length":1,"stats":{"Line":1}},{"line":107,"address":[595808],"length":1,"stats":{"Line":1}},{"line":108,"address":[595865],"length":1,"stats":{"Line":1}},{"line":109,"address":[595967],"length":1,"stats":{"Line":1}},{"line":110,"address":[596040],"length":1,"stats":{"Line":1}},{"line":111,"address":[596105],"length":1,"stats":{"Line":1}}],"covered":33,"coverable":33},{"path":["/","home","lucac","github","mermaid-builder","src","shared","style_class","error.rs"],"content":"//! Submodule defining the error enumeration which describes errors\n//! which may happen while creating style classes in Mermaid diagrams.\n\nuse thiserror::Error;\n\nuse crate::shared::{StyleClass, style_class::StyleProperty};\n\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Error)]\n/// Enum representing the different types of errors that can occur when\n/// creating or using style classes in Mermaid diagrams.\npub enum StyleClassError {\n    /// The name of the style class is empty.\n    #[error(\"Style class name cannot be empty.\")]\n    EmptyName,\n    /// The style class was duplicated.\n    #[error(\"Duplicate style class: `{0}`\")]\n    DuplicateClass(String),\n    /// The property was duplicated.\n    #[error(\"Duplicate property found: `{0}`\")]\n    DuplicateProperty(StyleProperty),\n    /// The style class is unknown in the context of the diagram.\n    #[error(\"Unknown style class: `{}`\", .0.name())]\n    UnknownClass(StyleClass),\n    /// The name of the style class is missing.\n    #[error(\"Style class name is missing.\")]\n    MissingName,\n    /// The properties of the style class are missing.\n    #[error(\"Style class properties are missing.\")]\n    MissingProperties,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","lucac","github","mermaid-builder","src","shared","style_class","font_style.rs"],"content":"//! Submodule providing the enumeration `FontStyle` which defines\n//! different font styles that can be applied to text in Mermaid diagrams.\n\nuse std::fmt::Display;\n\n#[derive(Default, Copy, Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// Represents different font styles that can be applied to text in Mermaid\n/// diagrams.\npub enum FontStyle {\n    /// Normal font style.\n    #[default]\n    Normal,\n    /// Italic font style.\n    Italic,\n    /// Oblique font style.\n    Oblique,\n}\n\nimpl Display for FontStyle {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            FontStyle::Normal =\u003e write!(f, \"normal\"),\n            FontStyle::Italic =\u003e write!(f, \"italic\"),\n            FontStyle::Oblique =\u003e write!(f, \"oblique\"),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_font_style_display() {\n        assert_eq!(format!(\"{}\", FontStyle::Normal), \"normal\");\n        assert_eq!(format!(\"{}\", FontStyle::Italic), \"italic\");\n        assert_eq!(format!(\"{}\", FontStyle::Oblique), \"oblique\");\n    }\n}\n","traces":[{"line":21,"address":[269824],"length":1,"stats":{"Line":1}},{"line":22,"address":[269842],"length":1,"stats":{"Line":1}},{"line":23,"address":[269874],"length":1,"stats":{"Line":1}},{"line":24,"address":[269911],"length":1,"stats":{"Line":1}},{"line":25,"address":[269948],"length":1,"stats":{"Line":1}}],"covered":5,"coverable":5},{"path":["/","home","lucac","github","mermaid-builder","src","shared","style_class","font_weight.rs"],"content":"//! Submodule providing the `FontWeight` enum used in Mermaid diagrams.\n\nuse std::fmt::Display;\n\n#[derive(Default, Copy, Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// Represents different font weights that can be applied to text in Mermaid\n/// diagrams.\npub enum FontWeight {\n    /// Normal font weight.\n    #[default]\n    Normal,\n    /// Bold font weight.\n    Bold,\n    /// Bolder font weight.\n    Bolder,\n    /// Lighter font weight.\n    Lighter,\n    /// A specific numeric font weight (e.g., 100, 200, ..., 900).\n    Number(u16),\n}\n\nimpl Display for FontWeight {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            FontWeight::Normal =\u003e write!(f, \"normal\"),\n            FontWeight::Bold =\u003e write!(f, \"bold\"),\n            FontWeight::Bolder =\u003e write!(f, \"bolder\"),\n            FontWeight::Lighter =\u003e write!(f, \"lighter\"),\n            FontWeight::Number(value) =\u003e write!(f, \"{value}\"),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_font_weight_display() {\n        assert_eq!(format!(\"{}\", FontWeight::Normal), \"normal\");\n        assert_eq!(format!(\"{}\", FontWeight::Bold), \"bold\");\n        assert_eq!(format!(\"{}\", FontWeight::Bolder), \"bolder\");\n        assert_eq!(format!(\"{}\", FontWeight::Lighter), \"lighter\");\n        assert_eq!(format!(\"{}\", FontWeight::Number(400)), \"400\");\n    }\n}\n","traces":[{"line":24,"address":[555984],"length":1,"stats":{"Line":1}},{"line":25,"address":[556008],"length":1,"stats":{"Line":1}},{"line":26,"address":[556039],"length":1,"stats":{"Line":1}},{"line":27,"address":[556080],"length":1,"stats":{"Line":1}},{"line":28,"address":[556121],"length":1,"stats":{"Line":1}},{"line":29,"address":[556162],"length":1,"stats":{"Line":1}},{"line":30,"address":[556205],"length":1,"stats":{"Line":1}}],"covered":7,"coverable":7},{"path":["/","home","lucac","github","mermaid-builder","src","shared","style_class","style_properties.rs"],"content":"//! Enumeration of style properties which may be applied to nodes in a Mermaid\n//! diagram.\n\nuse std::fmt::Display;\n\nuse crate::shared::style_class::{\n    color::Color, font_style::FontStyle, font_weight::FontWeight, units::Unit,\n};\n\n#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// `StyleProperty` enumerates all supported style properties for Mermaid class\n/// definitions.\npub enum StyleProperty {\n    /// Sets the fill color of the node (e.g., `fill: #ff0000`)\n    Fill(Color),\n    /// Sets the stroke (border) color of the node (e.g., `stroke: #000`)\n    Stroke(Color),\n    /// Sets the text color inside the node (e.g., `color: #333`)\n    Color(Color),\n    /// Sets the width of the node border (e.g., `stroke-width: 2px`)\n    StrokeWidth(Unit),\n    /// Sets the font size for node text (e.g., `font-size: 16px`)\n    FontSize(Unit),\n    /// Sets the font weight for node text (e.g., `font-weight: bold`)\n    FontWeight(FontWeight),\n    /// Sets the font style for node text (e.g., `font-style: italic`)\n    FontStyle(FontStyle),\n    /// Sets the dash pattern for the border (e.g., `stroke-dasharray: 5, 2`)\n    StrokeDasharray(u8, u8),\n    /// Sets the dash offset for the border (e.g., `stroke-dashoffset: 4`)\n    StrokeDashoffset(u16),\n    /// Sets the opacity of the node, with a value between 0 and 100,\n    /// which is then normalized to a float between 0.0 and 1.0.\n    Opacity(u8),\n    /// Border radius for rounded corners (e.g., `border-radius: 5px`)\n    BorderRadius(Unit),\n}\n\nimpl StyleProperty {\n    #[must_use]\n    /// Returns whether the provided style property is of the same type as\n    /// `self`.\n    pub fn is_same_type(self, other: StyleProperty) -\u003e bool {\n        matches!(\n            (self, other),\n            (StyleProperty::Fill(_), StyleProperty::Fill(_))\n                | (StyleProperty::Stroke(_), StyleProperty::Stroke(_))\n                | (StyleProperty::Color(_), StyleProperty::Color(_))\n                | (StyleProperty::StrokeWidth(_), StyleProperty::StrokeWidth(_))\n                | (StyleProperty::FontSize(_), StyleProperty::FontSize(_))\n                | (StyleProperty::FontWeight(_), StyleProperty::FontWeight(_))\n                | (StyleProperty::FontStyle(_), StyleProperty::FontStyle(_))\n                | (StyleProperty::StrokeDasharray(_, _), StyleProperty::StrokeDasharray(_, _))\n                | (StyleProperty::StrokeDashoffset(_), StyleProperty::StrokeDashoffset(_))\n                | (StyleProperty::Opacity(_), StyleProperty::Opacity(_))\n                | (StyleProperty::BorderRadius(_), StyleProperty::BorderRadius(_))\n        )\n    }\n}\n\nimpl Display for StyleProperty {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            StyleProperty::Fill(color) =\u003e write!(f, \"fill: {}\", color.to_hex()),\n            StyleProperty::Stroke(color) =\u003e write!(f, \"stroke: {}\", color.to_hex()),\n            StyleProperty::Color(color) =\u003e write!(f, \"color: {}\", color.to_hex()),\n            StyleProperty::StrokeWidth(unit) =\u003e write!(f, \"stroke-width: {unit}\"),\n            StyleProperty::FontSize(unit) =\u003e write!(f, \"font-size: {unit}\"),\n            StyleProperty::FontWeight(weight) =\u003e write!(f, \"font-weight: {weight}\"),\n            StyleProperty::FontStyle(style) =\u003e write!(f, \"font-style: {style}\"),\n            StyleProperty::StrokeDasharray(length, gap) =\u003e {\n                write!(f, \"stroke-dasharray: {length}, {gap}\")\n            }\n            StyleProperty::StrokeDashoffset(offset) =\u003e write!(f, \"stroke-dashoffset: {offset}\",),\n            StyleProperty::Opacity(value) =\u003e write!(f, \"opacity: {:.2}\", f32::from(*value) / 100.0),\n            StyleProperty::BorderRadius(radius) =\u003e write!(f, \"rx: {radius}, ry: {radius}\"),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_style_property_display() {\n        let color = Color::from((255, 0, 0));\n        assert_eq!(format!(\"{}\", StyleProperty::Fill(color)), \"fill: #ff0000\");\n        assert_eq!(format!(\"{}\", StyleProperty::Stroke(color)), \"stroke: #ff0000\");\n        assert_eq!(format!(\"{}\", StyleProperty::Color(color)), \"color: #ff0000\");\n        assert_eq!(format!(\"{}\", StyleProperty::StrokeWidth(Unit::Pixel(2))), \"stroke-width: 2px\");\n        assert_eq!(format!(\"{}\", StyleProperty::FontSize(Unit::Point(12))), \"font-size: 12pt\");\n        assert_eq!(format!(\"{}\", StyleProperty::FontWeight(FontWeight::Bold)), \"font-weight: bold\");\n        assert_eq!(\n            format!(\"{}\", StyleProperty::FontStyle(FontStyle::Italic)),\n            \"font-style: italic\"\n        );\n        assert_eq!(format!(\"{}\", StyleProperty::StrokeDasharray(5, 2)), \"stroke-dasharray: 5, 2\");\n        assert_eq!(format!(\"{}\", StyleProperty::StrokeDashoffset(4)), \"stroke-dashoffset: 4\");\n        assert_eq!(format!(\"{}\", StyleProperty::Opacity(50)), \"opacity: 0.50\");\n        assert_eq!(format!(\"{}\", StyleProperty::BorderRadius(Unit::Pixel(5))), \"rx: 5px, ry: 5px\");\n    }\n\n    #[test]\n    fn test_style_property_is_same_type() {\n        assert!(\n            StyleProperty::Fill(Color::from((255, 0, 0)))\n                .is_same_type(StyleProperty::Fill(Color::from((0, 0, 255))))\n        );\n        assert!(\n            !StyleProperty::Fill(Color::from((255, 0, 0)))\n                .is_same_type(StyleProperty::Stroke(Color::from((255, 0, 0))))\n        );\n    }\n}\n","traces":[{"line":44,"address":[793488,793627],"length":1,"stats":{"Line":1}},{"line":45,"address":[793746,793618,793657,793634,793703,793786,793680,793826,793806,793846,793766,793726],"length":1,"stats":{"Line":2}},{"line":46,"address":[793821,793761,793741,793781,793801,793629,793560,793698,793841,793721,793675,793652],"length":1,"stats":{"Line":2}},{"line":63,"address":[799719,799725,797904],"length":1,"stats":{"Line":1}},{"line":64,"address":[797937],"length":1,"stats":{"Line":1}},{"line":65,"address":[797973,799563],"length":1,"stats":{"Line":1}},{"line":66,"address":[798118,799738],"length":1,"stats":{"Line":1}},{"line":67,"address":[799882,798263],"length":1,"stats":{"Line":1}},{"line":68,"address":[798408],"length":1,"stats":{"Line":1}},{"line":69,"address":[798538],"length":1,"stats":{"Line":1}},{"line":70,"address":[798669],"length":1,"stats":{"Line":1}},{"line":71,"address":[798800],"length":1,"stats":{"Line":1}},{"line":72,"address":[798930],"length":1,"stats":{"Line":1}},{"line":73,"address":[798957],"length":1,"stats":{"Line":1}},{"line":75,"address":[799144],"length":1,"stats":{"Line":1}},{"line":76,"address":[799275],"length":1,"stats":{"Line":1}},{"line":77,"address":[799438],"length":1,"stats":{"Line":1}}],"covered":17,"coverable":17},{"path":["/","home","lucac","github","mermaid-builder","src","shared","style_class","units.rs"],"content":"//! Submodule providing an enumeration of units which may be used in\n//! style class definitions in Mermaid diagrams, including pixel and\n//! point units.\n\nuse std::fmt::Display;\n\n#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// Represents the unit of measurement used in style class definitions.\npub enum Unit {\n    /// Pixel unit, denoted by `px`.\n    Pixel(u8),\n    /// Point unit, denoted by `pt`.\n    Point(u8),\n}\n\nimpl Display for Unit {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Unit::Pixel(value) =\u003e write!(f, \"{value}px\"),\n            Unit::Point(value) =\u003e write!(f, \"{value}pt\"),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_unit_display() {\n        assert_eq!(format!(\"{}\", Unit::Pixel(10)), \"10px\");\n        assert_eq!(format!(\"{}\", Unit::Point(12)), \"12pt\");\n    }\n}\n","traces":[{"line":18,"address":[436848],"length":1,"stats":{"Line":1}},{"line":19,"address":[436874],"length":1,"stats":{"Line":1}},{"line":20,"address":[436992],"length":1,"stats":{"Line":1}},{"line":21,"address":[436893],"length":1,"stats":{"Line":1}}],"covered":4,"coverable":4},{"path":["/","home","lucac","github","mermaid-builder","src","shared","style_class.rs"],"content":"//! Submodule providing structs for style class definitions in Mermaid diagrams.\n\nmod builder;\nmod color;\nmod error;\nmod font_style;\nmod font_weight;\nmod style_properties;\nmod units;\nuse std::fmt::Display;\n\npub use builder::StyleClassBuilder;\npub use color::Color;\npub use error::StyleClassError;\npub use font_weight::FontWeight;\npub use style_properties::StyleProperty;\npub use units::Unit;\n\n#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n/// Represents a style class in Mermaid diagrams, which can be used to define\n/// styles for nodes, edges, and other elements. It includes a name and a set of\n/// properties that define the style.\npub struct StyleClass {\n    /// The name of the style class.\n    name: String,\n    /// The properties associated with the style class.\n    properties: Vec\u003cStyleProperty\u003e,\n}\n\nimpl StyleClass {\n    #[must_use]\n    /// Returns the name of the style class.\n    pub fn name(\u0026self) -\u003e \u0026str {\n        \u0026self.name\n    }\n    #[must_use]\n    /// Returns the properties of the style class.\n    pub fn properties(\u0026self) -\u003e \u0026[StyleProperty] {\n        \u0026self.properties\n    }\n}\n\nimpl Display for StyleClass {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        use crate::traits::TabbedDisplay;\n        self.fmt_tabbed(f, 0)\n    }\n}\n\nimpl crate::traits::TabbedDisplay for StyleClass {\n    fn fmt_tabbed(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e, tab_count: usize) -\u003e std::fmt::Result {\n        write!(f, \"{:indent$}classDef {} \", \"\", self.name, indent = tab_count * 2)?;\n        for (property_number, property) in self.properties.iter().enumerate() {\n            if property_number \u003e 0 {\n                write!(f, \",\")?;\n            }\n            write!(f, \"{property}\")?;\n        }\n        writeln!(f)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::shared::style_class::color::Color;\n\n    #[test]\n    fn test_style_class_display() {\n        let style_class = StyleClass {\n            name: \"myClass\".to_string(),\n            properties: vec![\n                StyleProperty::Fill(Color::from((255, 0, 0))),\n                StyleProperty::Stroke(Color::from((0, 0, 255))),\n            ],\n        };\n\n        assert_eq!(format!(\"{style_class}\"), \"classDef myClass fill: #ff0000,stroke: #0000ff\\n\");\n    }\n\n    #[test]\n    fn test_style_class_getters() {\n        let style_class = StyleClass {\n            name: \"myClass\".to_string(),\n            properties: vec![StyleProperty::Fill(Color::from((255, 0, 0)))],\n        };\n\n        assert_eq!(style_class.name(), \"myClass\");\n        assert_eq!(style_class.properties().len(), 1);\n    }\n}\n","traces":[{"line":34,"address":[515328],"length":1,"stats":{"Line":1}},{"line":35,"address":[515333],"length":1,"stats":{"Line":1}},{"line":39,"address":[515312],"length":1,"stats":{"Line":1}},{"line":40,"address":[515317],"length":1,"stats":{"Line":1}},{"line":45,"address":[517744],"length":1,"stats":{"Line":1}},{"line":47,"address":[517758],"length":1,"stats":{"Line":1}},{"line":52,"address":[516208],"length":1,"stats":{"Line":1}},{"line":53,"address":[516252],"length":1,"stats":{"Line":1}},{"line":54,"address":[516653,516548],"length":1,"stats":{"Line":2}},{"line":55,"address":[516745],"length":1,"stats":{"Line":1}},{"line":56,"address":[516939],"length":1,"stats":{"Line":1}},{"line":58,"address":[516807,517020],"length":1,"stats":{"Line":1}},{"line":60,"address":[516757],"length":1,"stats":{"Line":1}}],"covered":13,"coverable":13},{"path":["/","home","lucac","github","mermaid-builder","src","shared.rs"],"content":"//! Submodule providing structs used across different type of Mermaid diagrams.\n\npub mod generic_configuration;\npub use generic_configuration::{Direction, Renderer};\npub(crate) mod generic_diagram;\npub mod javascript_function_signature;\npub mod javascript_types;\npub mod style_class;\npub use style_class::{\n    Color, FontWeight, StyleClass, StyleClassBuilder, StyleClassError, StyleProperty, Unit,\n};\npub mod arrow_shape;\npub mod click_event;\npub mod line_style;\npub use arrow_shape::ArrowShape;\npub use click_event::ClickEvent;\npub use line_style::LineStyle;\nmod constants;\npub(crate) use constants::{EDGE_LETTER, NODE_LETTER};\npub(crate) mod generic_node;\npub(crate) use generic_node::GenericNode;\npub(crate) mod generic_edge;\npub(crate) use generic_edge::GenericEdge;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","lucac","github","mermaid-builder","src","traits","configuration.rs"],"content":"//! Submodule defining the `Configuration` trait for Mermaid diagrams.\n\nuse std::fmt::Display;\n\nuse crate::{\n    shared::generic_configuration::{Direction, Look, Renderer, Theme},\n    traits::ConfigurationBuilder,\n};\n\n/// Trait defining the configuration for Mermaid diagrams.\npub trait Configuration: Default + Display {\n    /// The builder type for this configuration.\n    type Builder: ConfigurationBuilder\u003cConfiguration = Self\u003e;\n\n    /// Returns the title of the diagram, if any.\n    fn title(\u0026self) -\u003e Option\u003c\u0026str\u003e;\n\n    /// Returns the renderer to use for the diagram.\n    fn renderer(\u0026self) -\u003e Renderer;\n\n    /// Returns the direction of the flowchart.\n    fn direction(\u0026self) -\u003e Direction;\n\n    /// Returns the theme to use for the diagram.\n    fn theme(\u0026self) -\u003e Theme;\n\n    /// Returns the look to use for the diagram.\n    fn look(\u0026self) -\u003e Look;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","lucac","github","mermaid-builder","src","traits","configuration_builder.rs"],"content":"//! Submodule defining the `ConfigurationBuilder` trait for Mermaid diagrams.\n\nuse crate::shared::generic_configuration::{Direction, Renderer};\n\n/// Trait defining a configuration builder for Mermaid diagrams.\npub trait ConfigurationBuilder: Sized {\n    /// Type of the configuration that this builder constructs.\n    type Configuration;\n\n    /// The error type returned when building the configuration fails.\n    type Error;\n\n    /// Builds the configuration.\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if the configuration cannot be built.\n    fn build(self) -\u003e Result\u003cSelf::Configuration, Self::Error\u003e;\n\n    /// Returns the current title of the configuration, if any.\n    ///\n    /// # Arguments\n    ///\n    /// * `title` - The title to set for the configuration.\n    ///\n    /// # Errors\n    ///\n    /// * If the provided title is empty.\n    fn title\u003cS: ToString\u003e(self, title: S) -\u003e Result\u003cSelf, Self::Error\u003e;\n\n    #[must_use]\n    /// Sets the renderer to use for the diagram.\n    fn renderer(self, renderer: Renderer) -\u003e Self;\n\n    #[must_use]\n    /// Sets the direction of the flowchart.\n    fn direction(self, direction: Direction) -\u003e Self;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","lucac","github","mermaid-builder","src","traits","diagram.rs"],"content":"//! Submodule defining the `Diagram` trait for Mermaid diagrams.\n\nuse std::{fmt::Display, rc::Rc};\n\nuse crate::{\n    shared::StyleClass,\n    traits::{Configuration, DiagramBuilder, Edge, Node},\n};\n\n/// Trait representing a Mermaid diagram.\npub trait Diagram {\n    /// Type of the associated builder for this diagram.\n    type Builder: DiagramBuilder\u003cDiagram = Self, Node = Self::Node, Edge = Self::Edge\u003e;\n    /// Type of the node used in the diagram.\n    type Node: Node + Display;\n    /// Type of edge used in the diagram.\n    type Edge: Edge\u003cNode = Self::Node\u003e + Display;\n    /// The configuration options for the diagram.\n    type Configuration: Configuration + Display;\n\n    /// Returns the configuration of the diagram.\n    fn configuration(\u0026self) -\u003e \u0026Self::Configuration;\n\n    /// Returns an iterator over the nodes in the diagram.\n    fn nodes(\u0026self) -\u003e impl Iterator\u003cItem = \u0026Self::Node\u003e;\n\n    /// Returns an iterator over the edges in the diagram.\n    fn edges(\u0026self) -\u003e impl Iterator\u003cItem = \u0026Self::Edge\u003e;\n\n    /// Returns an iterator over the style classes associated with the diagram.\n    fn style_classes(\u0026self) -\u003e impl Iterator\u003cItem = \u0026StyleClass\u003e;\n\n    /// Returns the reference to the requested node by ID if it exists.\n    fn get_node_by_id(\u0026self, id: u64) -\u003e Option\u003cRc\u003cSelf::Node\u003e\u003e;\n\n    /// Returns the reference to the requested style class by name if it exists.\n    fn get_style_class_by_name(\u0026self, name: \u0026str) -\u003e Option\u003cRc\u003cStyleClass\u003e\u003e;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","lucac","github","mermaid-builder","src","traits","diagram_builder.rs"],"content":"//! Submodule defining the `DiagramBuilder` trait for Mermaid diagrams.\n\nuse std::{fmt::Display, rc::Rc};\n\nuse crate::{\n    shared::{StyleClass, StyleClassBuilder},\n    traits::{Configuration, ConfigurationBuilder, Diagram, Edge, EdgeBuilder, Node, NodeBuilder},\n};\n\n/// Trait defining the builder for Mermaid diagrams.\npub trait DiagramBuilder: Default\nwhere\n    Self::Diagram: From\u003cSelf\u003e,\n{\n    /// Type of the diagram that this builder constructs.\n    type Diagram: Diagram\u003c\n            Builder = Self,\n            Node = Self::Node,\n            Edge = Self::Edge,\n            Configuration = Self::Configuration,\n        \u003e;\n    /// Type of the node used in the diagram.\n    type Node: Node\u003cBuilder = Self::NodeBuilder\u003e + Display;\n    /// The type of node builder used to create nodes in the diagram.\n    type NodeBuilder: NodeBuilder\u003cNode = Self::Node\u003e;\n    /// Type of edge used in the diagram.\n    type Edge: Edge\u003cNode = Self::Node\u003e + Display;\n    /// The type of edge builder used to create edges in the diagram.\n    type EdgeBuilder: EdgeBuilder\u003cEdge = Self::Edge\u003e;\n    /// The configuration type for the diagram.\n    type Configuration: Configuration + Display;\n    /// The configuration builder type for the diagram.\n    type ConfigurationBuilder: ConfigurationBuilder\u003cConfiguration = Self::Configuration\u003e;\n    /// The error type for the diagram builder.\n    type Error: std::error::Error + Display;\n\n    /// Sets the configuration for the diagram being built.\n    ///\n    /// # Arguments\n    ///\n    /// * `configuration` - The configuration builder to use for constructing\n    ///   the diagram's configuration.\n    ///\n    /// # Errors\n    ///\n    /// * If the configuration builder is incomplete or invalid.\n    fn configuration(self, configuration: Self::ConfigurationBuilder) -\u003e Result\u003cSelf, Self::Error\u003e;\n\n    /// Adds a style class to the diagram being built.\n    ///\n    /// # Arguments\n    ///\n    /// * `style_class` - The style class to add to the diagram.\n    ///\n    /// # Errors\n    ///\n    /// * If there are conflicting style class names.\n    /// * If the style class builder is incomplete or invalid.\n    fn style_class(\n        \u0026mut self,\n        style_class: StyleClassBuilder,\n    ) -\u003e Result\u003cRc\u003cStyleClass\u003e, Self::Error\u003e;\n\n    #[must_use]\n    /// Returns the number of nodes currently in the diagram.\n    fn number_of_nodes(\u0026self) -\u003e usize;\n\n    #[must_use]\n    /// Returns the number of edges currently in the diagram.\n    fn number_of_edges(\u0026self) -\u003e usize;\n\n    /// Builds and adds a node to the diagram being built.\n    ///\n    /// # Arguments\n    ///\n    /// * `node` - The node builder to use for constructing the node.\n    ///\n    /// # Errors\n    ///\n    /// * If the node already exists in the diagram.\n    /// * If the node cannot be built due to missing attributes or other issues.\n    fn node(\u0026mut self, node: Self::NodeBuilder) -\u003e Result\u003cRc\u003cSelf::Node\u003e, Self::Error\u003e;\n\n    /// Iterates over the nodes in the diagram being built.\n    fn nodes(\u0026self) -\u003e impl Iterator\u003cItem = \u0026Rc\u003cSelf::Node\u003e\u003e + '_;\n\n    /// Returns a reference to the requested node by ID if it exists.\n    fn get_node_by_id(\u0026self, id: u64) -\u003e Option\u003cRc\u003cSelf::Node\u003e\u003e;\n\n    /// Returns a reference to the request style class by name if it exists.\n    fn get_style_class_by_name(\u0026self, name: \u0026str) -\u003e Option\u003cRc\u003cStyleClass\u003e\u003e;\n\n    /// Builds and adds an edge to the diagram being built.\n    ///\n    /// # Arguments\n    ///\n    /// * `edge` - The edge builder to use for constructing the edge.\n    ///\n    /// # Errors\n    ///\n    /// * If the source or destination nodes cannot be found in the diagram.\n    /// * If the edge cannot be built due to missing attributes or other issues.\n    fn edge(\u0026mut self, edge: Self::EdgeBuilder) -\u003e Result\u003cRc\u003cSelf::Edge\u003e, Self::Error\u003e;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","lucac","github","mermaid-builder","src","traits","edge.rs"],"content":"//! Submodule defining the trait for representing edges in Mermaid diagrams.\n\nuse std::rc::Rc;\n\nuse crate::{\n    shared::{ArrowShape, LineStyle},\n    traits::{EdgeBuilder, Node},\n};\n\n/// Trait representing an edge in a Mermaid diagram.\npub trait Edge: Ord {\n    /// Type of the builder used to construct this edge.\n    type Builder: EdgeBuilder\u003cEdge = Self\u003e;\n    /// Type of the node this edge connects to.\n    type Node: Node;\n\n    /// Returns a reference to the label of the edge.\n    fn label(\u0026self) -\u003e Option\u003c\u0026str\u003e;\n\n    /// Returns a reference to the source node of the edge.\n    fn source(\u0026self) -\u003e \u0026Rc\u003cSelf::Node\u003e;\n\n    /// Returns a reference to the destination node of the edge.\n    fn destination(\u0026self) -\u003e \u0026Rc\u003cSelf::Node\u003e;\n\n    /// Returns the line style of the edge.\n    fn line_style(\u0026self) -\u003e LineStyle;\n\n    /// Returns an iterator over the style classes associated with the edge.\n    fn classes(\u0026self) -\u003e impl Iterator\u003cItem = \u0026crate::shared::StyleClass\u003e;\n\n    /// Returns the left arrow shape of the edge, if any.\n    fn left_arrow_shape(\u0026self) -\u003e Option\u003cArrowShape\u003e;\n\n    /// Returns the right arrow shape of the edge, if any.\n    fn right_arrow_shape(\u0026self) -\u003e Option\u003cArrowShape\u003e;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","lucac","github","mermaid-builder","src","traits","edge_builder.rs"],"content":"//! Submodule defining the trait for structs constructing edges in Mermaid\n//! diagrams.\n\nuse std::rc::Rc;\n\nuse crate::shared::{ArrowShape, LineStyle};\n\n/// Trait representing an edge builder in a Mermaid diagram.\npub trait EdgeBuilder: Sized {\n    /// The type of edge this builder constructs.\n    type Edge;\n    /// Type of the node this edge connects to.\n    type Node;\n\n    /// The error type returned when building the edge fails.\n    type Error;\n\n    /// Builds the edge.\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if the edge cannot be built.\n    fn build(self) -\u003e Result\u003cSelf::Edge, Self::Error\u003e;\n\n    /// Set the label for this edge.\n    ///\n    /// # Arguments\n    ///\n    /// * `label` - The label to set for this edge.\n    ///\n    /// # Errors\n    ///\n    /// * If the label is empty.\n    fn label\u003cS: ToString\u003e(self, label: S) -\u003e Result\u003cSelf, Self::Error\u003e;\n\n    /// Set the source node for this edge.\n    ///\n    /// # Arguments\n    ///\n    /// * `node` - The source node for this edge.\n    ///\n    /// # Errors\n    ///\n    /// * If the node is not compatible with any of the other set parameters.\n    fn source(self, node: Rc\u003cSelf::Node\u003e) -\u003e Result\u003cSelf, Self::Error\u003e;\n\n    /// Set the destination node for this edge.\n    ///\n    /// # Arguments\n    ///\n    /// * `node` - The destination node for this edge.\n    ///\n    /// # Errors\n    ///\n    /// * If the node is not compatible with any of the other set parameters.\n    fn destination(self, node: Rc\u003cSelf::Node\u003e) -\u003e Result\u003cSelf, Self::Error\u003e;\n\n    #[must_use]\n    /// Set the style class for this edge.\n    ///\n    /// # Arguments\n    ///\n    /// * `class` - The style class to set for this edge.\n    fn line_style(self, style: LineStyle) -\u003e Self;\n\n    /// Set the left arrow shape for this edge.\n    ///\n    /// # Arguments\n    ///\n    /// * `shape` - The shape of the left arrow.\n    ///\n    /// # Errors\n    ///\n    /// * If the shape is not compatible with the associated node type.\n    fn left_arrow_shape(self, shape: ArrowShape) -\u003e Result\u003cSelf, Self::Error\u003e;\n\n    /// Set the right arrow shape for this edge.\n    ///\n    /// # Arguments\n    ///\n    /// * `shape` - The shape of the right arrow.\n    ///\n    /// # Errors\n    ///\n    /// * If the shape is not compatible with the associated node type.\n    fn right_arrow_shape(self, shape: ArrowShape) -\u003e Result\u003cSelf, Self::Error\u003e;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","lucac","github","mermaid-builder","src","traits","node.rs"],"content":"//! Submodule defining the node trait used in Mermaid diagrams.\n\nuse crate::{\n    shared::{ArrowShape, StyleClass, StyleProperty},\n    traits::NodeBuilder,\n};\n\n/// Trait representing a node in a Mermaid diagram.\npub trait Node: PartialOrd + Ord + Eq + PartialEq {\n    /// Type of the builder used to construct this node.\n    type Builder: NodeBuilder\u003cNode = Self\u003e;\n\n    /// Returns the identifier of the node.\n    fn id(\u0026self) -\u003e u64;\n\n    /// Returns the label of the node.\n    fn label(\u0026self) -\u003e \u0026str;\n\n    /// Returns an iterator over the CSS classes associated with the node.\n    fn classes(\u0026self) -\u003e impl Iterator\u003cItem = \u0026StyleClass\u003e;\n\n    /// Returns an iterator over the style properties associated with the node.\n    fn styles(\u0026self) -\u003e impl Iterator\u003cItem = \u0026StyleProperty\u003e;\n\n    /// Returns whether the node is stylized.\n    fn has_styles(\u0026self) -\u003e bool {\n        self.styles().next().is_some()\n    }\n\n    /// Returns whether the provided arrow shape is compatible with the node.\n    fn is_compatible_arrow_shape(shape: ArrowShape) -\u003e bool;\n}\n","traces":[{"line":26,"address":[273209,273168],"length":1,"stats":{"Line":0}},{"line":27,"address":[273177,273240],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":2},{"path":["/","home","lucac","github","mermaid-builder","src","traits","node_builder.rs"],"content":"//! Submodule defining the traits for building a node in Mermaid diagrams.\n\nuse std::rc::Rc;\n\nuse crate::shared::{StyleClass, StyleClassError, StyleProperty};\n\n/// Trait for building nodes in Mermaid diagrams.\npub trait NodeBuilder: Sized {\n    /// Type of the node that this builder constructs.\n    type Node;\n\n    /// The error type returned when building the node fails.\n    type Error;\n\n    /// Builds the node.\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if the node cannot be built.\n    fn build(self) -\u003e Result\u003cSelf::Node, Self::Error\u003e;\n\n    /// Adds the provided style class to the node being built.\n    ///\n    /// # Arguments\n    ///\n    /// * `style_class` - The style class to add to the node.\n    ///\n    /// # Errors\n    ///\n    /// * If the style class name clashes with a previously applied class.\n    fn style_class(self, style_class: Rc\u003cStyleClass\u003e) -\u003e Result\u003cSelf, StyleClassError\u003e;\n\n    /// Adds a style property to the node being built.\n    ///\n    /// # Arguments\n    ///\n    /// * `property` - The style property to add to the node.\n    ///\n    /// # Errors\n    ///\n    /// * If the style property has already been set for the node.\n    fn style_property(self, property: StyleProperty) -\u003e Result\u003cSelf, StyleClassError\u003e;\n\n    /// Iterates across the style properties of the node being built.\n    fn style_properties(\u0026self) -\u003e impl Iterator\u003cItem = \u0026StyleProperty\u003e;\n\n    /// Sets the label for the node being built.\n    ///\n    /// # Arguments\n    ///\n    /// * `label` - The label to set for the node.\n    ///\n    /// # Errors\n    ///\n    /// * If the label is empty.\n    fn label\u003cS: ToString\u003e(self, label: S) -\u003e Result\u003cSelf, Self::Error\u003e;\n\n    /// Returns a reference to the label of the node being built, if set.\n    fn get_label(\u0026self) -\u003e Option\u003c\u0026String\u003e;\n\n    #[must_use]\n    /// Sets the ID for the node being built.\n    fn id(self, id: u64) -\u003e Self;\n\n    /// Returns the ID of the node being built, if set.\n    fn get_id(\u0026self) -\u003e Option\u003cu64\u003e;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","lucac","github","mermaid-builder","src","traits","tabbed_display.rs"],"content":"//! Module defining the `TabbedDisplay` trait for formatted output with\n//! indentation.\nuse std::fmt;\n\n/// Trait for displaying objects with indentation.\npub trait TabbedDisplay {\n    /// Formats the object with the given indentation level.\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if formatting fails.\n    fn fmt_tabbed(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e, tab_count: usize) -\u003e fmt::Result;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","lucac","github","mermaid-builder","src","traits.rs"],"content":"//! Submodule defining traits for Mermaid diagrams and annexed objects.\n\npub mod diagram;\npub mod diagram_builder;\npub use diagram::Diagram;\npub use diagram_builder::DiagramBuilder;\npub mod node;\npub use node::Node;\npub mod node_builder;\npub use node_builder::NodeBuilder;\npub mod edge;\npub use edge::Edge;\npub mod edge_builder;\npub use edge_builder::EdgeBuilder;\npub mod configuration;\npub use configuration::Configuration;\npub mod configuration_builder;\npub use configuration_builder::ConfigurationBuilder;\npub mod tabbed_display;\npub use tabbed_display::TabbedDisplay;\n","traces":[],"covered":0,"coverable":0}]};
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      },
    };
  });

  return [...folders, ...files.filter(file => file.path.length === 1)];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener('hashchange', () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.slice(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(
      ({current}) => {
        return {current: [...current, file.path[0]]};
      },
      () => this.updateHash(),
    );
  }

  back(file) {
    this.setState(
      ({current}) => {
        return {current: current.slice(0, current.length - 1)};
      },
      () => this.updateHash(),
    );
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e(
    'div',
    {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e(
      'table',
      {className: 'files-list'},
      e('thead', {className: 'files-list__head'}, e('tr', null, e('th', null, 'Path'), e('th', null, 'Coverage'))),
      e(
        'tbody',
        {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile})),
      ),
    ),
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? (file.covered / file.coverable) * 100 : -1;
  const coverageDelta =
    file.prevRun && (file.covered / file.coverable) * 100 - (file.prevRun.covered / file.prevRun.coverable) * 100;

  return e(
    'tr',
    {
      className:
        'files-list__file' +
        (coverage >= 0 && coverage < 50 ? ' files-list__file_low' : '') +
        (coverage >= 50 && coverage < 80 ? ' files-list__file_medium' : '') +
        (coverage >= 80 ? ' files-list__file_high' : '') +
        (file.is_folder ? ' files-list__file_folder' : ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e(
      'td',
      null,
      file.covered + ' / ' + file.coverable + (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e(
        'span',
        {title: 'Change from the previous run'},
        coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : '',
      ),
    ),
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'}, e(FileHeader, {file, onBack}), e(FileContent, {file}));
}

function FileHeader({file, onBack}) {
  const coverage = (file.covered / file.coverable) * 100;
  const coverageDelta = file.prevRun && coverage - (file.prevRun.covered / file.prevRun.coverable) * 100;

  return e(
    'div',
    {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e(
      'div',
      {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable + (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e(
        'span',
        {title: 'Change from the previous run'},
        coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : '',
      ),
      e('input', {id: 'theme-toggle', type: 'checkbox', hidden: true}),
      e('label', {for: 'theme-toggle', id: 'theme-toggle-label'}, ''),
    ),
  );
}

function FileContent({file}) {
  return e(
    'pre',
    {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e(
        'code',
        {
          className: 'code-line' + (covered ? ' code-line_covered' : '') + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        },
        line,
      );
    }),
  );
}

(function () {
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData &&
    previousData.files.forEach(file => {
      const path = file.path.slice(commonPath.length).join('/');
      prevFilesMap.set(path, file);
    });

  const files = data.files.map(file => {
    const path = file.path.slice(commonPath.length);
    const {covered = 0, coverable = 0} = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: {covered, coverable},
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    },
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));

  const toggle = document.getElementById('theme-toggle');
  const label = document.getElementById('theme-toggle-label');
  label.textContent = '';

  toggle.addEventListener('change', () => {
    if (toggle.checked) {
      document.documentElement.setAttribute('data-theme', 'dark');
      label.textContent = '';
    } else {
      document.documentElement.removeAttribute('data-theme');
      label.textContent = '';
    }
  });
})();
</script>
</body>
</html>